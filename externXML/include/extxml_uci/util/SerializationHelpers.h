/** @file SerializationHelpers.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:20 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef EXTXML_UCI_UTIL_SERIALIZATIONHELPERS_H
#define EXTXML_UCI_UTIL_SERIALIZATIONHELPERS_H

#include <cstdint>
#include <iomanip>
#include <map>
#include <sstream>
#include <string>

#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>

#include "uci/base/UUID.h"
#include "../../xs/type/xmlSchemaPrimitives.h"

/**  */
namespace extxml_uci {

/**  */
namespace util {

/** . */
class SerializationHelpers {
public:
  /** .
    *
    * @param propTree .
    * @param nodeName .
    */
  static void addNamespaceAttribute(boost::property_tree::ptree& propTree, const std::string& nodeName);

  /** .
    *
    * @param propTree .
    * @param type .
    */
  static void addTypeAttribute(boost::property_tree::ptree& propTree, const std::string& type);

  /** .
    *
    * @param propTree .
    * @return .
    */
  static std::string checkForNamespacePrefix(const boost::property_tree::ptree& propTree);

  /** .
    *
    * @param propTree .
    * @param nsPrefix .
    * @return .
    */
  static uci::base::accessorType::AccessorType checkForTypeAttribute(const boost::property_tree::ptree& propTree, const std::string& nsPrefix);

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Boolean deserializeBoolean(const std::string& value) {
    return (value == "true");
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Byte deserializeByte(const std::string& value) {
    return static_cast<xs::Byte>(std::stoi(value));
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::DateTime deserializeDateTime(const std::string& value);

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Double deserializeDouble(const std::string& value) {
    return boost::lexical_cast<xs::Double>(value);
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Duration deserializeDuration(const std::string& value);

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Float deserializeFloat(const std::string& value) {
    return boost::lexical_cast<xs::Float>(value);
  }

  /** .
    *
    * @param value .
    * @param accessor .
    */
  static void deserializeHexBinary(const std::string& value, xs::HexBinary& accessor);

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Int deserializeInt(const std::string& value) {
    return static_cast<xs::Int>(std::stol(value));
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Long deserializeLong(const std::string& value) {
    return std::stoll(value);
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Short deserializeShort(const std::string& value) {
    return static_cast<xs::Short>(std::stoi(value));
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Time deserializeTime(const std::string& value);

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::UnsignedByte deserializeUnsignedByte(const std::string& value) {
    return static_cast<xs::UnsignedByte>(std::stoul(value));
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::UnsignedInt deserializeUnsignedInt(const std::string& value) {
    return std::stoul(value);
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::UnsignedShort deserializeUnsignedShort(const std::string& value) {
    return static_cast<xs::UnsignedShort>(std::stoul(value));
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static uci::base::UUID deserializeUUID(const std::string& value);

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeBoolean(const xs::Boolean& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, (accessor ? "true" : "false"));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeByte(const xs::Byte& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, std::to_string(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeDateTime(const xs::DateTime& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, getPrimitiveDateTime(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeDouble(const xs::Double& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, boost::lexical_cast<std::string>(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeDuration(const xs::Duration& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, getPrimitiveDuration(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeFloat(const xs::Float& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, boost::lexical_cast<std::string>(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeHexBinary(const xs::HexBinary& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, getPrimitiveHexBinary(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeInt(const xs::Int& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, std::to_string(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeLong(const xs::Long& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, std::to_string(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeShort(const xs::Short& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, std::to_string(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeString(const xs::String& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, accessor.str());
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeTime(const xs::Time& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, getPrimitiveTime(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeUnsignedByte(const xs::UnsignedByte& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, std::to_string(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeUnsignedInt(const xs::UnsignedInt& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, std::to_string(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeUnsignedShort(const xs::UnsignedShort& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(nodeName, std::to_string(accessor));
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeUUID(const uci::base::UUID& accessor, boost::property_tree::ptree& node, const std::string& nodeName);

  /** .
    *
    * @param nanoSecs .
    * @return .
    */
  static std::string getPrimitiveDateTime(xs::DateTime nanoSecs);

  /** .
    *
    * @param nanoSecs .
    * @return .
    */
  static std::string getPrimitiveDuration(xs::Duration nanoSecs);

  /** .
    *
    * @param hexBinary .
    * @return .
    */
  static std::string getPrimitiveHexBinary(const xs::HexBinary& hexBinary);

  /** .
    *
    * @param nanoSecs .
    * @return .
    */
  static std::string getPrimitiveTime(xs::Time nanoSecs);

  /** .
    *
    * @param timeNanosecs .
    * @return .
    */
  static std::string serializeDateTimeHelper(std::int64_t timeNanosecs);

private:
  static constexpr const char* uciNamespace{"https://www.vdl.afrl.af.mil/programs/oam"};
  static const std::map<std::string, std::string> xmlNamespaces;
};

} // namespace util

} // namespace extxml_uci

#endif // EXTXML_UCI_UTIL_SERIALIZATIONHELPERS_H
