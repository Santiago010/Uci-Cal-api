/** @file SerializationHelpers.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:23 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "extjson_uci/util/SerializationHelpers.h"

#include <chrono>
#include <cstddef>
#include <cstdint>
#include <iomanip>
#include <iterator>
#include <map>
#include <ratio>
#include <sstream>
#include <string>
#include <vector>

#include <boost/algorithm/hex.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/regex.hpp>

#include "extjson_uci/util/DerivedTypesTranslator.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "xs/type/binaryXmlSchemaPrimitives.h"
#include "xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace extjson_uci {

/**  */
namespace util {

const std::map<std::string, std::string> SerializationHelpers::xmlNamespaces{
  {"xmlns:xs", "http://www.w3.org/2001/XMLSchema"},
  {"xmlns", "https://www.vdl.afrl.af.mil/programs/oam"},
  {"xmlns:xhtml", "http://www.w3.org/1999/xhtml"},
  {"xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"}
};

void SerializationHelpers::addTypeAttribute(boost::property_tree::ptree& propTree, const std::string& type) {
  propTree.add("$type", type);
}

uci::base::accessorType::AccessorType SerializationHelpers::checkForTypeAttribute(const boost::property_tree::ptree& propTree, const std::string& nsPrefix) {
  const auto typeAttribute = propTree.get_child_optional("$type");
  if (typeAttribute) {
    const std::string typeAttributeData{typeAttribute.get().data()};
    std::string translationData{typeAttributeData};
    if ((!nsPrefix.empty()) && (typeAttributeData.find(nsPrefix) == 0)) {
      translationData = typeAttributeData.substr(nsPrefix.length());
    }
    return DerivedTypesTranslator::translateToAccessorType(translationData);
  }
  return uci::base::accessorType::null;
}

xs::DateTime SerializationHelpers::deserializeDateTime(const std::string& value) {
  const std::string::size_type period{value.find('.')};
  const std::string isoString{((period != std::string::npos) ? value.substr(0, period) : value)};
  std::string nanoString{"0"};
  if (period != std::string::npos) {
    const std::string valueAfterPeriod{value.substr(period + 1).substr(0,9)};
    const std::string::size_type zee{valueAfterPeriod.find('Z')};
    std::string nanoStringValue{((zee != std::string::npos) ? valueAfterPeriod.substr(0, zee) : valueAfterPeriod)};
    nanoString = nanoStringValue.append("000000000").substr(0, 9);
  }
  const std::string::size_type zee{isoString.find('Z')};
  const boost::posix_time::ptime ptime{boost::posix_time::from_iso_extended_string(((zee != std::string::npos) ? isoString.substr(0, zee) : isoString))};
  const std::int64_t time_t{boost::posix_time::to_time_t(ptime)};
  return static_cast<xs::DateTime>(time_t * 1000000000 + std::stoull(nanoString));
}

xs::Duration SerializationHelpers::deserializeDuration(const std::string& value) {
  // std::regex reg("P([[:d:]]+Y)?([[:d:]]+M)?([[:d:]]+D)?T([[:d:]]+H)?([[:d:]]+M)?([[:d:]]+S|[[:d:]]+\\.[[:d:]]+S)?");
  const boost::regex reg{"P([[:d:]]+D)?T([[:d:]]+H)?([[:d:]]+M)?([[:d:]]+S|[[:d:]]+\\.[[:d:]]+S)?"};
  std::chrono::nanoseconds nanoseconds{0};
  boost::smatch match;
  boost::regex_search(value, match, reg);
  if (match.empty()) {
    throw uci::base::UCIException("Unexpected value found when attempting to deserialize duration (" + value + ")");
  }
  if (match[1].matched) {
    using days = std::chrono::duration<std::int32_t, std::ratio<86400>>;
    std::string matchString = match[1];
    matchString.pop_back();
    const std::uint64_t matchValue{std::stoull(matchString)};
    nanoseconds += days(matchValue);
  }
  if (match[2].matched) {
    std::string matchString = match[2];
    matchString.pop_back();
    const std::uint64_t matchValue{std::stoull(matchString)};
    nanoseconds += std::chrono::hours(matchValue);
  }
  if (match[3].matched) {
    std::string matchString = match[3];
    matchString.pop_back();
    const std::uint64_t matchValue{std::stoull(matchString)};
    nanoseconds += std::chrono::minutes(matchValue);
  }
  if (match[4].matched) {
    std::string matchString = match[4];
    matchString.pop_back();
    std::uint64_t secs{0};
    std::uint64_t nanos{0};
    const std::string::size_type periodInMatchString{matchString.find('.')};
    if (periodInMatchString == std::string::npos) {
      secs = std::stoull(matchString);
    } else {
      secs = std::stoull(matchString.substr(0, periodInMatchString));
      const std::string nanosString{matchString.substr(periodInMatchString + 1) + "000000000"};
      nanos = std::stoull(nanosString.substr(0, 9));
    }
    nanoseconds += std::chrono::seconds(secs);
    nanoseconds += std::chrono::nanoseconds(nanos);
  }
  return nanoseconds.count();
}

void SerializationHelpers::deserializeHexBinary(const std::string& value, xs::HexBinary& accessor) {
  std::vector<std::uint8_t> hexVector;
  boost::algorithm::unhex(value, std::back_inserter(hexVector));
  accessor.clear();
  accessor.reserve(hexVector.size());
  for (const auto& hexValue : hexVector) {
    accessor.push_back(hexValue);
  }
}

xs::Time SerializationHelpers::deserializeTime(const std::string& value) {
  const std::string::size_type period{value.find('.')};
  const std::string isoString{((period != std::string::npos) ? value.substr(0, period) : value)};
  const std::string nanoString{((period != std::string::npos) ? value.substr(period + 1).substr(0, 9) : "0")};
  const boost::posix_time::ptime ptime{boost::posix_time::from_iso_extended_string("1970-01-01" + std::string(((isoString.at(0) == 'T') ? "" : "T")) + isoString)};
  const std::int64_t time_t{boost::posix_time::to_time_t(ptime)};
  return static_cast<xs::Time>(time_t * 1000000000 + std::stoull(nanoString));
}

std::string SerializationHelpers::getPrimitiveDateTime(const xs::DateTime nanoSecs) {
   return serializeDateTimeHelper(nanoSecs) + "Z";
}

std::string SerializationHelpers::getPrimitiveDuration(const xs::Duration nanoSecs) {
  const std::chrono::nanoseconds nanoseconds{nanoSecs};
  using days = std::chrono::duration<std::int32_t, std::ratio<86400>>;
  const days dayValue{std::chrono::duration_cast<days>(nanoseconds)};
  const std::chrono::hours hourValue{std::chrono::duration_cast<std::chrono::hours>(nanoseconds % days(1))};
  const std::chrono::minutes minuteValue{std::chrono::duration_cast<std::chrono::minutes>(nanoseconds % std::chrono::hours(1))};
  const std::chrono::seconds secondValue{std::chrono::duration_cast<std::chrono::seconds>(nanoseconds % std::chrono::minutes(1))};
  const std::chrono::nanoseconds nanoValue{std::chrono::duration_cast<std::chrono::nanoseconds>(nanoseconds % std::chrono::seconds(1))};
  std::stringstream timeSeconds;
  timeSeconds << "P";
  if (dayValue.count() > 0) {
    timeSeconds << dayValue.count() << "D";
  }
  timeSeconds << "T";
  if (hourValue.count() > 0) {
    timeSeconds << hourValue.count() << "H";
  }
  if (minuteValue.count() > 0) {
    timeSeconds << minuteValue.count() << "M";
  }
  timeSeconds << secondValue.count();
  if (nanoValue.count() > 0) {
    std::stringstream nanosecondsStringStream;
    nanosecondsStringStream << "." << std::setw(9) << std::setfill('0') << nanoValue.count();
    std::string nanosecondsString{nanosecondsStringStream.str()};
    nanosecondsString.erase(nanosecondsString.find_last_not_of('0') + 1, std::string::npos);
    timeSeconds << nanosecondsString;
  }
  timeSeconds << "S";
  return timeSeconds.str();
}

std::string SerializationHelpers::getPrimitiveHexBinary(const xs::HexBinary& hexBinary) {
  std::vector<std::uint8_t> hexVector;
  hexVector.reserve(hexBinary.size());
  for (size_t i = 0, hexBinarySize = hexBinary.size(); i < hexBinarySize; ++i) {
    hexVector.push_back(hexBinary[i]);
  }
  std::string hexString;
  boost::algorithm::hex(hexVector, std::back_inserter(hexString));
  return hexString;
}

std::string SerializationHelpers::getPrimitiveTime(const xs::Time nanoSecs) {
  const std::string convertedValue{serializeDateTimeHelper(nanoSecs)};
  // current reference/starterKit Java CAL impl doesn't like 'T' specified in ISO 8601-1:2019, omit for compatibility
  return convertedValue.substr(convertedValue.find('T') + 1) + "Z";
}

std::string SerializationHelpers::serializeDateTimeHelper(const std::int64_t timeNanosecs) {
  const std::int64_t seconds{timeNanosecs / 1000000000};
  const std::int64_t nanoseconds{timeNanosecs % 1000000000};
  const boost::posix_time::ptime ptime(boost::posix_time::from_time_t(seconds));
  std::string nanosecondsString;
  if (nanoseconds != 0) {
    std::stringstream nanosecondsStringStream;
    nanosecondsStringStream << std::setw(9) << std::setfill('0') << nanoseconds;
    nanosecondsString = "." + nanosecondsStringStream.str();
    nanosecondsString.erase(nanosecondsString.find_last_not_of('0') + 1, std::string::npos);
  }
  return boost::posix_time::to_iso_extended_string(ptime) + nanosecondsString;
}

} // namespace util

} // namespace extjson_uci

