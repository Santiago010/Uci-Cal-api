/** @file PlanningByCaseTriggerType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:23 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "extjson_uci/type/PlanningByCaseTriggerType.h"

#include <string>

#include <boost/optional/optional.hpp>
#include <boost/property_tree/ptree.hpp>

#include "extjson_uci/type/CapabilityTaxonomyType.h"
#include "extjson_uci/type/CommsLostTriggerDataType.h"
#include "extjson_uci/type/EnduranceType.h"
#include "extjson_uci/type/PlanVulnerabilityType.h"
#include "extjson_uci/type/RequirementFailedTriggerType.h"
#include "extjson_uci/type/RequirementTriggerType.h"
#include "extjson_uci/type/ResponseID_Type.h"
#include "extjson_uci/type/SatelliteEnduranceType.h"
#include "extjson_uci/type/SystemStateFilterType.h"
#include "extjson_uci/type/ThresholdOffOrbitTriggerDataType.h"
#include "extjson_uci/type/ThresholdOffRouteTriggerDataType.h"
#include "extjson_uci/type/ZoneViolationTriggerDataType.h"
#include "extjson_uci/util/DerivedTypesDeserializer.h"
#include "extjson_uci/util/SerializationHelpers.h"
#include "uci/type/PlanningByCaseTriggerType.h"

/**  */
namespace extjson_uci {

/** The namespace in which all generated data types are declared */
namespace type {

/**  */
namespace PlanningByCaseTriggerType_Names {

constexpr const char* Extern_Type_Name{"PlanningByCaseTriggerType"};
constexpr const char* CapabilityAdded_Name{"CapabilityAdded"};
constexpr const char* CapabilityFailure_Name{"CapabilityFailure"};
constexpr const char* CommsLost_Name{"CommsLost"};
constexpr const char* DMPI_OverDesignation_Name{"DMPI_OverDesignation"};
constexpr const char* DMPI_UnderDesignation_Name{"DMPI_UnderDesignation"};
constexpr const char* EnduranceLow_Name{"EnduranceLow"};
constexpr const char* OffRoute_Name{"OffRoute"};
constexpr const char* ProximityConflict_Name{"ProximityConflict"};
constexpr const char* ReleasePointOutsideLAR_Name{"ReleasePointOutsideLAR"};
constexpr const char* RouteConflict_Name{"RouteConflict"};
constexpr const char* RouteVulnerability_Name{"RouteVulnerability"};
constexpr const char* SystemStateChange_Name{"SystemStateChange"};
constexpr const char* RequirementAdded_Name{"RequirementAdded"};
constexpr const char* RequirementDependencyFailed_Name{"RequirementDependencyFailed"};
constexpr const char* RequirementDropped_Name{"RequirementDropped"};
constexpr const char* RequirementFailed_Name{"RequirementFailed"};
constexpr const char* RequirementChange_Name{"RequirementChange"};
constexpr const char* RequirementTiming_Name{"RequirementTiming"};
constexpr const char* ZoneViolation_Name{"ZoneViolation"};
constexpr const char* OrbitConflict_Name{"OrbitConflict"};
constexpr const char* OffPlannedOrbit_Name{"OffPlannedOrbit"};
constexpr const char* SpacecraftEnduranceLow_Name{"SpacecraftEnduranceLow"};
constexpr const char* SpacecraftProximityConflict_Name{"SpacecraftProximityConflict"};
constexpr const char* ResponseID_Name{"ResponseID"};

} // namespace PlanningByCaseTriggerType_Names

bool PlanningByCaseTriggerType::deserialize(const boost::property_tree::ptree& propTree, uci::type::PlanningByCaseTriggerType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = PlanningByCaseTriggerType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::CapabilityAdded_Name) {
      CapabilityTaxonomyType::deserialize(valueType.second, accessor.chooseCapabilityAdded(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::CapabilityFailure_Name) {
      CapabilityTaxonomyType::deserialize(valueType.second, accessor.chooseCapabilityFailure(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::CommsLost_Name) {
      CommsLostTriggerDataType::deserialize(valueType.second, accessor.chooseCommsLost(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::DMPI_OverDesignation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseDMPI_OverDesignation().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::DMPI_UnderDesignation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseDMPI_UnderDesignation().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::EnduranceLow_Name) {
      EnduranceType::deserialize(valueType.second, accessor.chooseEnduranceLow(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::OffRoute_Name) {
      ThresholdOffRouteTriggerDataType::deserialize(valueType.second, accessor.chooseOffRoute(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::ProximityConflict_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseProximityConflict().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::ReleasePointOutsideLAR_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseReleasePointOutsideLAR().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RouteConflict_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseRouteConflict().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RouteVulnerability_Name) {
      PlanVulnerabilityType::deserialize(valueType.second, accessor.chooseRouteVulnerability(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::SystemStateChange_Name) {
      SystemStateFilterType::deserialize(valueType.second, accessor.chooseSystemStateChange(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementAdded_Name) {
      extjson_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseRequirementAdded(extjson_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementDependencyFailed_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseRequirementDependencyFailed().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementDropped_Name) {
      extjson_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseRequirementDropped(extjson_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementFailed_Name) {
      RequirementFailedTriggerType::deserialize(valueType.second, accessor.chooseRequirementFailed(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementChange_Name) {
      extjson_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseRequirementChange(extjson_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementTiming_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseRequirementTiming().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::ZoneViolation_Name) {
      ZoneViolationTriggerDataType::deserialize(valueType.second, accessor.chooseZoneViolation(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::OrbitConflict_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseOrbitConflict().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::OffPlannedOrbit_Name) {
      ThresholdOffOrbitTriggerDataType::deserialize(valueType.second, accessor.chooseOffPlannedOrbit(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::SpacecraftEnduranceLow_Name) {
      SatelliteEnduranceType::deserialize(valueType.second, accessor.chooseSpacecraftEnduranceLow(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::SpacecraftProximityConflict_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseSpacecraftProximityConflict().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::ResponseID_Name) {
      ResponseID_Type::deserialize(valueType.second, accessor.chooseResponseID(), nodeName, nsPrefix);
    }
  }
  return true;
}

std::string PlanningByCaseTriggerType::serialize(const uci::type::PlanningByCaseTriggerType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{nodeName.empty() ? PlanningByCaseTriggerType_Names::Extern_Type_Name : nodeName};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    extjson_uci::util::SerializationHelpers::addTypeAttribute(node, PlanningByCaseTriggerType_Names::Extern_Type_Name);
  }
  if (accessor.isCapabilityAdded()) {
    CapabilityTaxonomyType::serialize(accessor.getCapabilityAdded(), node, PlanningByCaseTriggerType_Names::CapabilityAdded_Name);
  } else if (accessor.isCapabilityFailure()) {
    CapabilityTaxonomyType::serialize(accessor.getCapabilityFailure(), node, PlanningByCaseTriggerType_Names::CapabilityFailure_Name);
  } else if (accessor.isCommsLost()) {
    CommsLostTriggerDataType::serialize(accessor.getCommsLost(), node, PlanningByCaseTriggerType_Names::CommsLost_Name);
  } else if (accessor.isDMPI_OverDesignation()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getDMPI_OverDesignation(), node, PlanningByCaseTriggerType_Names::DMPI_OverDesignation_Name);
  } else if (accessor.isDMPI_UnderDesignation()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getDMPI_UnderDesignation(), node, PlanningByCaseTriggerType_Names::DMPI_UnderDesignation_Name);
  } else if (accessor.isEnduranceLow()) {
    EnduranceType::serialize(accessor.getEnduranceLow(), node, PlanningByCaseTriggerType_Names::EnduranceLow_Name);
  } else if (accessor.isOffRoute()) {
    ThresholdOffRouteTriggerDataType::serialize(accessor.getOffRoute(), node, PlanningByCaseTriggerType_Names::OffRoute_Name);
  } else if (accessor.isProximityConflict()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getProximityConflict(), node, PlanningByCaseTriggerType_Names::ProximityConflict_Name);
  } else if (accessor.isReleasePointOutsideLAR()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getReleasePointOutsideLAR(), node, PlanningByCaseTriggerType_Names::ReleasePointOutsideLAR_Name);
  } else if (accessor.isRouteConflict()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getRouteConflict(), node, PlanningByCaseTriggerType_Names::RouteConflict_Name);
  } else if (accessor.isRouteVulnerability()) {
    PlanVulnerabilityType::serialize(accessor.getRouteVulnerability(), node, PlanningByCaseTriggerType_Names::RouteVulnerability_Name);
  } else if (accessor.isSystemStateChange()) {
    SystemStateFilterType::serialize(accessor.getSystemStateChange(), node, PlanningByCaseTriggerType_Names::SystemStateChange_Name);
  } else if (accessor.isRequirementAdded()) {
    RequirementTriggerType::serialize(accessor.getRequirementAdded(), node, PlanningByCaseTriggerType_Names::RequirementAdded_Name);
  } else if (accessor.isRequirementDependencyFailed()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getRequirementDependencyFailed(), node, PlanningByCaseTriggerType_Names::RequirementDependencyFailed_Name);
  } else if (accessor.isRequirementDropped()) {
    RequirementTriggerType::serialize(accessor.getRequirementDropped(), node, PlanningByCaseTriggerType_Names::RequirementDropped_Name);
  } else if (accessor.isRequirementFailed()) {
    RequirementFailedTriggerType::serialize(accessor.getRequirementFailed(), node, PlanningByCaseTriggerType_Names::RequirementFailed_Name);
  } else if (accessor.isRequirementChange()) {
    RequirementTriggerType::serialize(accessor.getRequirementChange(), node, PlanningByCaseTriggerType_Names::RequirementChange_Name);
  } else if (accessor.isRequirementTiming()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getRequirementTiming(), node, PlanningByCaseTriggerType_Names::RequirementTiming_Name);
  } else if (accessor.isZoneViolation()) {
    ZoneViolationTriggerDataType::serialize(accessor.getZoneViolation(), node, PlanningByCaseTriggerType_Names::ZoneViolation_Name);
  } else if (accessor.isOrbitConflict()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getOrbitConflict(), node, PlanningByCaseTriggerType_Names::OrbitConflict_Name);
  } else if (accessor.isOffPlannedOrbit()) {
    ThresholdOffOrbitTriggerDataType::serialize(accessor.getOffPlannedOrbit(), node, PlanningByCaseTriggerType_Names::OffPlannedOrbit_Name);
  } else if (accessor.isSpacecraftEnduranceLow()) {
    SatelliteEnduranceType::serialize(accessor.getSpacecraftEnduranceLow(), node, PlanningByCaseTriggerType_Names::SpacecraftEnduranceLow_Name);
  } else if (accessor.isSpacecraftProximityConflict()) {
    extjson_uci::util::SerializationHelpers::serializeString(accessor.getSpacecraftProximityConflict(), node, PlanningByCaseTriggerType_Names::SpacecraftProximityConflict_Name);
  } else if (accessor.isResponseID()) {
    ResponseID_Type::serialize(accessor.getResponseID(), node, PlanningByCaseTriggerType_Names::ResponseID_Name);
  }
  if (createNode) {
    propTree.add_child(boost::property_tree::ptree::path_type(generatedNodeName, '#'), node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace extjson_uci

