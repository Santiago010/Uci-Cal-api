/** @file SerializationHelpers.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:23 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef EXTJSON_UCI_UTIL_SERIALIZATIONHELPERS_H
#define EXTJSON_UCI_UTIL_SERIALIZATIONHELPERS_H

#include <cstdint>
#include <iomanip>
#include <map>
#include <sstream>
#include <string>

#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>

#include "uci/base/UUID.h"
#include "../../xs/type/xmlSchemaPrimitives.h"

/**  */
namespace extjson_uci {

/**  */
namespace util {

/** . */
class SerializationHelpers {
public:
  /** .
    *
    * @param propTree .
    * @param type .
    */
  static void addTypeAttribute(boost::property_tree::ptree& propTree, const std::string& type);

  /** .
    *
    * @param propTree .
    * @param nsPrefix .
    * @return .
    */
  static uci::base::accessorType::AccessorType checkForTypeAttribute(const boost::property_tree::ptree& propTree, const std::string& nsPrefix);

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Boolean deserializeBoolean(const std::string& value) {
    return (value == "true");
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeBooleanList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setBooleanValue(deserializeBoolean(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Byte deserializeByte(const std::string& value) {
    return static_cast<xs::Byte>(std::stoi(value));
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeByteList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setByteValue(deserializeByte(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::DateTime deserializeDateTime(const std::string& value);

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeDateTimeList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setDateTimeValue(deserializeDateTime(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Double deserializeDouble(const std::string& value) {
    return boost::lexical_cast<xs::Double>(value);
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeDoubleList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setDoubleValue(deserializeDouble(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Duration deserializeDuration(const std::string& value);

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeDurationList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setDurationValue(deserializeDuration(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Float deserializeFloat(const std::string& value) {
    return boost::lexical_cast<xs::Float>(value);
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeFloatList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setFloatValue(deserializeFloat(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @param accessor .
    */
  static void deserializeHexBinary(const std::string& value, xs::HexBinary& accessor);

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeHexBinaryList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        deserializeHexBinary(*value, boundedList.at(boundedListSize));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Int deserializeInt(const std::string& value) {
    return static_cast<xs::Int>(std::stol(value));
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeIntList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setIntValue(deserializeInt(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Long deserializeLong(const std::string& value) {
    return std::stoll(value);
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeLongList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setLongValue(deserializeLong(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Short deserializeShort(const std::string& value) {
    return static_cast<xs::Short>(std::stoi(value));
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeShortList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setShortValue(deserializeShort(*value));
      }
    }
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeStringList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setStringValue(*value);
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::Time deserializeTime(const std::string& value);

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeTimeList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setTimeValue(deserializeTime(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::UnsignedByte deserializeUnsignedByte(const std::string& value) {
    return static_cast<xs::UnsignedByte>(std::stoul(value));
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeUnsignedByteList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setUnsignedByteValue(deserializeUnsignedByte(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::UnsignedInt deserializeUnsignedInt(const std::string& value) {
    return std::stoul(value);
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeUnsignedIntList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setUnsignedIntValue(deserializeUnsignedInt(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static xs::UnsignedShort deserializeUnsignedShort(const std::string& value) {
    return static_cast<xs::UnsignedShort>(std::stoul(value));
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeUnsignedShortList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setUnsignedShortValue(deserializeUnsignedShort(*value));
      }
    }
  }

  /** .
    *
    * @param value .
    * @return .
    */
  static uci::base::UUID deserializeUUID(const std::string& value) {
    return uci::base::UUID::fromString(value);
  }

  /** .
    *
    * @param propTree .
    * @param boundedList .
    */
  template<typename T>
  static void deserializeUUIDList(const boost::property_tree::ptree& propTree, T& boundedList) {
    for (const boost::property_tree::ptree::value_type& valueType : propTree.get_child("")) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        const typename T::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize) = deserializeUUID(*value);
      }
    }
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeBoolean(const xs::Boolean& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + std::string{accessor ? "true" : "false"} + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeBooleanList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + std::string{boundedList.at(i) ? "true" : "false"} + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeByte(const xs::Byte& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + std::to_string(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeByteList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + std::to_string(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeDateTime(const xs::DateTime& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), getPrimitiveDateTime(accessor));
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeDateTimeList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(getPrimitiveDateTime(boundedList.at(i)))));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeDouble(const xs::Double& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + boost::lexical_cast<std::string>(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeDoubleList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + boost::lexical_cast<std::string>(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeDuration(const xs::Duration& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), getPrimitiveDuration(accessor));
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeDurationList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(getPrimitiveDuration(boundedList.at(i)))));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeFloat(const xs::Float& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + boost::lexical_cast<std::string>(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeFloatList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + boost::lexical_cast<std::string>(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeHexBinary(const xs::HexBinary& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), getPrimitiveHexBinary(accessor));
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeHexBinaryList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(getPrimitiveHexBinary(boundedList.at(i)))));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeInt(const xs::Int& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + std::to_string(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeIntList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + std::to_string(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeLong(const xs::Long& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + std::to_string(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeLongList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + std::to_string(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeShort(const xs::Short& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + std::to_string(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeShortList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + std::to_string(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeString(const xs::String& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), accessor.str());
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeStringList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(boundedList.at(i).str())));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeTime(const xs::Time& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), getPrimitiveTime(accessor));
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeTimeList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(getPrimitiveTime(boundedList.at(i)))));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeUnsignedByte(const xs::UnsignedByte& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + std::to_string(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeUnsignedByteList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + std::to_string(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeUnsignedInt(const xs::UnsignedInt& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + std::to_string(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeUnsignedIntList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + std::to_string(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeUnsignedShort(const xs::UnsignedShort& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), delimBegin + std::to_string(accessor) + delimEnd);
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeUnsignedShortList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(delimBegin + std::to_string(boundedList.at(i)) + delimEnd)));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param accessor .
    * @param node .
    * @param nodeName .
    */
  static void serializeUUID(const uci::base::UUID& accessor, boost::property_tree::ptree& node, const std::string& nodeName) {
    node.add(boost::property_tree::ptree::path_type(nodeName, '#'), accessor.toString());
  }

  /** .
    *
    * @param boundedList .
    * @param node .
    * @param nodeName .
    */
  template<typename T>
  static void serializeUUIDList(const T& boundedList, boost::property_tree::ptree& node, const std::string& nodeName) {
    boost::property_tree::ptree newNode;
    for (typename T::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      newNode.push_back(boost::property_tree::ptree::value_type("", boost::property_tree::ptree(boundedList.at(i).toString())));
    }
    node.add_child(boost::property_tree::ptree::path_type(nodeName, '#'), newNode);
  }

  /** .
    *
    * @param nanoSecs .
    * @return .
    */
  static std::string getPrimitiveDateTime(xs::DateTime nanoSecs);

  /** .
    *
    * @param nanoSecs .
    * @return .
    */
  static std::string getPrimitiveDuration(xs::Duration nanoSecs);

  /** .
    *
    * @param hexBinary .
    * @return .
    */
  static std::string getPrimitiveHexBinary(const xs::HexBinary& hexBinary);

  /** .
    *
    * @param nanoSecs .
    * @return .
    */
  static std::string getPrimitiveTime(xs::Time nanoSecs);

  /** .
    *
    * @param timeNanosecs .
    * @return .
    */
  static std::string serializeDateTimeHelper(std::int64_t timeNanosecs);

  static constexpr const char* delimBegin{"#DB#"};
  static constexpr const char* delimEnd{"#DE#"};

private:
  static constexpr const char* uciNamespace{"https://www.vdl.afrl.af.mil/programs/oam"};
  static const std::map<std::string, std::string> xmlNamespaces;
};

} // namespace util

} // namespace extjson_uci

#endif // EXTJSON_UCI_UTIL_SERIALIZATIONHELPERS_H
