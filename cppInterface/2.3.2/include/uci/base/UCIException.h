/** @file UCIException.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:05 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef UCI_BASE_UCIEXCEPTION_H
#define UCI_BASE_UCIEXCEPTION_H

#include <stdint.h>

#include <sstream>
#include <stdexcept>
#include <string>

/** The following macro is used to support the deprecation and removal of exception specifications in newer C++
  * standards. The targeted__cplusplus macro can be defined to override the __cplusplus macro provided by the compiler.
  */
#if ((defined(targeted__cplusplus) && targeted__cplusplus >= 201103L) || \
  (!defined(targeted__cplusplus) && defined(__cplusplus) && __cplusplus >= 201103L))
#define noexception noexcept
#else
#define noexception throw()
#endif

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all base data types are declared */
namespace base {

/** The UCIException is the base class of all exceptions that are thrown by the CAL methods */
class UCIException : public virtual std::runtime_error {
public:

  /** A numerical value that identifies the cause of an exception. */
  typedef uint32_t ErrorCode;

  /** The constructor.
    *
    * @param reason The reason why the exception was thrown.
    * @param errorCode The error code associated with the exception.
    */
  explicit UCIException(const std::string& reason, ErrorCode errorCode = 0)
    : std::runtime_error(reason),
      m_errorCode(errorCode) {
  }

  /** The constructor.
    *
    * @param reason The reason why the exception was thrown.
    * @param errorCode The error code associated with the exception.
    */
  explicit UCIException(const char* reason, ErrorCode errorCode = 0)
    : std::runtime_error(reason),
      m_errorCode(errorCode) {
  }

  /** The constructor.
    *
    * @param reason The reason why the exception was thrown.
    * @param errorCode The error code associated with the exception.
    */
  explicit UCIException(const std::ostringstream& reason, ErrorCode errorCode = 0)
    : std::runtime_error(reason.str()),
      m_errorCode(errorCode) {
  }

  /** The destructor. */
  ~UCIException() noexception {
  }

  /** Returns this exception's error code.
    *
    * @return This exception's error code.
    */
  ErrorCode getErrorCode() const noexception {
    return m_errorCode;
  }

protected:

  /** The error code that identifies the cause of the exception (may not be available for all exceptions) */
  ErrorCode m_errorCode;

private:

  /** The assignment operator. Sets the contents of this UCIException to the contents of the UCIException on the right hand
    * side (rhs) of the assignment operator [not supported].
    *
    * @param rhs The UCIException on the right hand side (rhs) of the assignment operator whose contents are used to set
    *      the contents of this UCIException.
    * @return A reference to this UCIException.
    */
  UCIException& operator=(const UCIException& rhs);

};

} // namespace base
} // namespace uci

/** The following macro is provided for ease-of-use. It provides support for throwing an exception using a stream to
  * construct the reason for why the exception was thrown. For example, one could write the following:
  *
  * throwUciException("A reason: value = " << value);
  */
#define throwUciException(message) \
  do { \
    std::ostringstream oStream; \
    oStream << message; \
    throw ::uci::base::UCIException(oStream); \
  } while (false)

#endif // UCI_BASE_UCIEXCEPTION_H

