/** @file UUID.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:05 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef UCI_BASE_UUID_H
#define UCI_BASE_UUID_H

#include <stdint.h>

#include <cstddef>
#include <vector>

#include "UCIException.h"
#include "export.h"
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all base data types are declared */
namespace base {

/** UUID is the base class of all UUID classes that are used to specify a unique ID.
  *
  * A UUID is an 128-bit identifier that can be used to uniquely identify anything. From the UUIDspecification (IETF
  * rsf4122.txt):
  *
  *   One of the main reasons for using UUIDs is that no centralized authority is required to administer them (although
  *   one format uses IEEE 802 node identifiers, others do not). As a result, generation on demand can be completely
  *   automated, and used for a variety of purposes. The UUID generation algorithm described here supports very high
  *   allocation rates of up to 10 million per second per machine if necessary, so that they could even be used as
  *   transaction IDs.
  *
  *   UUIDs are of a fixed size (128 bits) which is reasonably small compared to other alternatives. This lends itself
  *   well to sorting, ordering, and hashing of all sorts, storing in databases, simple allocation, and ease of
  *   programming in general.
  *
  *   Since UUIDs are unique and persistent, they make excellent Uniform Resource Names. The unique ability to generate a
  *   new UUID without a registration process allows for UUIDs to be one of the URNs with the lowest minting cost.
  *
  * For the "time-based" UUID, the format of the stringified version of the UUID is as follows:
  *
  *
  *   UUID                   = time-low "-" time-mid "-" time-high-and-version "-" clock-seq-and-reserved clock-seq-low "-" node
  *   time-low               = 4hexOctet
  *   time-mid               = 2hexOctet
  *   time-high-and-version  = 2hexOctet
  *   clock-seq-and-reserved = hexOctet
  *   clock-seq-low          = hexOctet
  *   node                   = 6hexOctet
  *   hexOctet               = hexDigit hexDigit
  *   hexDigit               = "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
  *                            "a" / "b" / "c" / "d" / "e" / "f"
  *                            "A" / "B" / "C" / "D" / "E" / "F"
  *
  */
class UUID : public boost::uuids::uuid {
public:

  // === Common Typedefs, Constants, Enumerations, etc. ==================================================================

  /** The number of octets that are containted in a UUID */
  static const size_t m_numberOfOctets = 16;

  /** The number of bytes used to specify a node address. */
  static const size_t m_sizeOfNodeAddress = 6;

  /** The Octet is the data type used to hold two hexadecimal digits, each represented using 4 bits.The Octet is declared
    * to be of a single atomic type as oppposed to a container of types (array, vector, etc) so that it's usage better
    * aligns with the UUID specification. The most significant hexadecimal digit (4 bits) is stored in the most significant
    * 4 bits of the Octet while the least significant hexadecimal digit (4 bits) is stored in the least signficant 4 bits
    * of the Octet.
    */
  typedef uint8_t Octet;

  /** Octets is a vector containing a set of octets. This vector can be used to set and get the value of a UUID. The size
    * of a valid Octets vector shall be m_numberOfOctets. The octets are ordered in the vector in network ordering, i.e.
    * big-endian ordering, such that the most significant octet is found in the first element of the vector, i.e.
    * octets[0], and the least significant octet is found in the last element of the vector, i.e. octets[m_numberOfOctets -
    * 1].
    */
  typedef std::vector<Octet> Octets;

  /** The node address is used to uniquely identify the processing node on a network of processing nodes that created the
    * UUID. In many cases, this is the MAC address of the device used by the processor that created this UUID. The size of
    * a valid Octets vector shall be m_sizeOfNodeAddress. The data is ordered in the vector in network ordering, i.e.
    * big-endian ordering, such that the most significant unsigned 8-bit integer is found in the first element of the
    * vector, i.e. nodeAddress[0], and the least significant unsigned 8-bit integer is found in the last element of the
    * vector, i.e. nodeAddress[m_sizeOfNodeAddress - 1].
    */
  typedef std::vector<uint8_t> NodeAddress;

  /** The timestamp is used to record the current time. The bytes contained within the timestamp will be ordered in network
    * ordering, i.e. big-endian ordering.
    */
  typedef uint64_t Timestamp;

  /** The clock sequence is the additional sequence that is combined with the current timestamp in order to produce a
    * unique time. The bytes contained within the timestamp will be ordered in network ordering, i.e. big-endian ordering.
    */
  typedef uint16_t ClockSequence;

  /** The Variant is an enumeration of the UUID variants as specified in RFC 4122. A UUID variant specifies the layout of
    * the octets contains in the UUID.
    */
  enum Variant {
    /** NCS backward compatibility */
    variantNCS = 0,

    /** Microsoft Corporation backward compatibility */
    variantMicrosoft = 6,

    /** The currently supported variant type. All OMS UUIDs will be of this variant. */
    variantCurrent = 2,

    /** Future variant specification */
    variantFuture = 7,

    /** This enumerated value is used to identify that the UUID is a variant of an unknown type, possibly indicating a
      * corruption of the UUID.
      */
    variantUnknown = 8

  };

  /** The Version is an enumeration of the UUID versions as specified in RFC 4122. The version specifies how the data
    * contained within the UUID is generated and interpreted.
    */
  enum Version {
    /** UUIDs of this version should have all zero values. */
    versionNil = 0,

    /** UUIDs of this version have the values generated following the time-base specification laid out in the IETF UUID
      * specification. Basically the UUID is generated by combining the current time with the processor's ethernet hardware
      * address, i.e. it's MAC address.
      */
    versionTimeBased = 1,

    /** UUIDs of this version have the values generated following the DCE security specification with embedded POSIX UIDs. */
    versionDceSecurity = 2,

    /** UUIDs of this version have the values generated using hash values generated by the MD5 algorithm applied to some set
      * of names.
      */
    versionNameBasedMD5 = 3,

    /** UUIDs of this version have the values generated using some random or pseudo random generator. This version is also
      * specified in the IETF UUID specification.
      */
    versionRandomNumber = 4,

    /** UUIDs of this version have the values generated using hash values generated by the SHA1 algorithm applied to some set
      * of names.
      */
    versionNameBasedSHA1 = 5,

    /** This enumerated value is used to identify that the UUID was generated by an unknown process, possibly indicating a
      * corruption of the UUID.
      */
    versionUnknown = 16

  };

  /** The ValueUUID is a 128-bit data type that contains the value of the UUID expressed as two 64-bit values. */
  struct ValueUUID {

    /** The most significant 64 bits, i.e., the most significant 16 hexadecimal digits, of the UUID. The hexadecimal digits
      * are stored in network ordering, i.e., big endian ordering.
      */
    uint64_t mostSignificantBits;

    /** The least significant 64 bits, i.e., the least significant 16 hexadecimal digits, of the UUID. The hexadecimal digits
      * are stored in network ordering, i.e., big endian ordering.
      */
    uint64_t leastSignificantBits;

  };

  /** This constructor initializes the UUID using a value UUID that defaults to the nil UUID.
    *
    * @param value The ValueUUID used to initialize the UUID.
    */
  explicit UUID(const ValueUUID& value = ValueUUID())
    : m_value(value) {
  }

  /** This constructor initializes the UUID using two 64-bit integers representing the most significant bits and the least
    * significant bits of the UUID in big-endian byte order.
    *
    * @param mostSignificantBits The most significant bits of the UUID as a big-endian, 64-bit integer.
    * @param leastSignificantBits The least significant bits of the UUID as a big-endian, 64-bit integer.
    */
  UUID(uint64_t mostSignificantBits, uint64_t leastSignificantBits) {
    m_value.mostSignificantBits = mostSignificantBits;
    m_value.leastSignificantBits = leastSignificantBits;
  }

  /** This constructor initializes the UUID using a stringified UUID formatted as specified in RFC 4122.
    *
    * @param stringifiedUUID A UUID expressed as a string as specified in RFC 4122.
    */
  UUID(const char* stringifiedUUID) {
    if (!stringifiedUUID) {
      throwUciException("UUID string cannot be NULL");
    }

    *this = fromString(stringifiedUUID);
  }

  /** This constructor initializes the UUID to the value of the UUID parameter.
    *
    * @param rhs The UUID whose contents are used to initialize the contents of the newly constructed UUID.
    */
  UUID(const UUID& rhs) {
    m_value.mostSignificantBits = rhs.m_value.mostSignificantBits;
    m_value.leastSignificantBits = rhs.m_value.leastSignificantBits;
  }

  /** Sets the value of the UUID to the value of the specified UUID (rhs).
    *
    * @param rhs The UUID on the right hand side (rhs) of the assignment operator that is used to set this UUID.
    * @return A reference to this UUID.
    */
  UUID& operator=(const UUID& rhs) {
    if (this == &rhs) {
      return *this;
    }

    m_value.mostSignificantBits = rhs.m_value.mostSignificantBits;
    m_value.leastSignificantBits = rhs.m_value.leastSignificantBits;
    return *this;
  }

  // === Getter methods ==================================================================================================

  /** Returns the value of the UUID expressed as a vector of octets.
    *
    * @return The value of the UUID expressed as a vector of octets.
    */
  Octets getOctets() const {
    Octets octets;

    octets.reserve(m_numberOfOctets);
    octets.push_back(static_cast<Octet>(m_value.mostSignificantBits >> 56));
    octets.push_back(static_cast<Octet>(m_value.mostSignificantBits >> 48));
    octets.push_back(static_cast<Octet>(m_value.mostSignificantBits >> 40));
    octets.push_back(static_cast<Octet>(m_value.mostSignificantBits >> 32));
    octets.push_back(static_cast<Octet>(m_value.mostSignificantBits >> 24));
    octets.push_back(static_cast<Octet>(m_value.mostSignificantBits >> 16));
    octets.push_back(static_cast<Octet>(m_value.mostSignificantBits >> 8));
    octets.push_back(static_cast<Octet>(m_value.mostSignificantBits >> 0));
    octets.push_back(static_cast<Octet>(m_value.leastSignificantBits >> 56));
    octets.push_back(static_cast<Octet>(m_value.leastSignificantBits >> 48));
    octets.push_back(static_cast<Octet>(m_value.leastSignificantBits >> 40));
    octets.push_back(static_cast<Octet>(m_value.leastSignificantBits >> 32));
    octets.push_back(static_cast<Octet>(m_value.leastSignificantBits >> 24));
    octets.push_back(static_cast<Octet>(m_value.leastSignificantBits >> 16));
    octets.push_back(static_cast<Octet>(m_value.leastSignificantBits >> 8));
    octets.push_back(static_cast<Octet>(m_value.leastSignificantBits >> 0));

    return octets;
  }

  /** Returns the value of the UUID expressed as a ValueUUID.
    *
    * @return The value of the UUID expressed as a ValueUUID.
    */
  ValueUUID getValueUUID() const {
    return m_value;
  }

  /** Returns the value of the UUID expressed as a string formatted according to the RFC 4122 specification.
    *
    * @return The value of the UUID expressed as a string.
    */
  std::string toString() const {
    std::string stringifiedUUID;

    stringifiedUUID.reserve(36);
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 60) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 56) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 52) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 48) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 44) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 40) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 36) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 32) & 0xF)));
    stringifiedUUID.push_back('-');
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 28) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 24) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 20) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 16) & 0xF)));
    stringifiedUUID.push_back('-');
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 12) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 8) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.mostSignificantBits >> 4) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>(m_value.mostSignificantBits & 0xF)));
    stringifiedUUID.push_back('-');
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 60) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 56) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 52) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 48) & 0xF)));
    stringifiedUUID.push_back('-');
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 44) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 40) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 36) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 32) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 28) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 24) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 20) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 16) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 12) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 8) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>((m_value.leastSignificantBits >> 4) & 0xF)));
    stringifiedUUID.push_back(toChar(static_cast<uint8_t>(m_value.leastSignificantBits & 0xF)));

    return stringifiedUUID;
  }

  // === Class Information ===============================================================================================

  /** Returns the variant of the UUID.
    *
    * @return The variant of the UUID.
    */
  Variant getVariant() const {
    //  According to the specification, the variant is in high order bits of octet 8.
    Octet octet = static_cast<Octet>(m_value.leastSignificantBits >> 56);

    //  Test for NCS variant: variant = 0xxx
    if ((octet & 0x80) == 0x00) {
      return variantNCS;
    }

    //  Test for current variant: variant = 10xx
    if ((octet & 0xC0) == 0x80) {
      return variantCurrent;
    }

    //  Test for microsoft variant: variant = 110x
    if ((octet & 0xE0) == 0xC0) {
      return variantMicrosoft;
    }

    //  Test for future variant: variant = 111x
    if ((octet & 0xE0) == 0xE0) {
      return variantFuture;
    }

    return variantUnknown;
  }

  /** Returns the version of the UUID.
    *
    * @return The version of the UUID.
    */
  Version getVersion() const {
    //  According to the specification, the variant is in high 4 bits of octet 6.
    Version version = static_cast<Version>((m_value.mostSignificantBits >> 12) & 0xF);

    if (version <= versionNameBasedSHA1) {
      return version;
    }

    return versionUnknown;
  }

  /** Returns the clock sequence of the UUID.
    *
    * @return The clock sequence contained in the UUID.
    */
  ClockSequence getClockSequence() const {
    if (getVersion() != versionTimeBased) {
      throwUciException("Invalid invocation of getClockSequence(), only valid with time-based UUIDs");
    }

    return static_cast<ClockSequence>((m_value.leastSignificantBits >> 48) & 0x3FFF);
  }

  /** Returns the time stamp of the UUID. This method is only valid with time based UUIDs. Invocation of this method with
    * other versions of UUIDs will result in an exception being thrown. NOTE: This version is different than previous
    * versions and returns the timestamp value in the native endianness, without requiring a conversion.
    *
    * @return The time stamp contained in the UUID.
    */
  Timestamp getTimestamp() const {
    if (getVersion() != versionTimeBased) {
      throwUciException("Invalid invocation of getTimestamp(), only valid with time-based UUIDs");
    }

    return ((m_value.mostSignificantBits & 0xFFF) << 48) | ((m_value.mostSignificantBits & 0xFFFF0000U) << 16) | (m_value.mostSignificantBits >> 32);
  }

  /** Returns the node address of the UUID. This method is only valid with time based UUIDs. Invocation of this method with
    * other versions of UUIDs will result in an exception being thrown.
    *
    * @return The node address of this UUID.
    */
  NodeAddress getNodeAddress() const {
    if (getVersion() != versionTimeBased) {
      throwUciException("Invalid invocation of getNodeAddress(), only valid with time-based UUIDs");
    }

    NodeAddress node;

    node.reserve(6);
    node.push_back(static_cast<uint8_t>(m_value.leastSignificantBits >> 40));
    node.push_back(static_cast<uint8_t>(m_value.leastSignificantBits >> 32));
    node.push_back(static_cast<uint8_t>(m_value.leastSignificantBits >> 24));
    node.push_back(static_cast<uint8_t>(m_value.leastSignificantBits >> 16));
    node.push_back(static_cast<uint8_t>(m_value.leastSignificantBits >> 8));
    node.push_back(static_cast<uint8_t>(m_value.leastSignificantBits >> 0));

    return node;
  }

  // === Comparison Operators ============================================================================================

  /** Tests whether the UUID is equal to the specified UUID (rhs) returning true if they are equal, false otherwise.
    *
    * @param rhs A constant reference to a UUID that is to be compared to the UUID.
    * @return A boolean indicating whether the UUID is equal to the UUID (rhs) (true) or not (false).
    */
  bool operator==(const UUID& rhs) const {
    return rhs.m_value.mostSignificantBits == m_value.mostSignificantBits && rhs.m_value.leastSignificantBits == m_value.leastSignificantBits;
  }

  /** Tests whether the UUID is not equal to the specified UUID (rhs) returning true if they are not equal, false
    * otherwise.
    *
    * @param rhs A constant reference to a UUID that is to be compared to the UUID.
    * @return A boolean indicating whether the UUID is not equal to the UUID (rhs) (true) or not (false).
    */
  bool operator!=(const UUID& rhs) const {
    return rhs.m_value.mostSignificantBits != m_value.mostSignificantBits || rhs.m_value.leastSignificantBits != m_value.leastSignificantBits;
  }

  /** Tests whether the UUID is less than the specified UUID (rhs) returning true if the UUID is less than the specified
    * UUID (rhs), false otherwise. The comparison is performed on a hexadecimal digit by hexadecimal digit basis starting
    * with the most significant hexadecimal digit.
    *
    * @param rhs A constant reference to a UUID that is to be compared to the UUID.
    * @return A boolean indicating whether the UUID is less than the UUID (rhs) (true) or not (false).
    */
  bool operator<(const UUID& rhs) const {
    return m_value.mostSignificantBits < rhs.m_value.mostSignificantBits || (m_value.mostSignificantBits == rhs.m_value.mostSignificantBits && m_value.leastSignificantBits < rhs.m_value.leastSignificantBits);
  }

  /** Tests whether the UUID is greater than the specified UUID (rhs) returning true if the UUID is greater than the
    * specified UUID (rhs), false otherwise. The comparison is performed on a hexadecimal digit by hexadecimal digit basis
    * starting with the most significant hexadecimal digit.
    *
    * @param rhs A constant reference to a UUID that is to be compared to the UUID.
    * @return A boolean indicating whether the UUID is greater than the UUID (rhs) (true) or not (false).
    */
  bool operator>(const UUID& rhs) const {
    return rhs.operator<(*this);
  }

  /** Tests whether the UUID is less than or equal to the specified UUID (rhs) returning true if the UUID is less than or
    * equal to the specified UUID (rhs), false otherwise. The comparison is performed on a hexadecimal digit by hexadecimal
    * digit basis starting with the most significant hexadecimal digit.
    *
    * @param rhs A constant reference to a UUID that is to be compared to the UUID.
    * @return A boolean indicating whether the UUID is less than or equal to the UUID (rhs) (true) or not (false).
    */
  bool operator<=(const UUID& rhs) const {
    return !rhs.operator<(*this);
  }

  /** Tests whether the UUID is greater than or equal to the specified UUID (rhs) returning true if the UUID is greater
    * than or equal to the specified UUID (rhs), false otherwise. The comparison is performed on a hexadecimal digit by
    * hexadecimal digit basis starting with the most significant hexadecimal digit.
    *
    * @param rhs A constant reference to a UUID that is to be compared to the UUID.
    * @return A boolean indicating whether the UUID is greater than or equal to the UUID (rhs) (true) or not (false).
    */
  bool operator>=(const UUID& rhs) const {
    return !operator<(rhs);
  }

  // === Helper Methods ==================================================================================================

  /** Returns whether the UUID is a nil UUID. A nil UUID is one in which all hexadecimal digits are 0 (zero).
    *
    * @return A boolean indicating whether the UUID is a nil UUID (true) or not (false).
    */
  bool isNil() const {
    return m_value.mostSignificantBits == 0 && m_value.leastSignificantBits == 0;
  }

  /** Returns whether the UUID is valid (true) or not (false). A UUID is valid if the UUID is a nil UUID or if both the
    * version and variant of the UUID conform to RFC 4122. Any UUID created using generate() or createVersion3UUID() is
    * guaranteed to be valid.
    *
    * @return A boolean indicating whether the UUID is valid (true) or not (false).
    */
  bool isValid() const {
    return isNil() || (getVariant() == variantCurrent && getVersion() >= 1 && getVersion() <= 5);
  }

  /** Creates a UUID from a vector of octets.
    *
    * @param octets A UUID expressed as a vector of octets that is used to create the UUID.
    * @return A UUID with the value represented by the octets.
    */
  static UUID fromOctets(const Octets& octets) {
    if (octets.size() != m_numberOfOctets) {
      throwUciException("Number of octets must be " << m_numberOfOctets);
    }

    return UUID((static_cast<uint64_t>(octets[0]) << 56) | (static_cast<uint64_t>(octets[1]) << 48) | (static_cast<uint64_t>(octets[2]) << 40) | (static_cast<uint64_t>(octets[3]) << 32) | (static_cast<uint64_t>(octets[4]) << 24) | (static_cast<uint64_t>(octets[5]) << 16) | (static_cast<uint64_t>(octets[6]) << 8) | octets[7],
      (static_cast<uint64_t>(octets[8]) << 56) | (static_cast<uint64_t>(octets[9]) << 48) | (static_cast<uint64_t>(octets[10]) << 40) | (static_cast<uint64_t>(octets[11]) << 32) | (static_cast<uint64_t>(octets[12]) << 24) | (static_cast<uint64_t>(octets[13]) << 16) | (static_cast<uint64_t>(octets[14]) << 8) | octets[15]);
  }

  /** Creates a UUID from a stringified UUID formatted as specified in RFC 4122.
    *
    * @param stringifiedUUID A UUID expressed as a string as specified in RFC 4122.
    * @return A UUID with the value represented by the stringified UUID.
    */
  static UUID fromString(const std::string& stringifiedUUID) {
    //  XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    //  012345678901234567890123456789012345 (size: 36)
    if (stringifiedUUID.length() != 36 || stringifiedUUID[8] != '-' || stringifiedUUID[13] != '-' || stringifiedUUID[18] != '-' || stringifiedUUID[23] != '-') {
      throwUciException("Invalid UUID string \"" << stringifiedUUID << "\"");
    }

    //  Convert the character at the given index to its hexadecimal value and left shift
    #define C2H(INDEX, LEFT_SHIFT) (static_cast<uint64_t>(fromChar(stringifiedUUID, INDEX)) << (LEFT_SHIFT))
    return UUID(
      C2H( 0, 60) | C2H( 1, 56) | C2H( 2, 52) | C2H( 3, 48) | C2H( 4, 44) | C2H( 5, 40) | C2H( 6, 36) | C2H( 7, 32) |
      C2H( 9, 28) | C2H(10, 24) | C2H(11, 20) | C2H(12, 16) |
      C2H(14, 12) | C2H(15,  8) | C2H(16,  4) | C2H(17,  0),
      C2H(19, 60) | C2H(20, 56) | C2H(21, 52) | C2H(22, 48) |
      C2H(24, 44) | C2H(25, 40) | C2H(26, 36) | C2H(27, 32) | C2H(28, 28) | C2H(29, 24) | C2H(30, 20) | C2H(31, 16) | C2H(32, 12) | C2H(33,  8) | C2H(34,  4) | C2H(35,  0));
    #undef C2H
  }

  /** Generates a UUID that conforms to RFC 4122 version 1 or version 4.
    *
    * @return The generated RFC 4122 version 1 or version 4 UUID.
    */
  static UCI_EXPORT UUID generateUUID();

  static UCI_EXPORT UUID getNilUUID(){
    return boost::uuids::nil_uuid();
  }

  /** Returns the UUID that is used in creating a Version 3 UUID for the method that does not provide the namespace
    * parameter.
    *
    * @return The UUID that can be used as the namespace for the createVersion3UUID(const UUID &ns, const std::string&
    *      name) method to create OMS Platform-specific, consistent UUIDs.
    */
  static UCI_EXPORT UUID getNamespaceUUID();

  /** Creates a UUID that conforms to RFC 4122 version 3 from the namespace UUID and string name.
    *
    * @param ns The namespace UUID used to create the version 3 UUID.
    * @param name The string name encoded in UTF-8 used to create the version 3 UUID.
    * @return The created RFC 4122 version 3 UUID.
    */
  static UCI_EXPORT UUID createVersion3UUID(const UUID& ns, const std::string& name);

  /** Creates a UUID that conforms to RFC 4122 version 3 from a string name. The getNamespaceUUID() member function will
    * return the namespace UUID used to create the RFC 4122 Version 3 UUID.
    *
    * @param name The string name encoded in UTF-8 used to create the version 3 UUID.
    * @return The created RFC 4122 version 3 UUID.
    */
  static UCI_EXPORT UUID createVersion3UUID(const std::string& name);

  /** Returns the specified variant as a string.
    *
    * @param variant The variant to be converted to a string.
    * @return A stringified version of the specified variant.
    */
  static const char* toString(Variant variant) noexception {
    if (variant == variantNCS) {
      return "VariantNCS";
    }

    if (variant == variantMicrosoft) {
      return "VariantMicrosoft";
    }

    if (variant == variantCurrent) {
      return "VariantCurrent";
    }

    if (variant == variantFuture) {
      return "VariantFuture";
    }

    return "VariantUnknown";
  }

  /** Returns the specified version as a string.
    *
    * @param version The version to be converted to a string.
    * @return The stringified version of the specified version.
    */
  static const char* toString(Version version) noexception {
    if (version == versionNil) {
      return "VersionNil";
    }

    if (version == versionTimeBased) {
      return "VersionTimeBased";
    }

    if (version == versionDceSecurity) {
      return "VersionDceSecurity";
    }

    if (version == versionNameBasedMD5) {
      return "VersionNameBasedMD5";
    }

    if (version == versionRandomNumber) {
      return "VersionRandomNumber";
    }

    if (version == versionNameBasedSHA1) {
      return "VersionNameBasedSHA1";
    }

    return "VersionUnknown";
  }

protected:

  /** This method converts a hexadecimal character at the specified index of a stringified UUID to its numerical
    * hexadecimal value.
    *
    * @param stringifiedUUID The stringified UUID.
    * @param index The index of the character to convert.
    * @return The value of the hexadecimal character at the specified index of the stringified UUID.
    */
  static uint8_t fromChar(const std::string& stringifiedUUID, size_t index) {
    char c = stringifiedUUID[index];

    if (c >= '0' && c <= '9') {
      return static_cast<uint8_t>(c - '0');
    }

    if (c >= 'A' && c <= 'F') {
      return static_cast<uint8_t>(c - 'A' + 10);
    }

    if (c >= 'a' && c <= 'f') {
      return static_cast<uint8_t>(c - 'a' + 10);
    }

    throwUciException("Unrecognized character \"" << c << "\" in UUID string \"" << stringifiedUUID << "\" at index " << index);
  }

  /** This method converts a numerical hexadecimal value to its hexadecimal character.
    *
    * @param value The value to convert.
    * @return The converted hexadecimal character.
    */
  static char toChar(uint8_t value) {
    static char const chars[] = { '0', '1', '2', '3' , '4', '5', '6' , '7', '8' , '9', 'a', 'b', 'c', 'd', 'e', 'f' };
    return chars[value];
  }

  ValueUUID m_value;

};

} // namespace base
} // namespace uci

#if defined(__cplusplus) && __cplusplus >= 201103L

#include <functional>

namespace std {

  template<> struct hash<uci::base::UUID> {

    typedef uci::base::UUID argument_type;
    typedef std::size_t result_type;

    std::size_t operator()(argument_type const& uuid) const noexcept
    {
      return std::hash<uint64_t>()(uuid.getValueUUID().leastSignificantBits ^ uuid.getValueUUID().mostSignificantBits);
    }

  };

}

#endif // defined(__cplusplus) && __cplusplus >= 201103L


#endif // UCI_BASE_UUID_H

