/** @file SimpleList.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:05 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef UCI_BASE_SIMPLELIST_H
#define UCI_BASE_SIMPLELIST_H

#include <stdint.h>

#include <climits>
#include <cstddef>

#include "uci/base/Accessor.h"

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all base data types are declared */
namespace base {

template<class T, uci::base::accessorType::AccessorType V>
/** The SimpleList is used to provide access to all simple lists. */
class SimpleList : public virtual uci::base::Accessor {
public:

  // === The typedefs ====================================================================================================

  /** The size_type typedef is an unsigned integral type that can represent any non-negative "size" values. e.g. the number
    * of elements in a SimpleList.
    */
  typedef std::size_t size_type;

  /** The reference typedef is an unsigned integral type that can represent any non-negative "size" values. e.g. the number
    * of elements in a SimpleList.
    */
  typedef T& reference;

  /** The const_reference typedef is an unsigned integral type that can represent any non-negative "size" values. e.g. the
    * number of elements in a SimpleList.
    */
  typedef const T& const_reference;

  // === The constants ===================================================================================================

  /** The MAXIMUM_LENGTH is the maximum size of a SimpleList. If the value returned by the getMaximumLength() method equals
    * this value, then no maximum length was specified in the XSD specification and this list is limited simply by natural
    * indexing.
    */
  static const size_type MAXIMUM_LENGTH = SIZE_MAX;

  // === The public methods ==============================================================================================

  /** Returns the number of elements in the SimpleList. This number is the number of actual objects held in the SimpleList,
    * which is not necessarily equal to its storage capacity.
    *
    * @return The number of actual objects held in the SimpleList.
    */
  virtual size_type size() const noexception = 0;

  /** Returns the maximum number of elements that the SimpleList should hold in order to be consider valid with respect to
    * the XSD specification used to generate this containers specification. The value returned is the same that is returned
    * by the getMaxLength() method. If not specified in the XSD, then this is the maximum size the container can reach due
    * to known system or library implementation limitations, but the container is by no means guaranteed to be able to
    * reach that size: it can still fail to allocate storage at any point before that size is reached.
    *
    * @return The maximum number of elements that the SimpleList should hold in order to be considered valid.
    */
  virtual size_type max_size() const noexception = 0;

  /** Returns the minimum number of elements the container should hold in order to be considered valid with respect to the
    * XSD specification used to generate this SimpleList's specification. The value returned is the same that is returned
    * by the getMinimumLength() method.
    *
    * @return The minimum number of elements that the SimpleList should hold in order to be considered valid.
    */
  virtual size_type min_size() const noexception = 0;

  /** Resizes the container so that it contains n elements.
    *
    * @param newSize The size of the container after it has been resized. If newSize is smaller than the current container
    *      size, the content of the SimpleList is reduced to its first n elements, removing those beyond (and destroying
    *      them). If newSize is greater than the current container size, the content of the SimpleList is expanded by
    *      inserting at the end as many elements as needed to reach a size of newSize. The newly added elements are value
    *      initialized (initialized according to their type). If newSize is greater than the current container capacity, an
    *      automatic reallocation of the allocated storage space takes place. Notice that this method changes the actual
    *      content of the container by inserting or erasing elements from it.
    * @param type = V The type of data to be added when this BoundedList is resized. The use of this parameter provides
    *      support for inheritable types. This parameter defaults to null that is used to indicate that the type of the
    *      elements to be inserted are of the type specified by the template argument used when this BoundedList's class
    *      was declared, i.e. the template's T argument. This type is known as the BoundedList's base type. If specified,
    *      this argument must either be a type ID associated with the BoundedList's base type or a accessor derived from
    *      the BoundedList's base type.
    */
  virtual void resize(size_type newSize, uci::base::accessorType::AccessorType type = V) = 0;

  /** Returns the size of allocated storage capacity expressed in terms of elements.
    *
    * @return The size of the storage space currently allocated for the SimpleList, expressed in terms of elements. This
    *      capacity is not necessarily equal to the SimpleList size. It can be equal or greater, with the extra space
    *      allowing to accommodate for growth without the need to reallocate on each insertion. Notice that this capacity
    *      does not suppose a limit on the size of the SimpleList. When this capacity is exhausted and more is needed, it
    *      is automatically expanded by the container (reallocating it storage space). The theoretical limit on the size of
    *      a SimpleList is given by member max_size. The capacity of a SimpleList can be explicitly altered by calling
    *      member SimpleList::reserve.
    */
  virtual size_type capacity() const noexception = 0;

  /** Tests whether SimpleList is empty.
    *
    * @return Returns whether the SimpleList is empty, i.e. whether its size is 0, (true) or not (false).
    * @note This function does not modify the container in any way. To clear the contents of a SimpleList, see
    *      SimpleList::clear.
    * @note This function is equivalent to "size() == 0" but may offer better performance due to implementation
    *      constraints.
    */
  virtual bool empty() const noexception = 0;

  /** Request a change in the SimpleList's capacity such that the capacity be at least large enough to contain n elements.
    *
    * @param newCapacity If newCapacity is greater than the SimpleList's current capacity, then the SimpleList's capacity
    *      will be increased to the new capacity. This action may result in a reallocation of the SimpleList's storage
    *      using new storage whose capacity is equal to or greater than newCapacity. Such a reallocation will cause all
    *      elements to be copied to the new storage and the original storage to be deleted. In all other cases, the
    *      function call does not cause a reallocation and the SimpleList capacity is not affected.
    * @note This function has no effect on the SimpleList size and cannot alter its elements.
    */
  virtual void reserve(size_type newCapacity) = 0;

  /** Removes the last element in the SimpleList, effectively reducing the container size by one. This destroys the removed
    * element.
    */
  virtual void pop_back() noexception = 0;

  /** Removes all elements from the SimpleList (which are destroyed), leaving the SimpleList with a size of 0.
    *
    * @note A reallocation is not guaranteed to happen, and the SimpleList capacity is not guaranteed to change due to
    *      calling this function.
    */
  virtual void clear() noexception = 0;

  /** Returns this SimpleList's "maxLength" facet as specified in the XML Schema specification.
    *
    * @return The SimpleList's "maxLength".
    * @note The value returned is the same as that returned by max_size()
    */
  virtual size_type getMaximumLength() const noexception = 0;

  /** Returns this SimpleList's "minLength" facet as specified in the XML Schema specification.
    *
    * @return The SimpleList's "minLength".
    * @note The value returned is the same as that returned by min_size()
    */
  virtual size_type getMinimumLength() const noexception = 0;

  /** Returns this SimpleList's "length" facet as specified in the XML Schema specification.
    *
    * @return The SimpleList's "maxLength".
    */
  virtual size_type getLength() const noexception = 0;

  /** Returns a reference to the enumerated item at position n in the SimpleList.
    *
    * @param index The index of the element in this SimpleList a reference to which is to be returned.
    * @return The reference to the element at position n in the SimpleList.
    * @note No bounds checking is performed by this operator. See SimpleList::at() for a version of this operator that does
    *      perform bounds checking. Unexpected results, including the throwing of exceptions, may occur if the index is out
    *      of range.
    */
  virtual reference operator[](size_type index) = 0;

  /** Returns a reference to the enumerated item at position n in the SimpleList.
    *
    * @param index The index of the element in this SimpleList a reference to which is to be returned.
    * @return The constant reference to the element at position n in the SimpleList.
    * @note No bounds checking is performed by this operator. See SimpleList::at() for a version of this operator that does
    *      perform bounds checking. Unexpected results, including the throwing of exceptions, may occur if the index is out
    *      of range.
    */
  virtual const_reference operator[](size_type index) const = 0;

  /** Returns a reference to the element at position n in the SimpleList container. This method automatically checks
    * whether the index is within the bounds of valid elements in the SimpleList, throwing an out_of_range exception if it
    * is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not
    * check against bounds.
    *
    * @param index The index of the element in this SimpleList a reference to which is to be returned. If this is greater
    *      than or equal to the SimpleList size, an exception of type out_of_range is thrown. Notice that the first element
    *      has a position of 0 (not 1).
    * @return The reference to the element at position index in the SimpleList.
    */
  virtual reference at(size_type index) = 0;

  /** Returns a reference to the element at position n in the SimpleList container. This method automatically checks
    * whether the index is within the bounds of valid elements in the SimpleList, throwing an out_of_range exception if it
    * is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not
    * check against bounds.
    *
    * @param index The index of the element in this SimpleList a reference to which is to be returned. If this is greater
    *      than or equal to the SimpleList size, an exception of type out_of_range is thrown. Notice that the first element
    *      has a position of 0 (not 1).
    * @return The reference to the enumerate item at position index in the SimpleList.
    */
  virtual const_reference at(size_type index) const = 0;

  /** Adds a new element at the end of the SimpleList, after its current last element. The content of value is copied (or
    * moved) to the new element. This effectively increases the container size by one, which causes an automatic
    * reallocation of the allocated storage space if, and only if, the new SimpleList size surpasses the current SimpleList
    * capacity.
    *
    * @param value The value to be copied (or moved) into the new element.
    */
  virtual void push_back(const_reference value) = 0;

protected:

  /** The constructor [only available to derived classes]. */
  SimpleList() {
  }

  /** The destructor [only available to derived classes]. */
  ~SimpleList() {
  }

  /** The copy constructor [only available to derived classes].
    *
    * @param rhs The SimpleList<T,V> to copy from.
    */
  SimpleList(const SimpleList<T,V>& rhs) {
    (void)rhs;
  }

  /** The assignment operator. Sets the contents of this SimpleList<T,V> to the contents of the SimpleList<T,V> on the
    * right hand side (rhs) of the assignment operator [only available to derived classes].
    *
    * @param rhs The SimpleList<T,V> on the right hand side (rhs) of the assignment operator whose contents are used to set
    *      the contents of this SimpleList<T,V>.
    * @return A reference to this SimpleList<T,V>.
    */
  SimpleList<T,V>& operator=(const SimpleList<T,V>& rhs) {
    (void)rhs;

    return *this;
  }

};

} // namespace base
} // namespace uci

#endif // UCI_BASE_SIMPLELIST_H

