/** @file BoundedList.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:05 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef UCI_BASE_BOUNDEDLIST_H
#define UCI_BASE_BOUNDEDLIST_H

#include <stdint.h>

#include <climits>
#include <cstddef>

#include "uci/base/Accessor.h"

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all base data types are declared */
namespace base {

template<class T, uci::base::accessorType::AccessorType V>
/** The BoundedList is used to provide access to all bounded lists. */
class BoundedList : public virtual uci::base::Accessor {
public:

  // === The typedefs ====================================================================================================

  /** The size_type typedef is an unsigned integral type that can represent any non-negative "size" values. e.g. the number
    * of elements in a BoundedList.
    */
  typedef std::size_t size_type;

  /** The reference typedef is an unsigned integral type that can represent any non-negative "size" values. e.g. the number
    * of elements in a BoundedList.
    */
  typedef T& reference;

  /** The const_reference typedef is an unsigned integral type that can represent any non-negative "size" values. e.g. the
    * number of elements in a BoundedList.
    */
  typedef const T& const_reference;

  // === The constants ===================================================================================================

  /** The UNBOUNDED_BOUND is the maximum size of a BoundedList. If the value returned by the getMaximumOccurs() method
    * equals this value, then no bounds were specified in the XSD specification and this list is bounded simply by natural
    * indexing.
    */
  static const size_type UNBOUNDED_BOUND = SIZE_MAX;

  // === The public methods ==============================================================================================

  /** Returns the number of elements in the BoundedList. This number is the number of actual objects held in the
    * BoundedList, which is not necessarily equal to its storage capacity.
    *
    * @return The number of actual objects held in the BoundedList.
    */
  virtual size_type size() const noexception = 0;

  /** Returns the maximum number of elements that the BoundedList should hold in order to be consider valid with respect to
    * the XSD specification used to generate this containers specification. The value returned is the same that is returned
    * by the getMaxOccurs() method. If not specified in the XSD, then this is the maximum size the container can reach due
    * to known system or library implementation limitations, but the container is by no means guaranteed to be able to
    * reach that size: it can still fail to allocate storage at any point before that size is reached.
    *
    * @return The maximum number of elements that the BoundedList should hold in order to be considered valid.
    */
  virtual size_type max_size() const noexception = 0;

  /** Returns the minimum number of elements the container should hold in order to be considered valid with respect to the
    * XSD specification used to generate this containers specification. The value returned is the same that is returned by
    * the getMinOccurs() method.
    *
    * @return The minimum number of elements that the BoundedList should hold in order to be considered valid.
    */
  virtual size_type min_size() const noexception = 0;

  /** Resizes the container so that it contains n elements.
    *
    * @param newSize The size of the container after it has been resized. If newSize is smaller than the current container
    *      size, the content of the BoundedList is reduced to its first n elements, removing those beyond (and destroying
    *      them). If newSize is greater than the current container size, the content of the BoundedList is expanded by
    *      inserting at the end as many elements as needed to reach a size of newSize. The newly added elements are value
    *      initialized (initialized according to their type). If newSize is greater than the current container capacity, an
    *      automatic reallocation of the allocated storage space takes place. Notice that this method changes the actual
    *      content of the container by inserting or erasing elements from it.
    * @param type = V The type of data to be added when this BoundedList is resized. The use of this parameter provides
    *      support for inheritable types. This parameter defaults to null that is used to indicate that the type of the
    *      elements to be inserted are of the type specified by the template argument used when this BoundedList's class
    *      was declared, i.e. the template's T argument. This type is known as the BoundedList's base type. If specified,
    *      this argument must either be a type ID associated with the BoundedList's base type or a accessor derived from
    *      the BoundedList's base type.
    */
  virtual void resize(size_type newSize, uci::base::accessorType::AccessorType type = V) = 0;

  /** Returns the size of allocated storage capacity expressed in terms of elements.
    *
    * @return The size of the storage space currently allocated for the BoundedList, expressed in terms of elements. This
    *      capacity is not necessarily equal to the BoundedList size. It can be equal or greater, with the extra space
    *      allowing to accommodate for growth without the need to reallocate on each insertion. Notice that this capacity
    *      does not suppose a limit on the size of the BoundedList. When this capacity is exhausted and more is needed, it
    *      is automatically expanded by the container (reallocating it storage space). The theoretical limit on the size of
    *      a BoundedList is given by member max_size. The capacity of a BoundedList can be explicitly altered by calling
    *      member BoundedList::reserve.
    */
  virtual size_type capacity() const noexception = 0;

  /** Tests whether BoundedList is empty.
    *
    * @return Returns whether the BoundedList is empty, i.e. whether its size is 0, (true) or not (false).
    * @note This function does not modify the container in any way. To clear the contents of a BoundedList, see
    *      BoundedList::clear.
    * @note This function is equivalent to "size() == 0" but may offer better performance due to implementation
    *      constraints.
    */
  virtual bool empty() const noexception = 0;

  /** Request a change in the BoundedList's capacity such that the capacity be at least large enough to contain n elements.
    *
    * @param newCapacity If newCapacity is greater than the BoundedList's current capacity, then the BoundedList's capacity
    *      will be increased to the new capacity. This action may result in a reallocation of the BoundedList's storage
    *      using new storage whose capacity is equal to or greater than newCapacity. Such a reallocation will cause all
    *      elements to be copied to the new storage and the original storage to be deleted. In all other cases, the
    *      function call does not cause a reallocation and the BoundedList capacity is not affected.
    * @note This function has no effect on the BoundedList size and cannot alter its elements.
    */
  virtual void reserve(size_type newCapacity) = 0;

  /** Removes the last element in the BoundedList, effectively reducing the container size by one. This destroys the
    * removed element.
    */
  virtual void pop_back() noexception = 0;

  /** Removes all elements from the BoundedList (which are destroyed), leaving the BoundedList with a size of 0.
    *
    * @note A reallocation is not guaranteed to happen, and the BoundedList capacity is not guaranteed to change due to
    *      calling this function.
    */
  virtual void clear() noexception = 0;

  /** The returns this BoundedList's "maxOccurs" as specified in the XML Schema specification.
    *
    * @return The BoundedList's "maxOccurs".
    * @note The value returned is the same as that returned by max_size()
    */
  virtual size_type getMaximumOccurs() const noexception = 0;

  /** The returns this BoundedList's "minOccurs" as specified in the XML Schema specification.
    *
    * @return The BoundedList's "minOccurs".
    * @note The value returned is the same as that returned by min_size()
    */
  virtual size_type getMinimumOccurs() const noexception = 0;

  /** Returns a reference to the enumerated item at position n in the BoundedList.
    *
    * @param index The index of the element in this BoundedList a reference to which is to be returned.
    * @return The reference to the element at position n in the BoundedList.
    * @note No bounds checking is performed by this operator. See BoundedList::at() for a version of this operator that
    *      does perform bounds checking. Unexpected results, including the throwing of exceptions, may occur if the index
    *      is out of range.
    */
  virtual reference operator[](size_type index) = 0;

  /** Returns a reference to the enumerated item at position n in the BoundedList.
    *
    * @param index The index of the element in this BoundedList a reference to which is to be returned.
    * @return The constant reference to the element at position n in the BoundedList.
    * @note No bounds checking is performed by this operator. See BoundedList::at() for a version of this operator that
    *      does perform bounds checking. Unexpected results, including the throwing of exceptions, may occur if the index
    *      is out of range.
    */
  virtual const_reference operator[](size_type index) const = 0;

  /** Returns a reference to the element at position n in the BoundedList container. This method automatically checks
    * whether the index is within the bounds of valid elements in the BoundedList, throwing an out_of_range exception if it
    * is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not
    * check against bounds.
    *
    * @param index The index of the element in this BoundedList a reference to which is to be returned. If this is greater
    *      than or equal to the BoundedList size, an exception of type out_of_range is thrown. Notice that the first
    *      element has a position of 0 (not 1).
    * @return The reference to the element at position index in the BoundedList.
    */
  virtual reference at(size_type index) = 0;

  /** Returns a reference to the element at position n in the BoundedList container. This method automatically checks
    * whether the index is within the bounds of valid elements in the BoundedList, throwing an out_of_range exception if it
    * is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not
    * check against bounds.
    *
    * @param index The index of the element in this BoundedList a reference to which is to be returned. If this is greater
    *      than or equal to the BoundedList size, an exception of type out_of_range is thrown. Notice that the first
    *      element has a position of 0 (not 1).
    * @return The reference to the enumerate item at position index in the BoundedList.
    */
  virtual const_reference at(size_type index) const = 0;

  /** Adds a new element at the end of the BoundedList, after its current last element. The content of value is copied (or
    * moved) to the new element. This effectively increases the container size by one, which causes an automatic
    * reallocation of the allocated storage space if, and only if, the new BoundedList size surpasses the current
    * BoundedList capacity.
    *
    * @param value The value to be copied (or moved) into the new element.
    */
  virtual void push_back(const_reference value) = 0;

private:

  template <typename U, U> struct CheckType;

  template <typename U, typename W> class IsAssignable
  {
    template <typename To, typename From> static int Check(CheckType < To & (To::*)(From), &To::operator=>*);
    template <typename, typename> static char Check(...);

  public:
    static const bool VALUE = sizeof(Check<U, W>(0)) == sizeof(int);
  };

  template <typename U> struct IsReference { static const bool VALUE = false; };
  template <typename U> struct IsReference<U&> { static const bool VALUE = true; };

  template <bool B, typename = void> struct EnableIf {};
  template <typename U> struct EnableIf<true, U> { typedef U Type; };

public:

  /** Adds a new element at the end of the BoundedList, after its current last element. The content of value is copied (or
    * moved) to the new element. This effectively increases the container size by one, which causes an automatic
    * reallocation of the allocated storage space if, and only if, the new BoundedList size surpasses the current
    * BoundedList capacity.
    *
    * @param value The value to be copied (or moved) into the new element.
    * @return .
    */
  template <typename U> typename EnableIf<IsAssignable<T, U>::VALUE && !IsReference<U>::VALUE>::Type push_back(U value) {
    const size_type index = size();
    resize(index + 1);
    operator[](index) = value;
  }

  /** Adds a new element at the end of the BoundedList, after its current last element. The content of value is copied (or
    * moved) to the new element. This effectively increases the container size by one, which causes an automatic
    * reallocation of the allocated storage space if, and only if, the new BoundedList size surpasses the current
    * BoundedList capacity.
    *
    * @param value The value to be copied (or moved) into the new element.
    * @return .
    */
  template <typename U> typename EnableIf<IsAssignable<T, const U&>::VALUE>::Type push_back(const U& value) {
    const size_type index = size();
    resize(index + 1);
    operator[](index) = value;
  }

protected:

  /** The constructor [only available to derived classes]. */
  BoundedList() {
  }

  /** The destructor [only available to derived classes]. */
  ~BoundedList() {
  }

  /** The copy constructor [only available to derived classes].
    *
    * @param rhs The BoundedList<T,V> to copy from.
    */
  BoundedList(const BoundedList<T,V>& rhs) {
    (void)rhs;
  }

  /** The assignment operator. Sets the contents of this BoundedList<T,V> to the contents of the BoundedList<T,V> on the
    * right hand side (rhs) of the assignment operator [only available to derived classes].
    *
    * @param rhs The BoundedList<T,V> on the right hand side (rhs) of the assignment operator whose contents are used to
    *      set the contents of this BoundedList<T,V>.
    * @return A reference to this BoundedList<T,V>.
    */
  BoundedList<T,V>& operator=(const BoundedList<T,V>& rhs) {
    (void)rhs;

    return *this;
  }

};

} // namespace base
} // namespace uci

#endif // UCI_BASE_BOUNDEDLIST_H

