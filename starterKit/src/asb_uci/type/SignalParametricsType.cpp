/** @file SignalParametricsType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/SignalParametricsType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/FrequencyDataType.h"
#include "asb_uci/type/FrequencyModulationVariationEnum.h"
#include "asb_uci/type/LongBaselineInterferometerInfoType.h"
#include "asb_uci/type/ModulationOnPulseDataType.h"
#include "asb_uci/type/PRI_PW_Type.h"
#include "asb_uci/type/PolarizationType.h"
#include "asb_uci/type/ScanDataType.h"
#include "asb_uci/type/SignalAmplitudeType.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/AnglePositiveType.h"
#include "uci/type/DecibelType.h"
#include "uci/type/DoubleNonNegativeType.h"
#include "uci/type/DurationType.h"
#include "uci/type/FrequencyDataType.h"
#include "uci/type/FrequencyModulationVariationEnum.h"
#include "uci/type/FrequencyType.h"
#include "uci/type/LongBaselineInterferometerInfoType.h"
#include "uci/type/ModulationOnPulseDataType.h"
#include "uci/type/PRI_PW_Type.h"
#include "uci/type/PolarizationType.h"
#include "uci/type/ScanDataType.h"
#include "uci/type/SignalAmplitudeType.h"
#include "uci/type/SignalParametricsType.h"
#include "xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

SignalParametricsType::SignalParametricsType()
  : frequency_Accessor{boost::make_unique<Frequency>(0, SIZE_MAX)},
    pRI_PW_Accessor{boost::make_unique<PRI_PW>(0, SIZE_MAX)} {
}

SignalParametricsType::~SignalParametricsType() = default;

void SignalParametricsType::copy(const uci::type::SignalParametricsType& accessor) {
  copyImpl(accessor, false);
}

void SignalParametricsType::copyImpl(const uci::type::SignalParametricsType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const SignalParametricsType&>(accessor);
    setFrequency(*(accessorImpl.frequency_Accessor));
    setPRI_PW(*(accessorImpl.pRI_PW_Accessor));
    if (accessorImpl.amplitude_Accessor) {
      setAmplitude(*(accessorImpl.amplitude_Accessor));
    } else {
      amplitude_Accessor.reset();
    }
    if (accessorImpl.polarization_Accessor) {
      setPolarization(*(accessorImpl.polarization_Accessor));
    } else {
      polarization_Accessor.reset();
    }
    if (accessorImpl.modulationOnPulse_Accessor) {
      setModulationOnPulse(*(accessorImpl.modulationOnPulse_Accessor));
    } else {
      modulationOnPulse_Accessor.reset();
    }
    if (accessorImpl.scan_Accessor) {
      setScan(*(accessorImpl.scan_Accessor));
    } else {
      scan_Accessor.reset();
    }
    if (accessorImpl.hasSignalNoiseRatio()) {
      setSignalNoiseRatio(accessorImpl.getSignalNoiseRatio());
    } else {
      clearSignalNoiseRatio();
    }
    if (accessorImpl.hasPulseRepetitionFrequency()) {
      setPulseRepetitionFrequency(accessorImpl.getPulseRepetitionFrequency());
    } else {
      clearPulseRepetitionFrequency();
    }
    if (accessorImpl.hasPulseRepetitionFrequencyCalculated()) {
      setPulseRepetitionFrequencyCalculated(accessorImpl.getPulseRepetitionFrequencyCalculated());
    } else {
      clearPulseRepetitionFrequencyCalculated();
    }
    if (accessorImpl.hasPulseDeviation()) {
      setPulseDeviation(accessorImpl.getPulseDeviation());
    } else {
      clearPulseDeviation();
    }
    if (accessorImpl.hasBurstDeviation()) {
      setBurstDeviation(accessorImpl.getBurstDeviation());
    } else {
      clearBurstDeviation();
    }
    if (accessorImpl.hasIlluminationRate()) {
      setIlluminationRate(accessorImpl.getIlluminationRate());
    } else {
      clearIlluminationRate();
    }
    if (accessorImpl.hasIlluminationRateDeviation()) {
      setIlluminationRateDeviation(accessorImpl.getIlluminationRateDeviation());
    } else {
      clearIlluminationRateDeviation();
    }
    if (accessorImpl.hasPulseCount()) {
      setPulseCount(accessorImpl.getPulseCount());
    } else {
      clearPulseCount();
    }
    if (accessorImpl.hasPulsesPerGroup()) {
      setPulsesPerGroup(accessorImpl.getPulsesPerGroup());
    } else {
      clearPulsesPerGroup();
    }
    if (accessorImpl.hasBeamWidth()) {
      setBeamWidth(accessorImpl.getBeamWidth());
    } else {
      clearBeamWidth();
    }
    if (accessorImpl.frequencyModulationVariation_Accessor) {
      setFrequencyModulationVariation(*(accessorImpl.frequencyModulationVariation_Accessor));
    } else {
      frequencyModulationVariation_Accessor.reset();
    }
    if (accessorImpl.hasFrequencyExcursion()) {
      setFrequencyExcursion(accessorImpl.getFrequencyExcursion());
    } else {
      clearFrequencyExcursion();
    }
    if (accessorImpl.hasFrequencyExcursionAverage()) {
      setFrequencyExcursionAverage(accessorImpl.getFrequencyExcursionAverage());
    } else {
      clearFrequencyExcursionAverage();
    }
    if (accessorImpl.hasFrequencyExcursionAverageReportCount()) {
      setFrequencyExcursionAverageReportCount(accessorImpl.getFrequencyExcursionAverageReportCount());
    } else {
      clearFrequencyExcursionAverageReportCount();
    }
    if (accessorImpl.hasPilotFrequency()) {
      setPilotFrequency(accessorImpl.getPilotFrequency());
    } else {
      clearPilotFrequency();
    }
    if (accessorImpl.hasPilotFrequencyAverage()) {
      setPilotFrequencyAverage(accessorImpl.getPilotFrequencyAverage());
    } else {
      clearPilotFrequencyAverage();
    }
    if (accessorImpl.hasPilotFrequencyAverageReportCount()) {
      setPilotFrequencyAverageReportCount(accessorImpl.getPilotFrequencyAverageReportCount());
    } else {
      clearPilotFrequencyAverageReportCount();
    }
    if (accessorImpl.hasAverageBasebandedPulseRepetitionInterval()) {
      setAverageBasebandedPulseRepetitionInterval(accessorImpl.getAverageBasebandedPulseRepetitionInterval());
    } else {
      clearAverageBasebandedPulseRepetitionInterval();
    }
    if (accessorImpl.hasAverageBasebandedPulseRepetitionIntervalReportCount()) {
      setAverageBasebandedPulseRepetitionIntervalReportCount(accessorImpl.getAverageBasebandedPulseRepetitionIntervalReportCount());
    } else {
      clearAverageBasebandedPulseRepetitionIntervalReportCount();
    }
    if (accessorImpl.hasBasebandedPulseRepetitionIntervalDeviation()) {
      setBasebandedPulseRepetitionIntervalDeviation(accessorImpl.getBasebandedPulseRepetitionIntervalDeviation());
    } else {
      clearBasebandedPulseRepetitionIntervalDeviation();
    }
    if (accessorImpl.longBaselineInterferometerInfo_Accessor) {
      setLongBaselineInterferometerInfo(*(accessorImpl.longBaselineInterferometerInfo_Accessor));
    } else {
      longBaselineInterferometerInfo_Accessor.reset();
    }
  }
}

void SignalParametricsType::reset() noexcept {
  frequency_Accessor->reset();
  pRI_PW_Accessor->reset();
  amplitude_Accessor.reset();
  polarization_Accessor.reset();
  modulationOnPulse_Accessor.reset();
  scan_Accessor.reset();
  clearSignalNoiseRatio();
  clearPulseRepetitionFrequency();
  clearPulseRepetitionFrequencyCalculated();
  clearPulseDeviation();
  clearBurstDeviation();
  clearIlluminationRate();
  clearIlluminationRateDeviation();
  clearPulseCount();
  clearPulsesPerGroup();
  clearBeamWidth();
  frequencyModulationVariation_Accessor.reset();
  clearFrequencyExcursion();
  clearFrequencyExcursionAverage();
  clearFrequencyExcursionAverageReportCount();
  clearPilotFrequency();
  clearPilotFrequencyAverage();
  clearPilotFrequencyAverageReportCount();
  clearAverageBasebandedPulseRepetitionInterval();
  clearAverageBasebandedPulseRepetitionIntervalReportCount();
  clearBasebandedPulseRepetitionIntervalDeviation();
  longBaselineInterferometerInfo_Accessor.reset();
}

const uci::type::SignalParametricsType::Frequency& SignalParametricsType::getFrequency() const {
  return *frequency_Accessor;
}

uci::type::SignalParametricsType::Frequency& SignalParametricsType::getFrequency() {
  return *frequency_Accessor;
}

uci::type::SignalParametricsType& SignalParametricsType::setFrequency(const uci::type::SignalParametricsType::Frequency& accessor) {
  if (&accessor != frequency_Accessor.get()) {
    frequency_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SignalParametricsType::PRI_PW& SignalParametricsType::getPRI_PW() const {
  return *pRI_PW_Accessor;
}

uci::type::SignalParametricsType::PRI_PW& SignalParametricsType::getPRI_PW() {
  return *pRI_PW_Accessor;
}

uci::type::SignalParametricsType& SignalParametricsType::setPRI_PW(const uci::type::SignalParametricsType::PRI_PW& accessor) {
  if (&accessor != pRI_PW_Accessor.get()) {
    pRI_PW_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalAmplitudeType& SignalParametricsType::getAmplitude_() const {
  if (amplitude_Accessor) {
    return *amplitude_Accessor;
  }
  throw uci::base::UCIException("Error in getAmplitude(): An attempt was made to get an optional field that was not enabled, call hasAmplitude() to determine if it is safe to call getAmplitude()");
}

const uci::type::SignalAmplitudeType& SignalParametricsType::getAmplitude() const {
  return getAmplitude_();
}

uci::type::SignalAmplitudeType& SignalParametricsType::getAmplitude() {
  return getAmplitude_();
}

uci::type::SignalParametricsType& SignalParametricsType::setAmplitude(const uci::type::SignalAmplitudeType& accessor) {
  enableAmplitude();
  if (&accessor != amplitude_Accessor.get()) {
    amplitude_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalParametricsType::hasAmplitude() const noexcept {
  return static_cast<bool>(amplitude_Accessor);
}

uci::type::SignalAmplitudeType& SignalParametricsType::enableAmplitude(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalAmplitudeType : type};
  if ((!amplitude_Accessor) || (amplitude_Accessor->getAccessorType() != requestedType)) {
    amplitude_Accessor = SignalAmplitudeType::create(requestedType);
    if (!amplitude_Accessor) {
      throw uci::base::UCIException("Error in enableAmplitude(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *amplitude_Accessor;
}

uci::type::SignalParametricsType& SignalParametricsType::clearAmplitude() noexcept {
  amplitude_Accessor.reset();
  return *this;
}

uci::type::PolarizationType& SignalParametricsType::getPolarization_() const {
  if (polarization_Accessor) {
    return *polarization_Accessor;
  }
  throw uci::base::UCIException("Error in getPolarization(): An attempt was made to get an optional field that was not enabled, call hasPolarization() to determine if it is safe to call getPolarization()");
}

const uci::type::PolarizationType& SignalParametricsType::getPolarization() const {
  return getPolarization_();
}

uci::type::PolarizationType& SignalParametricsType::getPolarization() {
  return getPolarization_();
}

uci::type::SignalParametricsType& SignalParametricsType::setPolarization(const uci::type::PolarizationType& accessor) {
  enablePolarization();
  if (&accessor != polarization_Accessor.get()) {
    polarization_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalParametricsType::hasPolarization() const noexcept {
  return static_cast<bool>(polarization_Accessor);
}

uci::type::PolarizationType& SignalParametricsType::enablePolarization(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::polarizationType : type};
  if ((!polarization_Accessor) || (polarization_Accessor->getAccessorType() != requestedType)) {
    polarization_Accessor = PolarizationType::create(requestedType);
    if (!polarization_Accessor) {
      throw uci::base::UCIException("Error in enablePolarization(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *polarization_Accessor;
}

uci::type::SignalParametricsType& SignalParametricsType::clearPolarization() noexcept {
  polarization_Accessor.reset();
  return *this;
}

uci::type::ModulationOnPulseDataType& SignalParametricsType::getModulationOnPulse_() const {
  if (modulationOnPulse_Accessor) {
    return *modulationOnPulse_Accessor;
  }
  throw uci::base::UCIException("Error in getModulationOnPulse(): An attempt was made to get an optional field that was not enabled, call hasModulationOnPulse() to determine if it is safe to call getModulationOnPulse()");
}

const uci::type::ModulationOnPulseDataType& SignalParametricsType::getModulationOnPulse() const {
  return getModulationOnPulse_();
}

uci::type::ModulationOnPulseDataType& SignalParametricsType::getModulationOnPulse() {
  return getModulationOnPulse_();
}

uci::type::SignalParametricsType& SignalParametricsType::setModulationOnPulse(const uci::type::ModulationOnPulseDataType& accessor) {
  enableModulationOnPulse();
  if (&accessor != modulationOnPulse_Accessor.get()) {
    modulationOnPulse_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalParametricsType::hasModulationOnPulse() const noexcept {
  return static_cast<bool>(modulationOnPulse_Accessor);
}

uci::type::ModulationOnPulseDataType& SignalParametricsType::enableModulationOnPulse(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::modulationOnPulseDataType : type};
  if ((!modulationOnPulse_Accessor) || (modulationOnPulse_Accessor->getAccessorType() != requestedType)) {
    modulationOnPulse_Accessor = ModulationOnPulseDataType::create(requestedType);
    if (!modulationOnPulse_Accessor) {
      throw uci::base::UCIException("Error in enableModulationOnPulse(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *modulationOnPulse_Accessor;
}

uci::type::SignalParametricsType& SignalParametricsType::clearModulationOnPulse() noexcept {
  modulationOnPulse_Accessor.reset();
  return *this;
}

uci::type::ScanDataType& SignalParametricsType::getScan_() const {
  if (scan_Accessor) {
    return *scan_Accessor;
  }
  throw uci::base::UCIException("Error in getScan(): An attempt was made to get an optional field that was not enabled, call hasScan() to determine if it is safe to call getScan()");
}

const uci::type::ScanDataType& SignalParametricsType::getScan() const {
  return getScan_();
}

uci::type::ScanDataType& SignalParametricsType::getScan() {
  return getScan_();
}

uci::type::SignalParametricsType& SignalParametricsType::setScan(const uci::type::ScanDataType& accessor) {
  enableScan();
  if (&accessor != scan_Accessor.get()) {
    scan_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalParametricsType::hasScan() const noexcept {
  return static_cast<bool>(scan_Accessor);
}

uci::type::ScanDataType& SignalParametricsType::enableScan(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::scanDataType : type};
  if ((!scan_Accessor) || (scan_Accessor->getAccessorType() != requestedType)) {
    scan_Accessor = ScanDataType::create(requestedType);
    if (!scan_Accessor) {
      throw uci::base::UCIException("Error in enableScan(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *scan_Accessor;
}

uci::type::SignalParametricsType& SignalParametricsType::clearScan() noexcept {
  scan_Accessor.reset();
  return *this;
}

uci::type::DecibelTypeValue SignalParametricsType::getSignalNoiseRatio() const {
  if (signalNoiseRatio_Accessor) {
    return *signalNoiseRatio_Accessor;
  }
  throw uci::base::UCIException("Error in getSignalNoiseRatio(): An attempt was made to get an optional field that was not enabled, call hasSignalNoiseRatio() to determine if it is safe to call getSignalNoiseRatio()");
}

uci::type::SignalParametricsType& SignalParametricsType::setSignalNoiseRatio(uci::type::DecibelTypeValue value) {
  signalNoiseRatio_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasSignalNoiseRatio() const noexcept {
  return signalNoiseRatio_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearSignalNoiseRatio() noexcept {
  signalNoiseRatio_Accessor.reset();
  return *this;
}

xs::Double SignalParametricsType::getPulseRepetitionFrequency() const {
  if (pulseRepetitionFrequency_Accessor) {
    return *pulseRepetitionFrequency_Accessor;
  }
  throw uci::base::UCIException("Error in getPulseRepetitionFrequency(): An attempt was made to get an optional field that was not enabled, call hasPulseRepetitionFrequency() to determine if it is safe to call getPulseRepetitionFrequency()");
}

uci::type::SignalParametricsType& SignalParametricsType::setPulseRepetitionFrequency(xs::Double value) {
  pulseRepetitionFrequency_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasPulseRepetitionFrequency() const noexcept {
  return pulseRepetitionFrequency_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearPulseRepetitionFrequency() noexcept {
  pulseRepetitionFrequency_Accessor.reset();
  return *this;
}

xs::Boolean SignalParametricsType::getPulseRepetitionFrequencyCalculated() const {
  if (pulseRepetitionFrequencyCalculated_Accessor) {
    return *pulseRepetitionFrequencyCalculated_Accessor;
  }
  throw uci::base::UCIException("Error in getPulseRepetitionFrequencyCalculated(): An attempt was made to get an optional field that was not enabled, call hasPulseRepetitionFrequencyCalculated() to determine if it is safe to call getPulseRepetitionFrequencyCalculated()");
}

uci::type::SignalParametricsType& SignalParametricsType::setPulseRepetitionFrequencyCalculated(xs::Boolean value) {
  pulseRepetitionFrequencyCalculated_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasPulseRepetitionFrequencyCalculated() const noexcept {
  return pulseRepetitionFrequencyCalculated_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearPulseRepetitionFrequencyCalculated() noexcept {
  pulseRepetitionFrequencyCalculated_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalParametricsType::getPulseDeviation() const {
  if (pulseDeviation_Accessor) {
    return *pulseDeviation_Accessor;
  }
  throw uci::base::UCIException("Error in getPulseDeviation(): An attempt was made to get an optional field that was not enabled, call hasPulseDeviation() to determine if it is safe to call getPulseDeviation()");
}

uci::type::SignalParametricsType& SignalParametricsType::setPulseDeviation(uci::type::DurationTypeValue value) {
  pulseDeviation_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasPulseDeviation() const noexcept {
  return pulseDeviation_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearPulseDeviation() noexcept {
  pulseDeviation_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalParametricsType::getBurstDeviation() const {
  if (burstDeviation_Accessor) {
    return *burstDeviation_Accessor;
  }
  throw uci::base::UCIException("Error in getBurstDeviation(): An attempt was made to get an optional field that was not enabled, call hasBurstDeviation() to determine if it is safe to call getBurstDeviation()");
}

uci::type::SignalParametricsType& SignalParametricsType::setBurstDeviation(uci::type::DurationTypeValue value) {
  burstDeviation_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasBurstDeviation() const noexcept {
  return burstDeviation_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearBurstDeviation() noexcept {
  burstDeviation_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalParametricsType::getIlluminationRate() const {
  if (illuminationRate_Accessor) {
    return *illuminationRate_Accessor;
  }
  throw uci::base::UCIException("Error in getIlluminationRate(): An attempt was made to get an optional field that was not enabled, call hasIlluminationRate() to determine if it is safe to call getIlluminationRate()");
}

uci::type::SignalParametricsType& SignalParametricsType::setIlluminationRate(uci::type::FrequencyTypeValue value) {
  illuminationRate_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasIlluminationRate() const noexcept {
  return illuminationRate_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearIlluminationRate() noexcept {
  illuminationRate_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalParametricsType::getIlluminationRateDeviation() const {
  if (illuminationRateDeviation_Accessor) {
    return *illuminationRateDeviation_Accessor;
  }
  throw uci::base::UCIException("Error in getIlluminationRateDeviation(): An attempt was made to get an optional field that was not enabled, call hasIlluminationRateDeviation() to determine if it is safe to call getIlluminationRateDeviation()");
}

uci::type::SignalParametricsType& SignalParametricsType::setIlluminationRateDeviation(uci::type::FrequencyTypeValue value) {
  illuminationRateDeviation_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasIlluminationRateDeviation() const noexcept {
  return illuminationRateDeviation_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearIlluminationRateDeviation() noexcept {
  illuminationRateDeviation_Accessor.reset();
  return *this;
}

xs::UnsignedInt SignalParametricsType::getPulseCount() const {
  if (pulseCount_Accessor) {
    return *pulseCount_Accessor;
  }
  throw uci::base::UCIException("Error in getPulseCount(): An attempt was made to get an optional field that was not enabled, call hasPulseCount() to determine if it is safe to call getPulseCount()");
}

uci::type::SignalParametricsType& SignalParametricsType::setPulseCount(xs::UnsignedInt value) {
  pulseCount_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasPulseCount() const noexcept {
  return pulseCount_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearPulseCount() noexcept {
  pulseCount_Accessor.reset();
  return *this;
}

xs::UnsignedInt SignalParametricsType::getPulsesPerGroup() const {
  if (pulsesPerGroup_Accessor) {
    return *pulsesPerGroup_Accessor;
  }
  throw uci::base::UCIException("Error in getPulsesPerGroup(): An attempt was made to get an optional field that was not enabled, call hasPulsesPerGroup() to determine if it is safe to call getPulsesPerGroup()");
}

uci::type::SignalParametricsType& SignalParametricsType::setPulsesPerGroup(xs::UnsignedInt value) {
  pulsesPerGroup_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasPulsesPerGroup() const noexcept {
  return pulsesPerGroup_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearPulsesPerGroup() noexcept {
  pulsesPerGroup_Accessor.reset();
  return *this;
}

uci::type::AnglePositiveTypeValue SignalParametricsType::getBeamWidth() const {
  if (beamWidth_Accessor) {
    return *beamWidth_Accessor;
  }
  throw uci::base::UCIException("Error in getBeamWidth(): An attempt was made to get an optional field that was not enabled, call hasBeamWidth() to determine if it is safe to call getBeamWidth()");
}

uci::type::SignalParametricsType& SignalParametricsType::setBeamWidth(uci::type::AnglePositiveTypeValue value) {
  beamWidth_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasBeamWidth() const noexcept {
  return beamWidth_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearBeamWidth() noexcept {
  beamWidth_Accessor.reset();
  return *this;
}

uci::type::FrequencyModulationVariationEnum& SignalParametricsType::getFrequencyModulationVariation_() const {
  if (frequencyModulationVariation_Accessor) {
    return *frequencyModulationVariation_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyModulationVariation(): An attempt was made to get an optional field that was not enabled, call hasFrequencyModulationVariation() to determine if it is safe to call getFrequencyModulationVariation()");
}

const uci::type::FrequencyModulationVariationEnum& SignalParametricsType::getFrequencyModulationVariation() const {
  return getFrequencyModulationVariation_();
}

uci::type::FrequencyModulationVariationEnum& SignalParametricsType::getFrequencyModulationVariation() {
  return getFrequencyModulationVariation_();
}

uci::type::SignalParametricsType& SignalParametricsType::setFrequencyModulationVariation(const uci::type::FrequencyModulationVariationEnum& accessor) {
  enableFrequencyModulationVariation();
  if (&accessor != frequencyModulationVariation_Accessor.get()) {
    frequencyModulationVariation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalParametricsType& SignalParametricsType::setFrequencyModulationVariation(const uci::type::FrequencyModulationVariationEnum::EnumerationItem value) {
  enableFrequencyModulationVariation().setValue(value);
  return *this;
}

bool SignalParametricsType::hasFrequencyModulationVariation() const noexcept {
  return static_cast<bool>(frequencyModulationVariation_Accessor);
}

uci::type::FrequencyModulationVariationEnum& SignalParametricsType::enableFrequencyModulationVariation(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::frequencyModulationVariationEnum : type};
  if ((!frequencyModulationVariation_Accessor) || (frequencyModulationVariation_Accessor->getAccessorType() != requestedType)) {
    frequencyModulationVariation_Accessor = FrequencyModulationVariationEnum::create(requestedType);
    if (!frequencyModulationVariation_Accessor) {
      throw uci::base::UCIException("Error in enableFrequencyModulationVariation(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *frequencyModulationVariation_Accessor;
}

uci::type::SignalParametricsType& SignalParametricsType::clearFrequencyModulationVariation() noexcept {
  frequencyModulationVariation_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalParametricsType::getFrequencyExcursion() const {
  if (frequencyExcursion_Accessor) {
    return *frequencyExcursion_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyExcursion(): An attempt was made to get an optional field that was not enabled, call hasFrequencyExcursion() to determine if it is safe to call getFrequencyExcursion()");
}

uci::type::SignalParametricsType& SignalParametricsType::setFrequencyExcursion(uci::type::FrequencyTypeValue value) {
  frequencyExcursion_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasFrequencyExcursion() const noexcept {
  return frequencyExcursion_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearFrequencyExcursion() noexcept {
  frequencyExcursion_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalParametricsType::getFrequencyExcursionAverage() const {
  if (frequencyExcursionAverage_Accessor) {
    return *frequencyExcursionAverage_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyExcursionAverage(): An attempt was made to get an optional field that was not enabled, call hasFrequencyExcursionAverage() to determine if it is safe to call getFrequencyExcursionAverage()");
}

uci::type::SignalParametricsType& SignalParametricsType::setFrequencyExcursionAverage(uci::type::FrequencyTypeValue value) {
  frequencyExcursionAverage_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasFrequencyExcursionAverage() const noexcept {
  return frequencyExcursionAverage_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearFrequencyExcursionAverage() noexcept {
  frequencyExcursionAverage_Accessor.reset();
  return *this;
}

xs::UnsignedInt SignalParametricsType::getFrequencyExcursionAverageReportCount() const {
  if (frequencyExcursionAverageReportCount_Accessor) {
    return *frequencyExcursionAverageReportCount_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyExcursionAverageReportCount(): An attempt was made to get an optional field that was not enabled, call hasFrequencyExcursionAverageReportCount() to determine if it is safe to call getFrequencyExcursionAverageReportCount()");
}

uci::type::SignalParametricsType& SignalParametricsType::setFrequencyExcursionAverageReportCount(xs::UnsignedInt value) {
  frequencyExcursionAverageReportCount_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasFrequencyExcursionAverageReportCount() const noexcept {
  return frequencyExcursionAverageReportCount_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearFrequencyExcursionAverageReportCount() noexcept {
  frequencyExcursionAverageReportCount_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalParametricsType::getPilotFrequency() const {
  if (pilotFrequency_Accessor) {
    return *pilotFrequency_Accessor;
  }
  throw uci::base::UCIException("Error in getPilotFrequency(): An attempt was made to get an optional field that was not enabled, call hasPilotFrequency() to determine if it is safe to call getPilotFrequency()");
}

uci::type::SignalParametricsType& SignalParametricsType::setPilotFrequency(uci::type::FrequencyTypeValue value) {
  pilotFrequency_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasPilotFrequency() const noexcept {
  return pilotFrequency_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearPilotFrequency() noexcept {
  pilotFrequency_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalParametricsType::getPilotFrequencyAverage() const {
  if (pilotFrequencyAverage_Accessor) {
    return *pilotFrequencyAverage_Accessor;
  }
  throw uci::base::UCIException("Error in getPilotFrequencyAverage(): An attempt was made to get an optional field that was not enabled, call hasPilotFrequencyAverage() to determine if it is safe to call getPilotFrequencyAverage()");
}

uci::type::SignalParametricsType& SignalParametricsType::setPilotFrequencyAverage(uci::type::FrequencyTypeValue value) {
  pilotFrequencyAverage_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasPilotFrequencyAverage() const noexcept {
  return pilotFrequencyAverage_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearPilotFrequencyAverage() noexcept {
  pilotFrequencyAverage_Accessor.reset();
  return *this;
}

xs::UnsignedInt SignalParametricsType::getPilotFrequencyAverageReportCount() const {
  if (pilotFrequencyAverageReportCount_Accessor) {
    return *pilotFrequencyAverageReportCount_Accessor;
  }
  throw uci::base::UCIException("Error in getPilotFrequencyAverageReportCount(): An attempt was made to get an optional field that was not enabled, call hasPilotFrequencyAverageReportCount() to determine if it is safe to call getPilotFrequencyAverageReportCount()");
}

uci::type::SignalParametricsType& SignalParametricsType::setPilotFrequencyAverageReportCount(xs::UnsignedInt value) {
  pilotFrequencyAverageReportCount_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasPilotFrequencyAverageReportCount() const noexcept {
  return pilotFrequencyAverageReportCount_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearPilotFrequencyAverageReportCount() noexcept {
  pilotFrequencyAverageReportCount_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalParametricsType::getAverageBasebandedPulseRepetitionInterval() const {
  if (averageBasebandedPulseRepetitionInterval_Accessor) {
    return *averageBasebandedPulseRepetitionInterval_Accessor;
  }
  throw uci::base::UCIException("Error in getAverageBasebandedPulseRepetitionInterval(): An attempt was made to get an optional field that was not enabled, call hasAverageBasebandedPulseRepetitionInterval() to determine if it is safe to call getAverageBasebandedPulseRepetitionInterval()");
}

uci::type::SignalParametricsType& SignalParametricsType::setAverageBasebandedPulseRepetitionInterval(uci::type::DurationTypeValue value) {
  averageBasebandedPulseRepetitionInterval_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasAverageBasebandedPulseRepetitionInterval() const noexcept {
  return averageBasebandedPulseRepetitionInterval_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearAverageBasebandedPulseRepetitionInterval() noexcept {
  averageBasebandedPulseRepetitionInterval_Accessor.reset();
  return *this;
}

xs::UnsignedShort SignalParametricsType::getAverageBasebandedPulseRepetitionIntervalReportCount() const {
  if (averageBasebandedPulseRepetitionIntervalReportCount_Accessor) {
    return *averageBasebandedPulseRepetitionIntervalReportCount_Accessor;
  }
  throw uci::base::UCIException("Error in getAverageBasebandedPulseRepetitionIntervalReportCount(): An attempt was made to get an optional field that was not enabled, call hasAverageBasebandedPulseRepetitionIntervalReportCount() to determine if it is safe to call getAverageBasebandedPulseRepetitionIntervalReportCount()");
}

uci::type::SignalParametricsType& SignalParametricsType::setAverageBasebandedPulseRepetitionIntervalReportCount(xs::UnsignedShort value) {
  averageBasebandedPulseRepetitionIntervalReportCount_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasAverageBasebandedPulseRepetitionIntervalReportCount() const noexcept {
  return averageBasebandedPulseRepetitionIntervalReportCount_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearAverageBasebandedPulseRepetitionIntervalReportCount() noexcept {
  averageBasebandedPulseRepetitionIntervalReportCount_Accessor.reset();
  return *this;
}

uci::type::DoubleNonNegativeTypeValue SignalParametricsType::getBasebandedPulseRepetitionIntervalDeviation() const {
  if (basebandedPulseRepetitionIntervalDeviation_Accessor) {
    return *basebandedPulseRepetitionIntervalDeviation_Accessor;
  }
  throw uci::base::UCIException("Error in getBasebandedPulseRepetitionIntervalDeviation(): An attempt was made to get an optional field that was not enabled, call hasBasebandedPulseRepetitionIntervalDeviation() to determine if it is safe to call getBasebandedPulseRepetitionIntervalDeviation()");
}

uci::type::SignalParametricsType& SignalParametricsType::setBasebandedPulseRepetitionIntervalDeviation(uci::type::DoubleNonNegativeTypeValue value) {
  basebandedPulseRepetitionIntervalDeviation_Accessor = value;
  return *this;
}

bool SignalParametricsType::hasBasebandedPulseRepetitionIntervalDeviation() const noexcept {
  return basebandedPulseRepetitionIntervalDeviation_Accessor.has_value();
}

uci::type::SignalParametricsType& SignalParametricsType::clearBasebandedPulseRepetitionIntervalDeviation() noexcept {
  basebandedPulseRepetitionIntervalDeviation_Accessor.reset();
  return *this;
}

uci::type::LongBaselineInterferometerInfoType& SignalParametricsType::getLongBaselineInterferometerInfo_() const {
  if (longBaselineInterferometerInfo_Accessor) {
    return *longBaselineInterferometerInfo_Accessor;
  }
  throw uci::base::UCIException("Error in getLongBaselineInterferometerInfo(): An attempt was made to get an optional field that was not enabled, call hasLongBaselineInterferometerInfo() to determine if it is safe to call getLongBaselineInterferometerInfo()");
}

const uci::type::LongBaselineInterferometerInfoType& SignalParametricsType::getLongBaselineInterferometerInfo() const {
  return getLongBaselineInterferometerInfo_();
}

uci::type::LongBaselineInterferometerInfoType& SignalParametricsType::getLongBaselineInterferometerInfo() {
  return getLongBaselineInterferometerInfo_();
}

uci::type::SignalParametricsType& SignalParametricsType::setLongBaselineInterferometerInfo(const uci::type::LongBaselineInterferometerInfoType& accessor) {
  enableLongBaselineInterferometerInfo();
  if (&accessor != longBaselineInterferometerInfo_Accessor.get()) {
    longBaselineInterferometerInfo_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalParametricsType::hasLongBaselineInterferometerInfo() const noexcept {
  return static_cast<bool>(longBaselineInterferometerInfo_Accessor);
}

uci::type::LongBaselineInterferometerInfoType& SignalParametricsType::enableLongBaselineInterferometerInfo(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::longBaselineInterferometerInfoType : type};
  if ((!longBaselineInterferometerInfo_Accessor) || (longBaselineInterferometerInfo_Accessor->getAccessorType() != requestedType)) {
    longBaselineInterferometerInfo_Accessor = LongBaselineInterferometerInfoType::create(requestedType);
    if (!longBaselineInterferometerInfo_Accessor) {
      throw uci::base::UCIException("Error in enableLongBaselineInterferometerInfo(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *longBaselineInterferometerInfo_Accessor;
}

uci::type::SignalParametricsType& SignalParametricsType::clearLongBaselineInterferometerInfo() noexcept {
  longBaselineInterferometerInfo_Accessor.reset();
  return *this;
}

std::unique_ptr<SignalParametricsType> SignalParametricsType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalParametricsType : type};
  return (requestedType == uci::type::accessorType::signalParametricsType) ? boost::make_unique<SignalParametricsType>() : nullptr;
}

/**  */
namespace SignalParametricsType_Names {

constexpr const char* Extern_Type_Name{"SignalParametricsType"};
constexpr const char* Frequency_Name{"Frequency"};
constexpr const char* PRI_PW_Name{"PRI_PW"};
constexpr const char* Amplitude_Name{"Amplitude"};
constexpr const char* Polarization_Name{"Polarization"};
constexpr const char* ModulationOnPulse_Name{"ModulationOnPulse"};
constexpr const char* Scan_Name{"Scan"};
constexpr const char* SignalNoiseRatio_Name{"SignalNoiseRatio"};
constexpr const char* PulseRepetitionFrequency_Name{"PulseRepetitionFrequency"};
constexpr const char* PulseRepetitionFrequencyCalculated_Name{"PulseRepetitionFrequencyCalculated"};
constexpr const char* PulseDeviation_Name{"PulseDeviation"};
constexpr const char* BurstDeviation_Name{"BurstDeviation"};
constexpr const char* IlluminationRate_Name{"IlluminationRate"};
constexpr const char* IlluminationRateDeviation_Name{"IlluminationRateDeviation"};
constexpr const char* PulseCount_Name{"PulseCount"};
constexpr const char* PulsesPerGroup_Name{"PulsesPerGroup"};
constexpr const char* BeamWidth_Name{"BeamWidth"};
constexpr const char* FrequencyModulationVariation_Name{"FrequencyModulationVariation"};
constexpr const char* FrequencyExcursion_Name{"FrequencyExcursion"};
constexpr const char* FrequencyExcursionAverage_Name{"FrequencyExcursionAverage"};
constexpr const char* FrequencyExcursionAverageReportCount_Name{"FrequencyExcursionAverageReportCount"};
constexpr const char* PilotFrequency_Name{"PilotFrequency"};
constexpr const char* PilotFrequencyAverage_Name{"PilotFrequencyAverage"};
constexpr const char* PilotFrequencyAverageReportCount_Name{"PilotFrequencyAverageReportCount"};
constexpr const char* AverageBasebandedPulseRepetitionInterval_Name{"AverageBasebandedPulseRepetitionInterval"};
constexpr const char* AverageBasebandedPulseRepetitionIntervalReportCount_Name{"AverageBasebandedPulseRepetitionIntervalReportCount"};
constexpr const char* BasebandedPulseRepetitionIntervalDeviation_Name{"BasebandedPulseRepetitionIntervalDeviation"};
constexpr const char* LongBaselineInterferometerInfo_Name{"LongBaselineInterferometerInfo"};

} // namespace SignalParametricsType_Names

void SignalParametricsType::deserialize(const boost::property_tree::ptree& propTree, uci::type::SignalParametricsType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = SignalParametricsType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::Frequency_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SignalParametricsType::Frequency& boundedList = accessor.getFrequency();
        const uci::type::SignalParametricsType::Frequency::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::FrequencyDataType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PRI_PW_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SignalParametricsType::PRI_PW& boundedList = accessor.getPRI_PW();
        const uci::type::SignalParametricsType::PRI_PW::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::PRI_PW_Type::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::Amplitude_Name) {
      SignalAmplitudeType::deserialize(valueType.second, accessor.enableAmplitude(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::Polarization_Name) {
      PolarizationType::deserialize(valueType.second, accessor.enablePolarization(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::ModulationOnPulse_Name) {
      ModulationOnPulseDataType::deserialize(valueType.second, accessor.enableModulationOnPulse(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::Scan_Name) {
      ScanDataType::deserialize(valueType.second, accessor.enableScan(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::SignalNoiseRatio_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setSignalNoiseRatio(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PulseRepetitionFrequency_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPulseRepetitionFrequency(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PulseRepetitionFrequencyCalculated_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPulseRepetitionFrequencyCalculated(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PulseDeviation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPulseDeviation(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::BurstDeviation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setBurstDeviation(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::IlluminationRate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setIlluminationRate(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::IlluminationRateDeviation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setIlluminationRateDeviation(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PulseCount_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPulseCount(asb_uci::util::SerializationHelpers::deserializeUnsignedInt(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PulsesPerGroup_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPulsesPerGroup(asb_uci::util::SerializationHelpers::deserializeUnsignedInt(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::BeamWidth_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setBeamWidth(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::FrequencyModulationVariation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableFrequencyModulationVariation().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::FrequencyExcursion_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFrequencyExcursion(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::FrequencyExcursionAverage_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFrequencyExcursionAverage(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::FrequencyExcursionAverageReportCount_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFrequencyExcursionAverageReportCount(asb_uci::util::SerializationHelpers::deserializeUnsignedInt(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PilotFrequency_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPilotFrequency(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PilotFrequencyAverage_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPilotFrequencyAverage(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::PilotFrequencyAverageReportCount_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPilotFrequencyAverageReportCount(asb_uci::util::SerializationHelpers::deserializeUnsignedInt(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::AverageBasebandedPulseRepetitionInterval_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAverageBasebandedPulseRepetitionInterval(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::AverageBasebandedPulseRepetitionIntervalReportCount_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAverageBasebandedPulseRepetitionIntervalReportCount(asb_uci::util::SerializationHelpers::deserializeUnsignedShort(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::BasebandedPulseRepetitionIntervalDeviation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setBasebandedPulseRepetitionIntervalDeviation(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalParametricsType_Names::LongBaselineInterferometerInfo_Name) {
      LongBaselineInterferometerInfoType::deserialize(valueType.second, accessor.enableLongBaselineInterferometerInfo(), nodeName, nsPrefix);
    }
  }
}

std::string SignalParametricsType::serialize(const uci::type::SignalParametricsType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? SignalParametricsType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, SignalParametricsType_Names::Extern_Type_Name);
  }
  {
    const uci::type::SignalParametricsType::Frequency& boundedList = accessor.getFrequency();
    for (uci::type::SignalParametricsType::Frequency::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::FrequencyDataType::serialize(boundedList.at(i), node, SignalParametricsType_Names::Frequency_Name);
    }
  }
  {
    const uci::type::SignalParametricsType::PRI_PW& boundedList = accessor.getPRI_PW();
    for (uci::type::SignalParametricsType::PRI_PW::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::PRI_PW_Type::serialize(boundedList.at(i), node, SignalParametricsType_Names::PRI_PW_Name);
    }
  }
  if (accessor.hasAmplitude()) {
    SignalAmplitudeType::serialize(accessor.getAmplitude(), node, SignalParametricsType_Names::Amplitude_Name);
  }
  if (accessor.hasPolarization()) {
    PolarizationType::serialize(accessor.getPolarization(), node, SignalParametricsType_Names::Polarization_Name);
  }
  if (accessor.hasModulationOnPulse()) {
    ModulationOnPulseDataType::serialize(accessor.getModulationOnPulse(), node, SignalParametricsType_Names::ModulationOnPulse_Name);
  }
  if (accessor.hasScan()) {
    ScanDataType::serialize(accessor.getScan(), node, SignalParametricsType_Names::Scan_Name);
  }
  if (accessor.hasSignalNoiseRatio()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getSignalNoiseRatio(), node, SignalParametricsType_Names::SignalNoiseRatio_Name);
  }
  if (accessor.hasPulseRepetitionFrequency()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getPulseRepetitionFrequency(), node, SignalParametricsType_Names::PulseRepetitionFrequency_Name);
  }
  if (accessor.hasPulseRepetitionFrequencyCalculated()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getPulseRepetitionFrequencyCalculated(), node, SignalParametricsType_Names::PulseRepetitionFrequencyCalculated_Name);
  }
  if (accessor.hasPulseDeviation()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getPulseDeviation(), node, SignalParametricsType_Names::PulseDeviation_Name);
  }
  if (accessor.hasBurstDeviation()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getBurstDeviation(), node, SignalParametricsType_Names::BurstDeviation_Name);
  }
  if (accessor.hasIlluminationRate()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getIlluminationRate(), node, SignalParametricsType_Names::IlluminationRate_Name);
  }
  if (accessor.hasIlluminationRateDeviation()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getIlluminationRateDeviation(), node, SignalParametricsType_Names::IlluminationRateDeviation_Name);
  }
  if (accessor.hasPulseCount()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedInt(accessor.getPulseCount(), node, SignalParametricsType_Names::PulseCount_Name);
  }
  if (accessor.hasPulsesPerGroup()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedInt(accessor.getPulsesPerGroup(), node, SignalParametricsType_Names::PulsesPerGroup_Name);
  }
  if (accessor.hasBeamWidth()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getBeamWidth(), node, SignalParametricsType_Names::BeamWidth_Name);
  }
  if (accessor.hasFrequencyModulationVariation()) {
    FrequencyModulationVariationEnum::serialize(accessor.getFrequencyModulationVariation(), node, SignalParametricsType_Names::FrequencyModulationVariation_Name, false);
  }
  if (accessor.hasFrequencyExcursion()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getFrequencyExcursion(), node, SignalParametricsType_Names::FrequencyExcursion_Name);
  }
  if (accessor.hasFrequencyExcursionAverage()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getFrequencyExcursionAverage(), node, SignalParametricsType_Names::FrequencyExcursionAverage_Name);
  }
  if (accessor.hasFrequencyExcursionAverageReportCount()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedInt(accessor.getFrequencyExcursionAverageReportCount(), node, SignalParametricsType_Names::FrequencyExcursionAverageReportCount_Name);
  }
  if (accessor.hasPilotFrequency()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getPilotFrequency(), node, SignalParametricsType_Names::PilotFrequency_Name);
  }
  if (accessor.hasPilotFrequencyAverage()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getPilotFrequencyAverage(), node, SignalParametricsType_Names::PilotFrequencyAverage_Name);
  }
  if (accessor.hasPilotFrequencyAverageReportCount()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedInt(accessor.getPilotFrequencyAverageReportCount(), node, SignalParametricsType_Names::PilotFrequencyAverageReportCount_Name);
  }
  if (accessor.hasAverageBasebandedPulseRepetitionInterval()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getAverageBasebandedPulseRepetitionInterval(), node, SignalParametricsType_Names::AverageBasebandedPulseRepetitionInterval_Name);
  }
  if (accessor.hasAverageBasebandedPulseRepetitionIntervalReportCount()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedShort(accessor.getAverageBasebandedPulseRepetitionIntervalReportCount(), node, SignalParametricsType_Names::AverageBasebandedPulseRepetitionIntervalReportCount_Name);
  }
  if (accessor.hasBasebandedPulseRepetitionIntervalDeviation()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getBasebandedPulseRepetitionIntervalDeviation(), node, SignalParametricsType_Names::BasebandedPulseRepetitionIntervalDeviation_Name);
  }
  if (accessor.hasLongBaselineInterferometerInfo()) {
    LongBaselineInterferometerInfoType::serialize(accessor.getLongBaselineInterferometerInfo(), node, SignalParametricsType_Names::LongBaselineInterferometerInfo_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::SignalParametricsType& SignalParametricsType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::SignalParametricsType>().release());
}

uci::type::SignalParametricsType& SignalParametricsType::create(const uci::type::SignalParametricsType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::SignalParametricsType> newAccessor{boost::make_unique<asb_uci::type::SignalParametricsType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void SignalParametricsType::destroy(uci::type::SignalParametricsType& accessor) {
  delete dynamic_cast<asb_uci::type::SignalParametricsType*>(&accessor);
}

} // namespace type

} // namespace uci

