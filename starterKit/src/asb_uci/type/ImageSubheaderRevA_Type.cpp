/** @file ImageSubheaderRevA_Type.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/ImageSubheaderRevA_Type.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/CharOrSpacePairsType.h"
#include "asb_uci/type/IID2_ChoiceType.h"
#include "asb_uci/type/NITF_CodewordsType.h"
#include "asb_uci/type/NITF_ControlAndHandlingType.h"
#include "asb_uci/type/NITF_DateType.h"
#include "asb_uci/type/NITF_DeclassificationExemptionType.h"
#include "asb_uci/type/NITF_DeclassificationType.h"
#include "asb_uci/type/NITF_ReleasingInstructionsType.h"
#include "asb_uci/type/VisibleLatin1String15Type.h"
#include "asb_uci/type/VisibleLatin1String40Type.h"
#include "asb_uci/type/VisibleLatin1String43Type.h"
#include "asb_uci/type/VisibleString17Type.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/CharOrSpacePairsType.h"
#include "uci/type/IID2_ChoiceType.h"
#include "uci/type/ImageSubheaderRevA_Type.h"
#include "uci/type/NITF_ClassificationAuthorityType.h"
#include "uci/type/NITF_ClassificationReasonType.h"
#include "uci/type/NITF_CodewordsType.h"
#include "uci/type/NITF_ControlAndHandlingType.h"
#include "uci/type/NITF_DateType.h"
#include "uci/type/NITF_DeclassificationExemptionType.h"
#include "uci/type/NITF_DeclassificationType.h"
#include "uci/type/NITF_DowngradeType.h"
#include "uci/type/NITF_FileSecurityClassificationType.h"
#include "uci/type/NITF_ReleasingInstructionsType.h"
#include "uci/type/VisibleLatin1String15Type.h"
#include "uci/type/VisibleLatin1String40Type.h"
#include "uci/type/VisibleLatin1String43Type.h"
#include "uci/type/VisibleString17Type.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

ImageSubheaderRevA_Type::ImageSubheaderRevA_Type()
  : imageSecurityClassification_Accessor{boost::make_unique<NITF_FileSecurityClassificationType>()} {
}

ImageSubheaderRevA_Type::~ImageSubheaderRevA_Type() = default;

void ImageSubheaderRevA_Type::copy(const uci::type::ImageSubheaderRevA_Type& accessor) {
  copyImpl(accessor, false);
}

void ImageSubheaderRevA_Type::copyImpl(const uci::type::ImageSubheaderRevA_Type& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const ImageSubheaderRevA_Type&>(accessor);
    if (accessorImpl.targetIdentifier_Accessor) {
      setTargetIdentifier(*(accessorImpl.targetIdentifier_Accessor));
    } else {
      targetIdentifier_Accessor.reset();
    }
    if (accessorImpl.iID2_Accessor) {
      setIID2(*(accessorImpl.iID2_Accessor));
    } else {
      iID2_Accessor.reset();
    }
    setImageSecurityClassification(*(accessorImpl.imageSecurityClassification_Accessor));
    if (accessorImpl.imageSecurityClassificationSystem_Accessor) {
      setImageSecurityClassificationSystem(*(accessorImpl.imageSecurityClassificationSystem_Accessor));
    } else {
      imageSecurityClassificationSystem_Accessor.reset();
    }
    if (accessorImpl.imageCodewords_Accessor) {
      setImageCodewords(*(accessorImpl.imageCodewords_Accessor));
    } else {
      imageCodewords_Accessor.reset();
    }
    if (accessorImpl.imageControlAndHandling_Accessor) {
      setImageControlAndHandling(*(accessorImpl.imageControlAndHandling_Accessor));
    } else {
      imageControlAndHandling_Accessor.reset();
    }
    if (accessorImpl.imageReleasingInstructions_Accessor) {
      setImageReleasingInstructions(*(accessorImpl.imageReleasingInstructions_Accessor));
    } else {
      imageReleasingInstructions_Accessor.reset();
    }
    if (accessorImpl.imageDeclassificationType_Accessor) {
      setImageDeclassificationType(*(accessorImpl.imageDeclassificationType_Accessor));
    } else {
      imageDeclassificationType_Accessor.reset();
    }
    if (accessorImpl.imageDeclassificationDate_Accessor) {
      setImageDeclassificationDate(*(accessorImpl.imageDeclassificationDate_Accessor));
    } else {
      imageDeclassificationDate_Accessor.reset();
    }
    if (accessorImpl.imageDeclassificationExemption_Accessor) {
      setImageDeclassificationExemption(*(accessorImpl.imageDeclassificationExemption_Accessor));
    } else {
      imageDeclassificationExemption_Accessor.reset();
    }
    if (accessorImpl.imageDowngrade_Accessor) {
      setImageDowngrade(*(accessorImpl.imageDowngrade_Accessor));
    } else {
      imageDowngrade_Accessor.reset();
    }
    if (accessorImpl.imageDowngradeDate_Accessor) {
      setImageDowngradeDate(*(accessorImpl.imageDowngradeDate_Accessor));
    } else {
      imageDowngradeDate_Accessor.reset();
    }
    if (accessorImpl.imageClassificationText_Accessor) {
      setImageClassificationText(*(accessorImpl.imageClassificationText_Accessor));
    } else {
      imageClassificationText_Accessor.reset();
    }
    if (accessorImpl.imageClassificationAuthorityType_Accessor) {
      setImageClassificationAuthorityType(*(accessorImpl.imageClassificationAuthorityType_Accessor));
    } else {
      imageClassificationAuthorityType_Accessor.reset();
    }
    if (accessorImpl.imageClassificationAuthority_Accessor) {
      setImageClassificationAuthority(*(accessorImpl.imageClassificationAuthority_Accessor));
    } else {
      imageClassificationAuthority_Accessor.reset();
    }
    if (accessorImpl.imageClassificationReason_Accessor) {
      setImageClassificationReason(*(accessorImpl.imageClassificationReason_Accessor));
    } else {
      imageClassificationReason_Accessor.reset();
    }
    if (accessorImpl.imageSecuritySourceDate_Accessor) {
      setImageSecuritySourceDate(*(accessorImpl.imageSecuritySourceDate_Accessor));
    } else {
      imageSecuritySourceDate_Accessor.reset();
    }
    if (accessorImpl.imageSecurityControlNumber_Accessor) {
      setImageSecurityControlNumber(*(accessorImpl.imageSecurityControlNumber_Accessor));
    } else {
      imageSecurityControlNumber_Accessor.reset();
    }
  }
}

void ImageSubheaderRevA_Type::reset() noexcept {
  targetIdentifier_Accessor.reset();
  iID2_Accessor.reset();
  imageSecurityClassification_Accessor->reset();
  imageSecurityClassificationSystem_Accessor.reset();
  imageCodewords_Accessor.reset();
  imageControlAndHandling_Accessor.reset();
  imageReleasingInstructions_Accessor.reset();
  imageDeclassificationType_Accessor.reset();
  imageDeclassificationDate_Accessor.reset();
  imageDeclassificationExemption_Accessor.reset();
  imageDowngrade_Accessor.reset();
  imageDowngradeDate_Accessor.reset();
  imageClassificationText_Accessor.reset();
  imageClassificationAuthorityType_Accessor.reset();
  imageClassificationAuthority_Accessor.reset();
  imageClassificationReason_Accessor.reset();
  imageSecuritySourceDate_Accessor.reset();
  imageSecurityControlNumber_Accessor.reset();
}

uci::type::VisibleString17Type& ImageSubheaderRevA_Type::getTargetIdentifier_() const {
  if (targetIdentifier_Accessor) {
    return *targetIdentifier_Accessor;
  }
  throw uci::base::UCIException("Error in getTargetIdentifier(): An attempt was made to get an optional field that was not enabled, call hasTargetIdentifier() to determine if it is safe to call getTargetIdentifier()");
}

const uci::type::VisibleString17Type& ImageSubheaderRevA_Type::getTargetIdentifier() const {
  return getTargetIdentifier_();
}

uci::type::VisibleString17Type& ImageSubheaderRevA_Type::getTargetIdentifier() {
  return getTargetIdentifier_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setTargetIdentifier(const uci::type::VisibleString17Type& value) {
  return setTargetIdentifier(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setTargetIdentifier(const std::string& value) {
  return setTargetIdentifier(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setTargetIdentifier(const char* value) {
  enableTargetIdentifier().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasTargetIdentifier() const noexcept {
  return static_cast<bool>(targetIdentifier_Accessor);
}

uci::type::VisibleString17Type& ImageSubheaderRevA_Type::enableTargetIdentifier(uci::base::accessorType::AccessorType type) {
  if (!targetIdentifier_Accessor) {
    targetIdentifier_Accessor = VisibleString17Type::create(type);
  }
  return *targetIdentifier_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearTargetIdentifier() noexcept {
  targetIdentifier_Accessor.reset();
  return *this;
}

uci::type::IID2_ChoiceType& ImageSubheaderRevA_Type::getIID2_() const {
  if (iID2_Accessor) {
    return *iID2_Accessor;
  }
  throw uci::base::UCIException("Error in getIID2(): An attempt was made to get an optional field that was not enabled, call hasIID2() to determine if it is safe to call getIID2()");
}

const uci::type::IID2_ChoiceType& ImageSubheaderRevA_Type::getIID2() const {
  return getIID2_();
}

uci::type::IID2_ChoiceType& ImageSubheaderRevA_Type::getIID2() {
  return getIID2_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setIID2(const uci::type::IID2_ChoiceType& accessor) {
  enableIID2();
  if (&accessor != iID2_Accessor.get()) {
    iID2_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool ImageSubheaderRevA_Type::hasIID2() const noexcept {
  return static_cast<bool>(iID2_Accessor);
}

uci::type::IID2_ChoiceType& ImageSubheaderRevA_Type::enableIID2(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::iID2_ChoiceType : type};
  if ((!iID2_Accessor) || (iID2_Accessor->getAccessorType() != requestedType)) {
    iID2_Accessor = IID2_ChoiceType::create(requestedType);
    if (!iID2_Accessor) {
      throw uci::base::UCIException("Error in enableIID2(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *iID2_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearIID2() noexcept {
  iID2_Accessor.reset();
  return *this;
}

const uci::type::NITF_FileSecurityClassificationType& ImageSubheaderRevA_Type::getImageSecurityClassification() const noexcept {
  return *imageSecurityClassification_Accessor;
}

uci::type::NITF_FileSecurityClassificationType& ImageSubheaderRevA_Type::getImageSecurityClassification() noexcept {
  return *imageSecurityClassification_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityClassification(const uci::type::NITF_FileSecurityClassificationType& value) {
  return setImageSecurityClassification(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityClassification(const std::string& value) {
  return setImageSecurityClassification(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityClassification(const char* value) {
  imageSecurityClassification_Accessor->setStringValue(value);
  return *this;
}

uci::type::CharOrSpacePairsType& ImageSubheaderRevA_Type::getImageSecurityClassificationSystem_() const {
  if (imageSecurityClassificationSystem_Accessor) {
    return *imageSecurityClassificationSystem_Accessor;
  }
  throw uci::base::UCIException("Error in getImageSecurityClassificationSystem(): An attempt was made to get an optional field that was not enabled, call hasImageSecurityClassificationSystem() to determine if it is safe to call getImageSecurityClassificationSystem()");
}

const uci::type::CharOrSpacePairsType& ImageSubheaderRevA_Type::getImageSecurityClassificationSystem() const {
  return getImageSecurityClassificationSystem_();
}

uci::type::CharOrSpacePairsType& ImageSubheaderRevA_Type::getImageSecurityClassificationSystem() {
  return getImageSecurityClassificationSystem_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityClassificationSystem(const uci::type::CharOrSpacePairsType& value) {
  return setImageSecurityClassificationSystem(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityClassificationSystem(const std::string& value) {
  return setImageSecurityClassificationSystem(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityClassificationSystem(const char* value) {
  enableImageSecurityClassificationSystem().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageSecurityClassificationSystem() const noexcept {
  return static_cast<bool>(imageSecurityClassificationSystem_Accessor);
}

uci::type::CharOrSpacePairsType& ImageSubheaderRevA_Type::enableImageSecurityClassificationSystem(uci::base::accessorType::AccessorType type) {
  if (!imageSecurityClassificationSystem_Accessor) {
    imageSecurityClassificationSystem_Accessor = CharOrSpacePairsType::create(type);
  }
  return *imageSecurityClassificationSystem_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageSecurityClassificationSystem() noexcept {
  imageSecurityClassificationSystem_Accessor.reset();
  return *this;
}

uci::type::NITF_CodewordsType& ImageSubheaderRevA_Type::getImageCodewords_() const {
  if (imageCodewords_Accessor) {
    return *imageCodewords_Accessor;
  }
  throw uci::base::UCIException("Error in getImageCodewords(): An attempt was made to get an optional field that was not enabled, call hasImageCodewords() to determine if it is safe to call getImageCodewords()");
}

const uci::type::NITF_CodewordsType& ImageSubheaderRevA_Type::getImageCodewords() const {
  return getImageCodewords_();
}

uci::type::NITF_CodewordsType& ImageSubheaderRevA_Type::getImageCodewords() {
  return getImageCodewords_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageCodewords(const uci::type::NITF_CodewordsType& value) {
  return setImageCodewords(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageCodewords(const std::string& value) {
  return setImageCodewords(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageCodewords(const char* value) {
  enableImageCodewords().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageCodewords() const noexcept {
  return static_cast<bool>(imageCodewords_Accessor);
}

uci::type::NITF_CodewordsType& ImageSubheaderRevA_Type::enableImageCodewords(uci::base::accessorType::AccessorType type) {
  if (!imageCodewords_Accessor) {
    imageCodewords_Accessor = NITF_CodewordsType::create(type);
  }
  return *imageCodewords_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageCodewords() noexcept {
  imageCodewords_Accessor.reset();
  return *this;
}

uci::type::NITF_ControlAndHandlingType& ImageSubheaderRevA_Type::getImageControlAndHandling_() const {
  if (imageControlAndHandling_Accessor) {
    return *imageControlAndHandling_Accessor;
  }
  throw uci::base::UCIException("Error in getImageControlAndHandling(): An attempt was made to get an optional field that was not enabled, call hasImageControlAndHandling() to determine if it is safe to call getImageControlAndHandling()");
}

const uci::type::NITF_ControlAndHandlingType& ImageSubheaderRevA_Type::getImageControlAndHandling() const {
  return getImageControlAndHandling_();
}

uci::type::NITF_ControlAndHandlingType& ImageSubheaderRevA_Type::getImageControlAndHandling() {
  return getImageControlAndHandling_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageControlAndHandling(const uci::type::NITF_ControlAndHandlingType& value) {
  return setImageControlAndHandling(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageControlAndHandling(const std::string& value) {
  return setImageControlAndHandling(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageControlAndHandling(const char* value) {
  enableImageControlAndHandling().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageControlAndHandling() const noexcept {
  return static_cast<bool>(imageControlAndHandling_Accessor);
}

uci::type::NITF_ControlAndHandlingType& ImageSubheaderRevA_Type::enableImageControlAndHandling(uci::base::accessorType::AccessorType type) {
  if (!imageControlAndHandling_Accessor) {
    imageControlAndHandling_Accessor = NITF_ControlAndHandlingType::create(type);
  }
  return *imageControlAndHandling_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageControlAndHandling() noexcept {
  imageControlAndHandling_Accessor.reset();
  return *this;
}

uci::type::NITF_ReleasingInstructionsType& ImageSubheaderRevA_Type::getImageReleasingInstructions_() const {
  if (imageReleasingInstructions_Accessor) {
    return *imageReleasingInstructions_Accessor;
  }
  throw uci::base::UCIException("Error in getImageReleasingInstructions(): An attempt was made to get an optional field that was not enabled, call hasImageReleasingInstructions() to determine if it is safe to call getImageReleasingInstructions()");
}

const uci::type::NITF_ReleasingInstructionsType& ImageSubheaderRevA_Type::getImageReleasingInstructions() const {
  return getImageReleasingInstructions_();
}

uci::type::NITF_ReleasingInstructionsType& ImageSubheaderRevA_Type::getImageReleasingInstructions() {
  return getImageReleasingInstructions_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageReleasingInstructions(const uci::type::NITF_ReleasingInstructionsType& value) {
  return setImageReleasingInstructions(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageReleasingInstructions(const std::string& value) {
  return setImageReleasingInstructions(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageReleasingInstructions(const char* value) {
  enableImageReleasingInstructions().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageReleasingInstructions() const noexcept {
  return static_cast<bool>(imageReleasingInstructions_Accessor);
}

uci::type::NITF_ReleasingInstructionsType& ImageSubheaderRevA_Type::enableImageReleasingInstructions(uci::base::accessorType::AccessorType type) {
  if (!imageReleasingInstructions_Accessor) {
    imageReleasingInstructions_Accessor = NITF_ReleasingInstructionsType::create(type);
  }
  return *imageReleasingInstructions_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageReleasingInstructions() noexcept {
  imageReleasingInstructions_Accessor.reset();
  return *this;
}

uci::type::NITF_DeclassificationType& ImageSubheaderRevA_Type::getImageDeclassificationType_() const {
  if (imageDeclassificationType_Accessor) {
    return *imageDeclassificationType_Accessor;
  }
  throw uci::base::UCIException("Error in getImageDeclassificationType(): An attempt was made to get an optional field that was not enabled, call hasImageDeclassificationType() to determine if it is safe to call getImageDeclassificationType()");
}

const uci::type::NITF_DeclassificationType& ImageSubheaderRevA_Type::getImageDeclassificationType() const {
  return getImageDeclassificationType_();
}

uci::type::NITF_DeclassificationType& ImageSubheaderRevA_Type::getImageDeclassificationType() {
  return getImageDeclassificationType_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationType(const uci::type::NITF_DeclassificationType& value) {
  return setImageDeclassificationType(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationType(const std::string& value) {
  return setImageDeclassificationType(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationType(const char* value) {
  enableImageDeclassificationType().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageDeclassificationType() const noexcept {
  return static_cast<bool>(imageDeclassificationType_Accessor);
}

uci::type::NITF_DeclassificationType& ImageSubheaderRevA_Type::enableImageDeclassificationType(uci::base::accessorType::AccessorType type) {
  if (!imageDeclassificationType_Accessor) {
    imageDeclassificationType_Accessor = NITF_DeclassificationType::create(type);
  }
  return *imageDeclassificationType_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageDeclassificationType() noexcept {
  imageDeclassificationType_Accessor.reset();
  return *this;
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageDeclassificationDate_() const {
  if (imageDeclassificationDate_Accessor) {
    return *imageDeclassificationDate_Accessor;
  }
  throw uci::base::UCIException("Error in getImageDeclassificationDate(): An attempt was made to get an optional field that was not enabled, call hasImageDeclassificationDate() to determine if it is safe to call getImageDeclassificationDate()");
}

const uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageDeclassificationDate() const {
  return getImageDeclassificationDate_();
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageDeclassificationDate() {
  return getImageDeclassificationDate_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationDate(const uci::type::NITF_DateType& value) {
  return setImageDeclassificationDate(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationDate(const std::string& value) {
  return setImageDeclassificationDate(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationDate(const char* value) {
  enableImageDeclassificationDate().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageDeclassificationDate() const noexcept {
  return static_cast<bool>(imageDeclassificationDate_Accessor);
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::enableImageDeclassificationDate(uci::base::accessorType::AccessorType type) {
  if (!imageDeclassificationDate_Accessor) {
    imageDeclassificationDate_Accessor = NITF_DateType::create(type);
  }
  return *imageDeclassificationDate_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageDeclassificationDate() noexcept {
  imageDeclassificationDate_Accessor.reset();
  return *this;
}

uci::type::NITF_DeclassificationExemptionType& ImageSubheaderRevA_Type::getImageDeclassificationExemption_() const {
  if (imageDeclassificationExemption_Accessor) {
    return *imageDeclassificationExemption_Accessor;
  }
  throw uci::base::UCIException("Error in getImageDeclassificationExemption(): An attempt was made to get an optional field that was not enabled, call hasImageDeclassificationExemption() to determine if it is safe to call getImageDeclassificationExemption()");
}

const uci::type::NITF_DeclassificationExemptionType& ImageSubheaderRevA_Type::getImageDeclassificationExemption() const {
  return getImageDeclassificationExemption_();
}

uci::type::NITF_DeclassificationExemptionType& ImageSubheaderRevA_Type::getImageDeclassificationExemption() {
  return getImageDeclassificationExemption_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationExemption(const uci::type::NITF_DeclassificationExemptionType& value) {
  return setImageDeclassificationExemption(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationExemption(const std::string& value) {
  return setImageDeclassificationExemption(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDeclassificationExemption(const char* value) {
  enableImageDeclassificationExemption().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageDeclassificationExemption() const noexcept {
  return static_cast<bool>(imageDeclassificationExemption_Accessor);
}

uci::type::NITF_DeclassificationExemptionType& ImageSubheaderRevA_Type::enableImageDeclassificationExemption(uci::base::accessorType::AccessorType type) {
  if (!imageDeclassificationExemption_Accessor) {
    imageDeclassificationExemption_Accessor = NITF_DeclassificationExemptionType::create(type);
  }
  return *imageDeclassificationExemption_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageDeclassificationExemption() noexcept {
  imageDeclassificationExemption_Accessor.reset();
  return *this;
}

uci::type::NITF_DowngradeType& ImageSubheaderRevA_Type::getImageDowngrade_() const {
  if (imageDowngrade_Accessor) {
    return *imageDowngrade_Accessor;
  }
  throw uci::base::UCIException("Error in getImageDowngrade(): An attempt was made to get an optional field that was not enabled, call hasImageDowngrade() to determine if it is safe to call getImageDowngrade()");
}

const uci::type::NITF_DowngradeType& ImageSubheaderRevA_Type::getImageDowngrade() const {
  return getImageDowngrade_();
}

uci::type::NITF_DowngradeType& ImageSubheaderRevA_Type::getImageDowngrade() {
  return getImageDowngrade_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDowngrade(const uci::type::NITF_DowngradeType& value) {
  return setImageDowngrade(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDowngrade(const std::string& value) {
  return setImageDowngrade(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDowngrade(const char* value) {
  enableImageDowngrade().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageDowngrade() const noexcept {
  return static_cast<bool>(imageDowngrade_Accessor);
}

uci::type::NITF_DowngradeType& ImageSubheaderRevA_Type::enableImageDowngrade(uci::base::accessorType::AccessorType type) {
  if (!imageDowngrade_Accessor) {
    imageDowngrade_Accessor = NITF_DowngradeType::create(type);
  }
  return *imageDowngrade_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageDowngrade() noexcept {
  imageDowngrade_Accessor.reset();
  return *this;
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageDowngradeDate_() const {
  if (imageDowngradeDate_Accessor) {
    return *imageDowngradeDate_Accessor;
  }
  throw uci::base::UCIException("Error in getImageDowngradeDate(): An attempt was made to get an optional field that was not enabled, call hasImageDowngradeDate() to determine if it is safe to call getImageDowngradeDate()");
}

const uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageDowngradeDate() const {
  return getImageDowngradeDate_();
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageDowngradeDate() {
  return getImageDowngradeDate_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDowngradeDate(const uci::type::NITF_DateType& value) {
  return setImageDowngradeDate(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDowngradeDate(const std::string& value) {
  return setImageDowngradeDate(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageDowngradeDate(const char* value) {
  enableImageDowngradeDate().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageDowngradeDate() const noexcept {
  return static_cast<bool>(imageDowngradeDate_Accessor);
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::enableImageDowngradeDate(uci::base::accessorType::AccessorType type) {
  if (!imageDowngradeDate_Accessor) {
    imageDowngradeDate_Accessor = NITF_DateType::create(type);
  }
  return *imageDowngradeDate_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageDowngradeDate() noexcept {
  imageDowngradeDate_Accessor.reset();
  return *this;
}

uci::type::VisibleLatin1String43Type& ImageSubheaderRevA_Type::getImageClassificationText_() const {
  if (imageClassificationText_Accessor) {
    return *imageClassificationText_Accessor;
  }
  throw uci::base::UCIException("Error in getImageClassificationText(): An attempt was made to get an optional field that was not enabled, call hasImageClassificationText() to determine if it is safe to call getImageClassificationText()");
}

const uci::type::VisibleLatin1String43Type& ImageSubheaderRevA_Type::getImageClassificationText() const {
  return getImageClassificationText_();
}

uci::type::VisibleLatin1String43Type& ImageSubheaderRevA_Type::getImageClassificationText() {
  return getImageClassificationText_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationText(const uci::type::VisibleLatin1String43Type& value) {
  return setImageClassificationText(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationText(const std::string& value) {
  return setImageClassificationText(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationText(const char* value) {
  enableImageClassificationText().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageClassificationText() const noexcept {
  return static_cast<bool>(imageClassificationText_Accessor);
}

uci::type::VisibleLatin1String43Type& ImageSubheaderRevA_Type::enableImageClassificationText(uci::base::accessorType::AccessorType type) {
  if (!imageClassificationText_Accessor) {
    imageClassificationText_Accessor = VisibleLatin1String43Type::create(type);
  }
  return *imageClassificationText_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageClassificationText() noexcept {
  imageClassificationText_Accessor.reset();
  return *this;
}

uci::type::NITF_ClassificationAuthorityType& ImageSubheaderRevA_Type::getImageClassificationAuthorityType_() const {
  if (imageClassificationAuthorityType_Accessor) {
    return *imageClassificationAuthorityType_Accessor;
  }
  throw uci::base::UCIException("Error in getImageClassificationAuthorityType(): An attempt was made to get an optional field that was not enabled, call hasImageClassificationAuthorityType() to determine if it is safe to call getImageClassificationAuthorityType()");
}

const uci::type::NITF_ClassificationAuthorityType& ImageSubheaderRevA_Type::getImageClassificationAuthorityType() const {
  return getImageClassificationAuthorityType_();
}

uci::type::NITF_ClassificationAuthorityType& ImageSubheaderRevA_Type::getImageClassificationAuthorityType() {
  return getImageClassificationAuthorityType_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationAuthorityType(const uci::type::NITF_ClassificationAuthorityType& value) {
  return setImageClassificationAuthorityType(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationAuthorityType(const std::string& value) {
  return setImageClassificationAuthorityType(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationAuthorityType(const char* value) {
  enableImageClassificationAuthorityType().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageClassificationAuthorityType() const noexcept {
  return static_cast<bool>(imageClassificationAuthorityType_Accessor);
}

uci::type::NITF_ClassificationAuthorityType& ImageSubheaderRevA_Type::enableImageClassificationAuthorityType(uci::base::accessorType::AccessorType type) {
  if (!imageClassificationAuthorityType_Accessor) {
    imageClassificationAuthorityType_Accessor = NITF_ClassificationAuthorityType::create(type);
  }
  return *imageClassificationAuthorityType_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageClassificationAuthorityType() noexcept {
  imageClassificationAuthorityType_Accessor.reset();
  return *this;
}

uci::type::VisibleLatin1String40Type& ImageSubheaderRevA_Type::getImageClassificationAuthority_() const {
  if (imageClassificationAuthority_Accessor) {
    return *imageClassificationAuthority_Accessor;
  }
  throw uci::base::UCIException("Error in getImageClassificationAuthority(): An attempt was made to get an optional field that was not enabled, call hasImageClassificationAuthority() to determine if it is safe to call getImageClassificationAuthority()");
}

const uci::type::VisibleLatin1String40Type& ImageSubheaderRevA_Type::getImageClassificationAuthority() const {
  return getImageClassificationAuthority_();
}

uci::type::VisibleLatin1String40Type& ImageSubheaderRevA_Type::getImageClassificationAuthority() {
  return getImageClassificationAuthority_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationAuthority(const uci::type::VisibleLatin1String40Type& value) {
  return setImageClassificationAuthority(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationAuthority(const std::string& value) {
  return setImageClassificationAuthority(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationAuthority(const char* value) {
  enableImageClassificationAuthority().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageClassificationAuthority() const noexcept {
  return static_cast<bool>(imageClassificationAuthority_Accessor);
}

uci::type::VisibleLatin1String40Type& ImageSubheaderRevA_Type::enableImageClassificationAuthority(uci::base::accessorType::AccessorType type) {
  if (!imageClassificationAuthority_Accessor) {
    imageClassificationAuthority_Accessor = VisibleLatin1String40Type::create(type);
  }
  return *imageClassificationAuthority_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageClassificationAuthority() noexcept {
  imageClassificationAuthority_Accessor.reset();
  return *this;
}

uci::type::NITF_ClassificationReasonType& ImageSubheaderRevA_Type::getImageClassificationReason_() const {
  if (imageClassificationReason_Accessor) {
    return *imageClassificationReason_Accessor;
  }
  throw uci::base::UCIException("Error in getImageClassificationReason(): An attempt was made to get an optional field that was not enabled, call hasImageClassificationReason() to determine if it is safe to call getImageClassificationReason()");
}

const uci::type::NITF_ClassificationReasonType& ImageSubheaderRevA_Type::getImageClassificationReason() const {
  return getImageClassificationReason_();
}

uci::type::NITF_ClassificationReasonType& ImageSubheaderRevA_Type::getImageClassificationReason() {
  return getImageClassificationReason_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationReason(const uci::type::NITF_ClassificationReasonType& value) {
  return setImageClassificationReason(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationReason(const std::string& value) {
  return setImageClassificationReason(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageClassificationReason(const char* value) {
  enableImageClassificationReason().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageClassificationReason() const noexcept {
  return static_cast<bool>(imageClassificationReason_Accessor);
}

uci::type::NITF_ClassificationReasonType& ImageSubheaderRevA_Type::enableImageClassificationReason(uci::base::accessorType::AccessorType type) {
  if (!imageClassificationReason_Accessor) {
    imageClassificationReason_Accessor = NITF_ClassificationReasonType::create(type);
  }
  return *imageClassificationReason_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageClassificationReason() noexcept {
  imageClassificationReason_Accessor.reset();
  return *this;
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageSecuritySourceDate_() const {
  if (imageSecuritySourceDate_Accessor) {
    return *imageSecuritySourceDate_Accessor;
  }
  throw uci::base::UCIException("Error in getImageSecuritySourceDate(): An attempt was made to get an optional field that was not enabled, call hasImageSecuritySourceDate() to determine if it is safe to call getImageSecuritySourceDate()");
}

const uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageSecuritySourceDate() const {
  return getImageSecuritySourceDate_();
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::getImageSecuritySourceDate() {
  return getImageSecuritySourceDate_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecuritySourceDate(const uci::type::NITF_DateType& value) {
  return setImageSecuritySourceDate(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecuritySourceDate(const std::string& value) {
  return setImageSecuritySourceDate(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecuritySourceDate(const char* value) {
  enableImageSecuritySourceDate().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageSecuritySourceDate() const noexcept {
  return static_cast<bool>(imageSecuritySourceDate_Accessor);
}

uci::type::NITF_DateType& ImageSubheaderRevA_Type::enableImageSecuritySourceDate(uci::base::accessorType::AccessorType type) {
  if (!imageSecuritySourceDate_Accessor) {
    imageSecuritySourceDate_Accessor = NITF_DateType::create(type);
  }
  return *imageSecuritySourceDate_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageSecuritySourceDate() noexcept {
  imageSecuritySourceDate_Accessor.reset();
  return *this;
}

uci::type::VisibleLatin1String15Type& ImageSubheaderRevA_Type::getImageSecurityControlNumber_() const {
  if (imageSecurityControlNumber_Accessor) {
    return *imageSecurityControlNumber_Accessor;
  }
  throw uci::base::UCIException("Error in getImageSecurityControlNumber(): An attempt was made to get an optional field that was not enabled, call hasImageSecurityControlNumber() to determine if it is safe to call getImageSecurityControlNumber()");
}

const uci::type::VisibleLatin1String15Type& ImageSubheaderRevA_Type::getImageSecurityControlNumber() const {
  return getImageSecurityControlNumber_();
}

uci::type::VisibleLatin1String15Type& ImageSubheaderRevA_Type::getImageSecurityControlNumber() {
  return getImageSecurityControlNumber_();
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityControlNumber(const uci::type::VisibleLatin1String15Type& value) {
  return setImageSecurityControlNumber(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityControlNumber(const std::string& value) {
  return setImageSecurityControlNumber(value.c_str());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::setImageSecurityControlNumber(const char* value) {
  enableImageSecurityControlNumber().setStringValue(value);
  return *this;
}

bool ImageSubheaderRevA_Type::hasImageSecurityControlNumber() const noexcept {
  return static_cast<bool>(imageSecurityControlNumber_Accessor);
}

uci::type::VisibleLatin1String15Type& ImageSubheaderRevA_Type::enableImageSecurityControlNumber(uci::base::accessorType::AccessorType type) {
  if (!imageSecurityControlNumber_Accessor) {
    imageSecurityControlNumber_Accessor = VisibleLatin1String15Type::create(type);
  }
  return *imageSecurityControlNumber_Accessor;
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::clearImageSecurityControlNumber() noexcept {
  imageSecurityControlNumber_Accessor.reset();
  return *this;
}

std::unique_ptr<ImageSubheaderRevA_Type> ImageSubheaderRevA_Type::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::imageSubheaderRevA_Type : type};
  return (requestedType == uci::type::accessorType::imageSubheaderRevA_Type) ? boost::make_unique<ImageSubheaderRevA_Type>() : nullptr;
}

/**  */
namespace ImageSubheaderRevA_Type_Names {

constexpr const char* Extern_Type_Name{"ImageSubheaderRevA_Type"};
constexpr const char* TargetIdentifier_Name{"TargetIdentifier"};
constexpr const char* IID2_Name{"IID2"};
constexpr const char* ImageSecurityClassification_Name{"ImageSecurityClassification"};
constexpr const char* ImageSecurityClassificationSystem_Name{"ImageSecurityClassificationSystem"};
constexpr const char* ImageCodewords_Name{"ImageCodewords"};
constexpr const char* ImageControlAndHandling_Name{"ImageControlAndHandling"};
constexpr const char* ImageReleasingInstructions_Name{"ImageReleasingInstructions"};
constexpr const char* ImageDeclassificationType_Name{"ImageDeclassificationType"};
constexpr const char* ImageDeclassificationDate_Name{"ImageDeclassificationDate"};
constexpr const char* ImageDeclassificationExemption_Name{"ImageDeclassificationExemption"};
constexpr const char* ImageDowngrade_Name{"ImageDowngrade"};
constexpr const char* ImageDowngradeDate_Name{"ImageDowngradeDate"};
constexpr const char* ImageClassificationText_Name{"ImageClassificationText"};
constexpr const char* ImageClassificationAuthorityType_Name{"ImageClassificationAuthorityType"};
constexpr const char* ImageClassificationAuthority_Name{"ImageClassificationAuthority"};
constexpr const char* ImageClassificationReason_Name{"ImageClassificationReason"};
constexpr const char* ImageSecuritySourceDate_Name{"ImageSecuritySourceDate"};
constexpr const char* ImageSecurityControlNumber_Name{"ImageSecurityControlNumber"};

} // namespace ImageSubheaderRevA_Type_Names

void ImageSubheaderRevA_Type::deserialize(const boost::property_tree::ptree& propTree, uci::type::ImageSubheaderRevA_Type& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = ImageSubheaderRevA_Type_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::TargetIdentifier_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setTargetIdentifier(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::IID2_Name) {
      IID2_ChoiceType::deserialize(valueType.second, accessor.enableIID2(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageSecurityClassification_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageSecurityClassification(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageSecurityClassificationSystem_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageSecurityClassificationSystem(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageCodewords_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageCodewords(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageControlAndHandling_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageControlAndHandling(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageReleasingInstructions_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageReleasingInstructions(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageDeclassificationType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageDeclassificationType(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageDeclassificationDate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageDeclassificationDate(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageDeclassificationExemption_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageDeclassificationExemption(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageDowngrade_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageDowngrade(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageDowngradeDate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageDowngradeDate(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageClassificationText_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageClassificationText(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageClassificationAuthorityType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageClassificationAuthorityType(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageClassificationAuthority_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageClassificationAuthority(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageClassificationReason_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageClassificationReason(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageSecuritySourceDate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageSecuritySourceDate(*value);
      }
    } else if (valueType.first == nsPrefix + ImageSubheaderRevA_Type_Names::ImageSecurityControlNumber_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageSecurityControlNumber(*value);
      }
    }
  }
}

std::string ImageSubheaderRevA_Type::serialize(const uci::type::ImageSubheaderRevA_Type& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? ImageSubheaderRevA_Type_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, ImageSubheaderRevA_Type_Names::Extern_Type_Name);
  }
  if (accessor.hasTargetIdentifier()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getTargetIdentifier(), node, ImageSubheaderRevA_Type_Names::TargetIdentifier_Name);
  }
  if (accessor.hasIID2()) {
    IID2_ChoiceType::serialize(accessor.getIID2(), node, ImageSubheaderRevA_Type_Names::IID2_Name);
  }
  asb_uci::util::SerializationHelpers::serializeString(accessor.getImageSecurityClassification(), node, ImageSubheaderRevA_Type_Names::ImageSecurityClassification_Name);
  if (accessor.hasImageSecurityClassificationSystem()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageSecurityClassificationSystem(), node, ImageSubheaderRevA_Type_Names::ImageSecurityClassificationSystem_Name);
  }
  if (accessor.hasImageCodewords()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageCodewords(), node, ImageSubheaderRevA_Type_Names::ImageCodewords_Name);
  }
  if (accessor.hasImageControlAndHandling()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageControlAndHandling(), node, ImageSubheaderRevA_Type_Names::ImageControlAndHandling_Name);
  }
  if (accessor.hasImageReleasingInstructions()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageReleasingInstructions(), node, ImageSubheaderRevA_Type_Names::ImageReleasingInstructions_Name);
  }
  if (accessor.hasImageDeclassificationType()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageDeclassificationType(), node, ImageSubheaderRevA_Type_Names::ImageDeclassificationType_Name);
  }
  if (accessor.hasImageDeclassificationDate()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageDeclassificationDate(), node, ImageSubheaderRevA_Type_Names::ImageDeclassificationDate_Name);
  }
  if (accessor.hasImageDeclassificationExemption()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageDeclassificationExemption(), node, ImageSubheaderRevA_Type_Names::ImageDeclassificationExemption_Name);
  }
  if (accessor.hasImageDowngrade()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageDowngrade(), node, ImageSubheaderRevA_Type_Names::ImageDowngrade_Name);
  }
  if (accessor.hasImageDowngradeDate()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageDowngradeDate(), node, ImageSubheaderRevA_Type_Names::ImageDowngradeDate_Name);
  }
  if (accessor.hasImageClassificationText()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageClassificationText(), node, ImageSubheaderRevA_Type_Names::ImageClassificationText_Name);
  }
  if (accessor.hasImageClassificationAuthorityType()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageClassificationAuthorityType(), node, ImageSubheaderRevA_Type_Names::ImageClassificationAuthorityType_Name);
  }
  if (accessor.hasImageClassificationAuthority()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageClassificationAuthority(), node, ImageSubheaderRevA_Type_Names::ImageClassificationAuthority_Name);
  }
  if (accessor.hasImageClassificationReason()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageClassificationReason(), node, ImageSubheaderRevA_Type_Names::ImageClassificationReason_Name);
  }
  if (accessor.hasImageSecuritySourceDate()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageSecuritySourceDate(), node, ImageSubheaderRevA_Type_Names::ImageSecuritySourceDate_Name);
  }
  if (accessor.hasImageSecurityControlNumber()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getImageSecurityControlNumber(), node, ImageSubheaderRevA_Type_Names::ImageSecurityControlNumber_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::ImageSubheaderRevA_Type>().release());
}

uci::type::ImageSubheaderRevA_Type& ImageSubheaderRevA_Type::create(const uci::type::ImageSubheaderRevA_Type& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::ImageSubheaderRevA_Type> newAccessor{boost::make_unique<asb_uci::type::ImageSubheaderRevA_Type>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void ImageSubheaderRevA_Type::destroy(uci::type::ImageSubheaderRevA_Type& accessor) {
  delete dynamic_cast<asb_uci::type::ImageSubheaderRevA_Type*>(&accessor);
}

} // namespace type

} // namespace uci

