/** @file RequirementConstraintsType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:14 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/RequirementConstraintsType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/AnalyticConstraintsType.h"
#include "asb_uci/type/ComparableRankingType.h"
#include "asb_uci/type/DataProductClassificationLevelType.h"
#include "asb_uci/type/EnvironmentPairingEnum.h"
#include "asb_uci/type/RequirementAllocationParametersType.h"
#include "asb_uci/type/RequirementDependencyType.h"
#include "asb_uci/type/RequirementKinematicConstraintsType.h"
#include "asb_uci/type/RequirementTaxonomyType.h"
#include "asb_uci/type/RequirementTimingType.h"
#include "asb_uci/type/SecurityInformationType.h"
#include "asb_uci/type/VisibleString1024Type.h"
#include "asb_uci/util/DerivedTypesDeserializer.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/AnalyticConstraintsType.h"
#include "uci/type/ComparableRankingType.h"
#include "uci/type/DataProductClassificationLevelType.h"
#include "uci/type/EnvironmentPairingEnum.h"
#include "uci/type/RequirementAllocationParametersType.h"
#include "uci/type/RequirementConstraintsType.h"
#include "uci/type/RequirementDependencyType.h"
#include "uci/type/RequirementKinematicConstraintsType.h"
#include "uci/type/RequirementTaxonomyType.h"
#include "uci/type/RequirementTimingType.h"
#include "uci/type/SecurityInformationType.h"
#include "uci/type/VisibleString1024Type.h"
#include "xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

RequirementConstraintsType::RequirementConstraintsType()
  : timing_Accessor{boost::make_unique<Timing>(0, 4)},
    kinematic_Accessor{boost::make_unique<Kinematic>(0, 4)},
    dependency_Accessor{boost::make_unique<Dependency>(0, SIZE_MAX)},
    allowedDomainPairing_Accessor{boost::make_unique<AllowedDomainPairing>(0, 48)},
    excludedDomainPairing_Accessor{boost::make_unique<ExcludedDomainPairing>(0, 48)} {
}

RequirementConstraintsType::~RequirementConstraintsType() = default;

void RequirementConstraintsType::copy(const uci::type::RequirementConstraintsType& accessor) {
  copyImpl(accessor, false);
}

void RequirementConstraintsType::copyImpl(const uci::type::RequirementConstraintsType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const RequirementConstraintsType&>(accessor);
    if (accessorImpl.rank_Accessor) {
      setRank(*(accessorImpl.rank_Accessor));
    } else {
      rank_Accessor.reset();
    }
    if (accessorImpl.hasInterruptLowerRank()) {
      setInterruptLowerRank(accessorImpl.getInterruptLowerRank());
    } else {
      clearInterruptLowerRank();
    }
    if (accessorImpl.allocation_Accessor) {
      setAllocation(*(accessorImpl.allocation_Accessor));
    } else {
      allocation_Accessor.reset();
    }
    setTiming(*(accessorImpl.timing_Accessor));
    setKinematic(*(accessorImpl.kinematic_Accessor));
    setDependency(*(accessorImpl.dependency_Accessor));
    if (accessorImpl.maxProductDisseminationClassificationLevel_Accessor) {
      setMaxProductDisseminationClassificationLevel(*(accessorImpl.maxProductDisseminationClassificationLevel_Accessor));
    } else {
      maxProductDisseminationClassificationLevel_Accessor.reset();
    }
    if (accessorImpl.analytic_Accessor) {
      setAnalytic(*(accessorImpl.analytic_Accessor));
    } else {
      analytic_Accessor.reset();
    }
    if (accessorImpl.acceptableClassificationLevel_Accessor) {
      setAcceptableClassificationLevel(*(accessorImpl.acceptableClassificationLevel_Accessor));
    } else {
      acceptableClassificationLevel_Accessor.reset();
    }
    if (accessorImpl.hasCommsRequired()) {
      setCommsRequired(accessorImpl.getCommsRequired());
    } else {
      clearCommsRequired();
    }
    if (accessorImpl.allowedRequirementTypes_Accessor) {
      setAllowedRequirementTypes(*(accessorImpl.allowedRequirementTypes_Accessor));
    } else {
      allowedRequirementTypes_Accessor.reset();
    }
    if (accessorImpl.excludedRequirementTypes_Accessor) {
      setExcludedRequirementTypes(*(accessorImpl.excludedRequirementTypes_Accessor));
    } else {
      excludedRequirementTypes_Accessor.reset();
    }
    if (accessorImpl.constraintsNarrative_Accessor) {
      setConstraintsNarrative(*(accessorImpl.constraintsNarrative_Accessor));
    } else {
      constraintsNarrative_Accessor.reset();
    }
    setAllowedDomainPairing(*(accessorImpl.allowedDomainPairing_Accessor));
    setExcludedDomainPairing(*(accessorImpl.excludedDomainPairing_Accessor));
  }
}

void RequirementConstraintsType::reset() noexcept {
  rank_Accessor.reset();
  clearInterruptLowerRank();
  allocation_Accessor.reset();
  timing_Accessor->reset();
  kinematic_Accessor->reset();
  dependency_Accessor->reset();
  maxProductDisseminationClassificationLevel_Accessor.reset();
  analytic_Accessor.reset();
  acceptableClassificationLevel_Accessor.reset();
  clearCommsRequired();
  allowedRequirementTypes_Accessor.reset();
  excludedRequirementTypes_Accessor.reset();
  constraintsNarrative_Accessor.reset();
  allowedDomainPairing_Accessor->reset();
  excludedDomainPairing_Accessor->reset();
}

uci::type::ComparableRankingType& RequirementConstraintsType::getRank_() const {
  if (rank_Accessor) {
    return *rank_Accessor;
  }
  throw uci::base::UCIException("Error in getRank(): An attempt was made to get an optional field that was not enabled, call hasRank() to determine if it is safe to call getRank()");
}

const uci::type::ComparableRankingType& RequirementConstraintsType::getRank() const {
  return getRank_();
}

uci::type::ComparableRankingType& RequirementConstraintsType::getRank() {
  return getRank_();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setRank(const uci::type::ComparableRankingType& accessor) {
  enableRank();
  if (&accessor != rank_Accessor.get()) {
    rank_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool RequirementConstraintsType::hasRank() const noexcept {
  return static_cast<bool>(rank_Accessor);
}

uci::type::ComparableRankingType& RequirementConstraintsType::enableRank(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::comparableRankingType : type};
  if ((!rank_Accessor) || (rank_Accessor->getAccessorType() != requestedType)) {
    rank_Accessor = ComparableRankingType::create(requestedType);
    if (!rank_Accessor) {
      throw uci::base::UCIException("Error in enableRank(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *rank_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearRank() noexcept {
  rank_Accessor.reset();
  return *this;
}

xs::Boolean RequirementConstraintsType::getInterruptLowerRank() const {
  if (interruptLowerRank_Accessor) {
    return *interruptLowerRank_Accessor;
  }
  throw uci::base::UCIException("Error in getInterruptLowerRank(): An attempt was made to get an optional field that was not enabled, call hasInterruptLowerRank() to determine if it is safe to call getInterruptLowerRank()");
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setInterruptLowerRank(xs::Boolean value) {
  interruptLowerRank_Accessor = value;
  return *this;
}

bool RequirementConstraintsType::hasInterruptLowerRank() const noexcept {
  return interruptLowerRank_Accessor.has_value();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearInterruptLowerRank() noexcept {
  interruptLowerRank_Accessor.reset();
  return *this;
}

uci::type::RequirementAllocationParametersType& RequirementConstraintsType::getAllocation_() const {
  if (allocation_Accessor) {
    return *allocation_Accessor;
  }
  throw uci::base::UCIException("Error in getAllocation(): An attempt was made to get an optional field that was not enabled, call hasAllocation() to determine if it is safe to call getAllocation()");
}

const uci::type::RequirementAllocationParametersType& RequirementConstraintsType::getAllocation() const {
  return getAllocation_();
}

uci::type::RequirementAllocationParametersType& RequirementConstraintsType::getAllocation() {
  return getAllocation_();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setAllocation(const uci::type::RequirementAllocationParametersType& accessor) {
  enableAllocation();
  if (&accessor != allocation_Accessor.get()) {
    allocation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool RequirementConstraintsType::hasAllocation() const noexcept {
  return static_cast<bool>(allocation_Accessor);
}

uci::type::RequirementAllocationParametersType& RequirementConstraintsType::enableAllocation(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementAllocationParametersType : type};
  if ((!allocation_Accessor) || (allocation_Accessor->getAccessorType() != requestedType)) {
    allocation_Accessor = RequirementAllocationParametersType::create(requestedType);
    if (!allocation_Accessor) {
      throw uci::base::UCIException("Error in enableAllocation(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *allocation_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearAllocation() noexcept {
  allocation_Accessor.reset();
  return *this;
}

const uci::type::RequirementConstraintsType::Timing& RequirementConstraintsType::getTiming() const {
  return *timing_Accessor;
}

uci::type::RequirementConstraintsType::Timing& RequirementConstraintsType::getTiming() {
  return *timing_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setTiming(const uci::type::RequirementConstraintsType::Timing& accessor) {
  if (&accessor != timing_Accessor.get()) {
    timing_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::RequirementConstraintsType::Kinematic& RequirementConstraintsType::getKinematic() const {
  return *kinematic_Accessor;
}

uci::type::RequirementConstraintsType::Kinematic& RequirementConstraintsType::getKinematic() {
  return *kinematic_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setKinematic(const uci::type::RequirementConstraintsType::Kinematic& accessor) {
  if (&accessor != kinematic_Accessor.get()) {
    kinematic_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::RequirementConstraintsType::Dependency& RequirementConstraintsType::getDependency() const {
  return *dependency_Accessor;
}

uci::type::RequirementConstraintsType::Dependency& RequirementConstraintsType::getDependency() {
  return *dependency_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setDependency(const uci::type::RequirementConstraintsType::Dependency& accessor) {
  if (&accessor != dependency_Accessor.get()) {
    dependency_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::DataProductClassificationLevelType& RequirementConstraintsType::getMaxProductDisseminationClassificationLevel_() const {
  if (maxProductDisseminationClassificationLevel_Accessor) {
    return *maxProductDisseminationClassificationLevel_Accessor;
  }
  throw uci::base::UCIException("Error in getMaxProductDisseminationClassificationLevel(): An attempt was made to get an optional field that was not enabled, call hasMaxProductDisseminationClassificationLevel() to determine if it is safe to call getMaxProductDisseminationClassificationLevel()");
}

const uci::type::DataProductClassificationLevelType& RequirementConstraintsType::getMaxProductDisseminationClassificationLevel() const {
  return getMaxProductDisseminationClassificationLevel_();
}

uci::type::DataProductClassificationLevelType& RequirementConstraintsType::getMaxProductDisseminationClassificationLevel() {
  return getMaxProductDisseminationClassificationLevel_();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setMaxProductDisseminationClassificationLevel(const uci::type::DataProductClassificationLevelType& accessor) {
  enableMaxProductDisseminationClassificationLevel();
  if (&accessor != maxProductDisseminationClassificationLevel_Accessor.get()) {
    maxProductDisseminationClassificationLevel_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool RequirementConstraintsType::hasMaxProductDisseminationClassificationLevel() const noexcept {
  return static_cast<bool>(maxProductDisseminationClassificationLevel_Accessor);
}

uci::type::DataProductClassificationLevelType& RequirementConstraintsType::enableMaxProductDisseminationClassificationLevel(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::dataProductClassificationLevelType : type};
  if ((!maxProductDisseminationClassificationLevel_Accessor) || (maxProductDisseminationClassificationLevel_Accessor->getAccessorType() != requestedType)) {
    maxProductDisseminationClassificationLevel_Accessor = DataProductClassificationLevelType::create(requestedType);
    if (!maxProductDisseminationClassificationLevel_Accessor) {
      throw uci::base::UCIException("Error in enableMaxProductDisseminationClassificationLevel(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *maxProductDisseminationClassificationLevel_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearMaxProductDisseminationClassificationLevel() noexcept {
  maxProductDisseminationClassificationLevel_Accessor.reset();
  return *this;
}

uci::type::AnalyticConstraintsType& RequirementConstraintsType::getAnalytic_() const {
  if (analytic_Accessor) {
    return *analytic_Accessor;
  }
  throw uci::base::UCIException("Error in getAnalytic(): An attempt was made to get an optional field that was not enabled, call hasAnalytic() to determine if it is safe to call getAnalytic()");
}

const uci::type::AnalyticConstraintsType& RequirementConstraintsType::getAnalytic() const {
  return getAnalytic_();
}

uci::type::AnalyticConstraintsType& RequirementConstraintsType::getAnalytic() {
  return getAnalytic_();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setAnalytic(const uci::type::AnalyticConstraintsType& accessor) {
  enableAnalytic();
  if (&accessor != analytic_Accessor.get()) {
    analytic_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool RequirementConstraintsType::hasAnalytic() const noexcept {
  return static_cast<bool>(analytic_Accessor);
}

uci::type::AnalyticConstraintsType& RequirementConstraintsType::enableAnalytic(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::analyticConstraintsType : type};
  if ((!analytic_Accessor) || (analytic_Accessor->getAccessorType() != requestedType)) {
    analytic_Accessor = AnalyticConstraintsType::create(requestedType);
    if (!analytic_Accessor) {
      throw uci::base::UCIException("Error in enableAnalytic(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *analytic_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearAnalytic() noexcept {
  analytic_Accessor.reset();
  return *this;
}

uci::type::SecurityInformationType& RequirementConstraintsType::getAcceptableClassificationLevel_() const {
  if (acceptableClassificationLevel_Accessor) {
    return *acceptableClassificationLevel_Accessor;
  }
  throw uci::base::UCIException("Error in getAcceptableClassificationLevel(): An attempt was made to get an optional field that was not enabled, call hasAcceptableClassificationLevel() to determine if it is safe to call getAcceptableClassificationLevel()");
}

const uci::type::SecurityInformationType& RequirementConstraintsType::getAcceptableClassificationLevel() const {
  return getAcceptableClassificationLevel_();
}

uci::type::SecurityInformationType& RequirementConstraintsType::getAcceptableClassificationLevel() {
  return getAcceptableClassificationLevel_();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setAcceptableClassificationLevel(const uci::type::SecurityInformationType& accessor) {
  enableAcceptableClassificationLevel();
  if (&accessor != acceptableClassificationLevel_Accessor.get()) {
    acceptableClassificationLevel_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool RequirementConstraintsType::hasAcceptableClassificationLevel() const noexcept {
  return static_cast<bool>(acceptableClassificationLevel_Accessor);
}

uci::type::SecurityInformationType& RequirementConstraintsType::enableAcceptableClassificationLevel(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityInformationType : type};
  if ((!acceptableClassificationLevel_Accessor) || (acceptableClassificationLevel_Accessor->getAccessorType() != requestedType)) {
    acceptableClassificationLevel_Accessor = SecurityInformationType::create(requestedType);
    if (!acceptableClassificationLevel_Accessor) {
      throw uci::base::UCIException("Error in enableAcceptableClassificationLevel(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *acceptableClassificationLevel_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearAcceptableClassificationLevel() noexcept {
  acceptableClassificationLevel_Accessor.reset();
  return *this;
}

xs::Boolean RequirementConstraintsType::getCommsRequired() const {
  if (commsRequired_Accessor) {
    return *commsRequired_Accessor;
  }
  throw uci::base::UCIException("Error in getCommsRequired(): An attempt was made to get an optional field that was not enabled, call hasCommsRequired() to determine if it is safe to call getCommsRequired()");
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setCommsRequired(xs::Boolean value) {
  commsRequired_Accessor = value;
  return *this;
}

bool RequirementConstraintsType::hasCommsRequired() const noexcept {
  return commsRequired_Accessor.has_value();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearCommsRequired() noexcept {
  commsRequired_Accessor.reset();
  return *this;
}

uci::type::RequirementTaxonomyType& RequirementConstraintsType::getAllowedRequirementTypes_() const {
  if (allowedRequirementTypes_Accessor) {
    return *allowedRequirementTypes_Accessor;
  }
  throw uci::base::UCIException("Error in getAllowedRequirementTypes(): An attempt was made to get an optional field that was not enabled, call hasAllowedRequirementTypes() to determine if it is safe to call getAllowedRequirementTypes()");
}

const uci::type::RequirementTaxonomyType& RequirementConstraintsType::getAllowedRequirementTypes() const {
  return getAllowedRequirementTypes_();
}

uci::type::RequirementTaxonomyType& RequirementConstraintsType::getAllowedRequirementTypes() {
  return getAllowedRequirementTypes_();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setAllowedRequirementTypes(const uci::type::RequirementTaxonomyType& accessor) {
  enableAllowedRequirementTypes(accessor.getAccessorType());
  if (&accessor != allowedRequirementTypes_Accessor.get()) {
    allowedRequirementTypes_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool RequirementConstraintsType::hasAllowedRequirementTypes() const noexcept {
  return static_cast<bool>(allowedRequirementTypes_Accessor);
}

uci::type::RequirementTaxonomyType& RequirementConstraintsType::enableAllowedRequirementTypes(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementTaxonomyType : type};
  if ((!allowedRequirementTypes_Accessor) || (allowedRequirementTypes_Accessor->getAccessorType() != requestedType)) {
    allowedRequirementTypes_Accessor = RequirementTaxonomyType::create(requestedType);
    if (!allowedRequirementTypes_Accessor) {
      throw uci::base::UCIException("Error in enableAllowedRequirementTypes(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *allowedRequirementTypes_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearAllowedRequirementTypes() noexcept {
  allowedRequirementTypes_Accessor.reset();
  return *this;
}

uci::type::RequirementTaxonomyType& RequirementConstraintsType::getExcludedRequirementTypes_() const {
  if (excludedRequirementTypes_Accessor) {
    return *excludedRequirementTypes_Accessor;
  }
  throw uci::base::UCIException("Error in getExcludedRequirementTypes(): An attempt was made to get an optional field that was not enabled, call hasExcludedRequirementTypes() to determine if it is safe to call getExcludedRequirementTypes()");
}

const uci::type::RequirementTaxonomyType& RequirementConstraintsType::getExcludedRequirementTypes() const {
  return getExcludedRequirementTypes_();
}

uci::type::RequirementTaxonomyType& RequirementConstraintsType::getExcludedRequirementTypes() {
  return getExcludedRequirementTypes_();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setExcludedRequirementTypes(const uci::type::RequirementTaxonomyType& accessor) {
  enableExcludedRequirementTypes(accessor.getAccessorType());
  if (&accessor != excludedRequirementTypes_Accessor.get()) {
    excludedRequirementTypes_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool RequirementConstraintsType::hasExcludedRequirementTypes() const noexcept {
  return static_cast<bool>(excludedRequirementTypes_Accessor);
}

uci::type::RequirementTaxonomyType& RequirementConstraintsType::enableExcludedRequirementTypes(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementTaxonomyType : type};
  if ((!excludedRequirementTypes_Accessor) || (excludedRequirementTypes_Accessor->getAccessorType() != requestedType)) {
    excludedRequirementTypes_Accessor = RequirementTaxonomyType::create(requestedType);
    if (!excludedRequirementTypes_Accessor) {
      throw uci::base::UCIException("Error in enableExcludedRequirementTypes(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *excludedRequirementTypes_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearExcludedRequirementTypes() noexcept {
  excludedRequirementTypes_Accessor.reset();
  return *this;
}

uci::type::VisibleString1024Type& RequirementConstraintsType::getConstraintsNarrative_() const {
  if (constraintsNarrative_Accessor) {
    return *constraintsNarrative_Accessor;
  }
  throw uci::base::UCIException("Error in getConstraintsNarrative(): An attempt was made to get an optional field that was not enabled, call hasConstraintsNarrative() to determine if it is safe to call getConstraintsNarrative()");
}

const uci::type::VisibleString1024Type& RequirementConstraintsType::getConstraintsNarrative() const {
  return getConstraintsNarrative_();
}

uci::type::VisibleString1024Type& RequirementConstraintsType::getConstraintsNarrative() {
  return getConstraintsNarrative_();
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setConstraintsNarrative(const uci::type::VisibleString1024Type& value) {
  return setConstraintsNarrative(value.c_str());
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setConstraintsNarrative(const std::string& value) {
  return setConstraintsNarrative(value.c_str());
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setConstraintsNarrative(const char* value) {
  enableConstraintsNarrative().setStringValue(value);
  return *this;
}

bool RequirementConstraintsType::hasConstraintsNarrative() const noexcept {
  return static_cast<bool>(constraintsNarrative_Accessor);
}

uci::type::VisibleString1024Type& RequirementConstraintsType::enableConstraintsNarrative(uci::base::accessorType::AccessorType type) {
  if (!constraintsNarrative_Accessor) {
    constraintsNarrative_Accessor = VisibleString1024Type::create(type);
  }
  return *constraintsNarrative_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::clearConstraintsNarrative() noexcept {
  constraintsNarrative_Accessor.reset();
  return *this;
}

const uci::type::RequirementConstraintsType::AllowedDomainPairing& RequirementConstraintsType::getAllowedDomainPairing() const {
  return *allowedDomainPairing_Accessor;
}

uci::type::RequirementConstraintsType::AllowedDomainPairing& RequirementConstraintsType::getAllowedDomainPairing() {
  return *allowedDomainPairing_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setAllowedDomainPairing(const uci::type::RequirementConstraintsType::AllowedDomainPairing& accessor) {
  if (&accessor != allowedDomainPairing_Accessor.get()) {
    allowedDomainPairing_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::RequirementConstraintsType::ExcludedDomainPairing& RequirementConstraintsType::getExcludedDomainPairing() const {
  return *excludedDomainPairing_Accessor;
}

uci::type::RequirementConstraintsType::ExcludedDomainPairing& RequirementConstraintsType::getExcludedDomainPairing() {
  return *excludedDomainPairing_Accessor;
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::setExcludedDomainPairing(const uci::type::RequirementConstraintsType::ExcludedDomainPairing& accessor) {
  if (&accessor != excludedDomainPairing_Accessor.get()) {
    excludedDomainPairing_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

std::unique_ptr<RequirementConstraintsType> RequirementConstraintsType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementConstraintsType : type};
  return (requestedType == uci::type::accessorType::requirementConstraintsType) ? boost::make_unique<RequirementConstraintsType>() : nullptr;
}

/**  */
namespace RequirementConstraintsType_Names {

constexpr const char* Extern_Type_Name{"RequirementConstraintsType"};
constexpr const char* Rank_Name{"Rank"};
constexpr const char* InterruptLowerRank_Name{"InterruptLowerRank"};
constexpr const char* Allocation_Name{"Allocation"};
constexpr const char* Timing_Name{"Timing"};
constexpr const char* Kinematic_Name{"Kinematic"};
constexpr const char* Dependency_Name{"Dependency"};
constexpr const char* MaxProductDisseminationClassificationLevel_Name{"MaxProductDisseminationClassificationLevel"};
constexpr const char* Analytic_Name{"Analytic"};
constexpr const char* AcceptableClassificationLevel_Name{"AcceptableClassificationLevel"};
constexpr const char* CommsRequired_Name{"CommsRequired"};
constexpr const char* AllowedRequirementTypes_Name{"AllowedRequirementTypes"};
constexpr const char* ExcludedRequirementTypes_Name{"ExcludedRequirementTypes"};
constexpr const char* ConstraintsNarrative_Name{"ConstraintsNarrative"};
constexpr const char* AllowedDomainPairing_Name{"AllowedDomainPairing"};
constexpr const char* ExcludedDomainPairing_Name{"ExcludedDomainPairing"};

} // namespace RequirementConstraintsType_Names

void RequirementConstraintsType::deserialize(const boost::property_tree::ptree& propTree, uci::type::RequirementConstraintsType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = RequirementConstraintsType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::Rank_Name) {
      ComparableRankingType::deserialize(valueType.second, accessor.enableRank(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::InterruptLowerRank_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setInterruptLowerRank(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::Allocation_Name) {
      RequirementAllocationParametersType::deserialize(valueType.second, accessor.enableAllocation(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::Timing_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::RequirementConstraintsType::Timing& boundedList = accessor.getTiming();
        const uci::type::RequirementConstraintsType::Timing::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::RequirementTimingType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::Kinematic_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::RequirementConstraintsType::Kinematic& boundedList = accessor.getKinematic();
        const uci::type::RequirementConstraintsType::Kinematic::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::RequirementKinematicConstraintsType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::Dependency_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::RequirementConstraintsType::Dependency& boundedList = accessor.getDependency();
        const uci::type::RequirementConstraintsType::Dependency::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::RequirementDependencyType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::MaxProductDisseminationClassificationLevel_Name) {
      DataProductClassificationLevelType::deserialize(valueType.second, accessor.enableMaxProductDisseminationClassificationLevel(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::Analytic_Name) {
      AnalyticConstraintsType::deserialize(valueType.second, accessor.enableAnalytic(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::AcceptableClassificationLevel_Name) {
      SecurityInformationType::deserialize(valueType.second, accessor.enableAcceptableClassificationLevel(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::CommsRequired_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setCommsRequired(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::AllowedRequirementTypes_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableAllowedRequirementTypes(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::ExcludedRequirementTypes_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableExcludedRequirementTypes(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::ConstraintsNarrative_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setConstraintsNarrative(*value);
      }
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::AllowedDomainPairing_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::RequirementConstraintsType::AllowedDomainPairing& boundedList = accessor.getAllowedDomainPairing();
        const uci::type::RequirementConstraintsType::AllowedDomainPairing::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + RequirementConstraintsType_Names::ExcludedDomainPairing_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::RequirementConstraintsType::ExcludedDomainPairing& boundedList = accessor.getExcludedDomainPairing();
        const uci::type::RequirementConstraintsType::ExcludedDomainPairing::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setValueFromName(*value);
      }
    }
  }
}

std::string RequirementConstraintsType::serialize(const uci::type::RequirementConstraintsType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? RequirementConstraintsType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, RequirementConstraintsType_Names::Extern_Type_Name);
  }
  if (accessor.hasRank()) {
    ComparableRankingType::serialize(accessor.getRank(), node, RequirementConstraintsType_Names::Rank_Name);
  }
  if (accessor.hasInterruptLowerRank()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getInterruptLowerRank(), node, RequirementConstraintsType_Names::InterruptLowerRank_Name);
  }
  if (accessor.hasAllocation()) {
    RequirementAllocationParametersType::serialize(accessor.getAllocation(), node, RequirementConstraintsType_Names::Allocation_Name);
  }
  {
    const uci::type::RequirementConstraintsType::Timing& boundedList = accessor.getTiming();
    for (uci::type::RequirementConstraintsType::Timing::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::RequirementTimingType::serialize(boundedList.at(i), node, RequirementConstraintsType_Names::Timing_Name);
    }
  }
  {
    const uci::type::RequirementConstraintsType::Kinematic& boundedList = accessor.getKinematic();
    for (uci::type::RequirementConstraintsType::Kinematic::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::RequirementKinematicConstraintsType::serialize(boundedList.at(i), node, RequirementConstraintsType_Names::Kinematic_Name);
    }
  }
  {
    const uci::type::RequirementConstraintsType::Dependency& boundedList = accessor.getDependency();
    for (uci::type::RequirementConstraintsType::Dependency::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::RequirementDependencyType::serialize(boundedList.at(i), node, RequirementConstraintsType_Names::Dependency_Name);
    }
  }
  if (accessor.hasMaxProductDisseminationClassificationLevel()) {
    DataProductClassificationLevelType::serialize(accessor.getMaxProductDisseminationClassificationLevel(), node, RequirementConstraintsType_Names::MaxProductDisseminationClassificationLevel_Name);
  }
  if (accessor.hasAnalytic()) {
    AnalyticConstraintsType::serialize(accessor.getAnalytic(), node, RequirementConstraintsType_Names::Analytic_Name);
  }
  if (accessor.hasAcceptableClassificationLevel()) {
    SecurityInformationType::serialize(accessor.getAcceptableClassificationLevel(), node, RequirementConstraintsType_Names::AcceptableClassificationLevel_Name);
  }
  if (accessor.hasCommsRequired()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getCommsRequired(), node, RequirementConstraintsType_Names::CommsRequired_Name);
  }
  if (accessor.hasAllowedRequirementTypes()) {
    RequirementTaxonomyType::serialize(accessor.getAllowedRequirementTypes(), node, RequirementConstraintsType_Names::AllowedRequirementTypes_Name);
  }
  if (accessor.hasExcludedRequirementTypes()) {
    RequirementTaxonomyType::serialize(accessor.getExcludedRequirementTypes(), node, RequirementConstraintsType_Names::ExcludedRequirementTypes_Name);
  }
  if (accessor.hasConstraintsNarrative()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getConstraintsNarrative(), node, RequirementConstraintsType_Names::ConstraintsNarrative_Name);
  }
  {
    const uci::type::RequirementConstraintsType::AllowedDomainPairing& boundedList = accessor.getAllowedDomainPairing();
    for (uci::type::RequirementConstraintsType::AllowedDomainPairing::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      EnvironmentPairingEnum::serialize(boundedList.at(i), node, RequirementConstraintsType_Names::AllowedDomainPairing_Name, false);
    }
  }
  {
    const uci::type::RequirementConstraintsType::ExcludedDomainPairing& boundedList = accessor.getExcludedDomainPairing();
    for (uci::type::RequirementConstraintsType::ExcludedDomainPairing::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      EnvironmentPairingEnum::serialize(boundedList.at(i), node, RequirementConstraintsType_Names::ExcludedDomainPairing_Name, false);
    }
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::RequirementConstraintsType& RequirementConstraintsType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::RequirementConstraintsType>().release());
}

uci::type::RequirementConstraintsType& RequirementConstraintsType::create(const uci::type::RequirementConstraintsType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::RequirementConstraintsType> newAccessor{boost::make_unique<asb_uci::type::RequirementConstraintsType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void RequirementConstraintsType::destroy(uci::type::RequirementConstraintsType& accessor) {
  delete dynamic_cast<asb_uci::type::RequirementConstraintsType*>(&accessor);
}

} // namespace type

} // namespace uci

