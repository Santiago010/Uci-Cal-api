/** @file OrderOfBattleEmitterType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:14 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/OrderOfBattleEmitterType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/EOB_EmitterID_Type.h"
#include "asb_uci/type/EOB_EmitterIdentityType.h"
#include "asb_uci/type/EOB_EmitterModeType.h"
#include "asb_uci/type/OperationalScheduleType.h"
#include "asb_uci/type/OrderOfBattleLastCollectorType.h"
#include "asb_uci/type/OrderOfBattleRecordOwnerType.h"
#include "asb_uci/type/OrderOfBattleTimestampsType.h"
#include "asb_uci/type/VisibleString512Type.h"
#include "asb_uci/util/DerivedTypesCopier.h"
#include "asb_uci/util/DerivedTypesCreator.h"
#include "asb_uci/util/DerivedTypesDeserializer.h"
#include "asb_uci/util/DerivedTypesSerializer.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/EOB_EmitterID_Type.h"
#include "uci/type/EOB_EmitterIdentityType.h"
#include "uci/type/EOB_EmitterModeType.h"
#include "uci/type/OperationalScheduleType.h"
#include "uci/type/OrderOfBattleEmitterType.h"
#include "uci/type/OrderOfBattleLastCollectorType.h"
#include "uci/type/OrderOfBattleRecordOwnerType.h"
#include "uci/type/OrderOfBattleTimestampsType.h"
#include "uci/type/VisibleString512Type.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

OrderOfBattleEmitterType::OrderOfBattleEmitterType()
  : emitterID_Accessor{boost::make_unique<EOB_EmitterID_Type>()},
    mode_Accessor{boost::make_unique<Mode>(0, SIZE_MAX)} {
}

OrderOfBattleEmitterType::~OrderOfBattleEmitterType() = default;

void OrderOfBattleEmitterType::copy(const uci::type::OrderOfBattleEmitterType& accessor) {
  copyImpl(accessor, false);
}

void OrderOfBattleEmitterType::copyImpl(const uci::type::OrderOfBattleEmitterType& accessor, const bool checkIfDerivation) {
  if (&accessor != this) {
    if (!checkIfDerivation || (accessor.getAccessorType() == uci::type::accessorType::orderOfBattleEmitterType)) {
      const auto& accessorImpl = dynamic_cast<const OrderOfBattleEmitterType&>(accessor);
      setEmitterID(*(accessorImpl.emitterID_Accessor));
      if (accessorImpl.identity_Accessor) {
        setIdentity(*(accessorImpl.identity_Accessor));
      } else {
        identity_Accessor.reset();
      }
      if (accessorImpl.timestamps_Accessor) {
        setTimestamps(*(accessorImpl.timestamps_Accessor));
      } else {
        timestamps_Accessor.reset();
      }
      if (accessorImpl.lastCollector_Accessor) {
        setLastCollector(*(accessorImpl.lastCollector_Accessor));
      } else {
        lastCollector_Accessor.reset();
      }
      if (accessorImpl.recordOwner_Accessor) {
        setRecordOwner(*(accessorImpl.recordOwner_Accessor));
      } else {
        recordOwner_Accessor.reset();
      }
      if (accessorImpl.remarksText_Accessor) {
        setRemarksText(*(accessorImpl.remarksText_Accessor));
      } else {
        remarksText_Accessor.reset();
      }
      setMode(*(accessorImpl.mode_Accessor));
      if (accessorImpl.operationalSchedule_Accessor) {
        setOperationalSchedule(*(accessorImpl.operationalSchedule_Accessor));
      } else {
        operationalSchedule_Accessor.reset();
      }
    } else {
      asb_uci::util::DerivedTypesCopier::copy(accessor, *this);
    }
  }
}

void OrderOfBattleEmitterType::reset() noexcept {
  emitterID_Accessor->reset();
  identity_Accessor.reset();
  timestamps_Accessor.reset();
  lastCollector_Accessor.reset();
  recordOwner_Accessor.reset();
  remarksText_Accessor.reset();
  mode_Accessor->reset();
  operationalSchedule_Accessor.reset();
}

const uci::type::EOB_EmitterID_Type& OrderOfBattleEmitterType::getEmitterID() const {
  return *emitterID_Accessor;
}

uci::type::EOB_EmitterID_Type& OrderOfBattleEmitterType::getEmitterID() {
  return *emitterID_Accessor;
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setEmitterID(const uci::type::EOB_EmitterID_Type& accessor) {
  if (&accessor != emitterID_Accessor.get()) {
    emitterID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::EOB_EmitterIdentityType& OrderOfBattleEmitterType::getIdentity_() const {
  if (identity_Accessor) {
    return *identity_Accessor;
  }
  throw uci::base::UCIException("Error in getIdentity(): An attempt was made to get an optional field that was not enabled, call hasIdentity() to determine if it is safe to call getIdentity()");
}

const uci::type::EOB_EmitterIdentityType& OrderOfBattleEmitterType::getIdentity() const {
  return getIdentity_();
}

uci::type::EOB_EmitterIdentityType& OrderOfBattleEmitterType::getIdentity() {
  return getIdentity_();
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setIdentity(const uci::type::EOB_EmitterIdentityType& accessor) {
  enableIdentity();
  if (&accessor != identity_Accessor.get()) {
    identity_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrderOfBattleEmitterType::hasIdentity() const noexcept {
  return static_cast<bool>(identity_Accessor);
}

uci::type::EOB_EmitterIdentityType& OrderOfBattleEmitterType::enableIdentity(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::eOB_EmitterIdentityType : type};
  if ((!identity_Accessor) || (identity_Accessor->getAccessorType() != requestedType)) {
    identity_Accessor = EOB_EmitterIdentityType::create(requestedType);
    if (!identity_Accessor) {
      throw uci::base::UCIException("Error in enableIdentity(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *identity_Accessor;
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::clearIdentity() noexcept {
  identity_Accessor.reset();
  return *this;
}

uci::type::OrderOfBattleTimestampsType& OrderOfBattleEmitterType::getTimestamps_() const {
  if (timestamps_Accessor) {
    return *timestamps_Accessor;
  }
  throw uci::base::UCIException("Error in getTimestamps(): An attempt was made to get an optional field that was not enabled, call hasTimestamps() to determine if it is safe to call getTimestamps()");
}

const uci::type::OrderOfBattleTimestampsType& OrderOfBattleEmitterType::getTimestamps() const {
  return getTimestamps_();
}

uci::type::OrderOfBattleTimestampsType& OrderOfBattleEmitterType::getTimestamps() {
  return getTimestamps_();
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setTimestamps(const uci::type::OrderOfBattleTimestampsType& accessor) {
  enableTimestamps();
  if (&accessor != timestamps_Accessor.get()) {
    timestamps_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrderOfBattleEmitterType::hasTimestamps() const noexcept {
  return static_cast<bool>(timestamps_Accessor);
}

uci::type::OrderOfBattleTimestampsType& OrderOfBattleEmitterType::enableTimestamps(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orderOfBattleTimestampsType : type};
  if ((!timestamps_Accessor) || (timestamps_Accessor->getAccessorType() != requestedType)) {
    timestamps_Accessor = OrderOfBattleTimestampsType::create(requestedType);
    if (!timestamps_Accessor) {
      throw uci::base::UCIException("Error in enableTimestamps(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *timestamps_Accessor;
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::clearTimestamps() noexcept {
  timestamps_Accessor.reset();
  return *this;
}

uci::type::OrderOfBattleLastCollectorType& OrderOfBattleEmitterType::getLastCollector_() const {
  if (lastCollector_Accessor) {
    return *lastCollector_Accessor;
  }
  throw uci::base::UCIException("Error in getLastCollector(): An attempt was made to get an optional field that was not enabled, call hasLastCollector() to determine if it is safe to call getLastCollector()");
}

const uci::type::OrderOfBattleLastCollectorType& OrderOfBattleEmitterType::getLastCollector() const {
  return getLastCollector_();
}

uci::type::OrderOfBattleLastCollectorType& OrderOfBattleEmitterType::getLastCollector() {
  return getLastCollector_();
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setLastCollector(const uci::type::OrderOfBattleLastCollectorType& value) {
  return setLastCollector(value.c_str());
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setLastCollector(const std::string& value) {
  return setLastCollector(value.c_str());
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setLastCollector(const char* value) {
  enableLastCollector().setStringValue(value);
  return *this;
}

bool OrderOfBattleEmitterType::hasLastCollector() const noexcept {
  return static_cast<bool>(lastCollector_Accessor);
}

uci::type::OrderOfBattleLastCollectorType& OrderOfBattleEmitterType::enableLastCollector(uci::base::accessorType::AccessorType type) {
  if (!lastCollector_Accessor) {
    lastCollector_Accessor = OrderOfBattleLastCollectorType::create(type);
  }
  return *lastCollector_Accessor;
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::clearLastCollector() noexcept {
  lastCollector_Accessor.reset();
  return *this;
}

uci::type::OrderOfBattleRecordOwnerType& OrderOfBattleEmitterType::getRecordOwner_() const {
  if (recordOwner_Accessor) {
    return *recordOwner_Accessor;
  }
  throw uci::base::UCIException("Error in getRecordOwner(): An attempt was made to get an optional field that was not enabled, call hasRecordOwner() to determine if it is safe to call getRecordOwner()");
}

const uci::type::OrderOfBattleRecordOwnerType& OrderOfBattleEmitterType::getRecordOwner() const {
  return getRecordOwner_();
}

uci::type::OrderOfBattleRecordOwnerType& OrderOfBattleEmitterType::getRecordOwner() {
  return getRecordOwner_();
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setRecordOwner(const uci::type::OrderOfBattleRecordOwnerType& value) {
  return setRecordOwner(value.c_str());
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setRecordOwner(const std::string& value) {
  return setRecordOwner(value.c_str());
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setRecordOwner(const char* value) {
  enableRecordOwner().setStringValue(value);
  return *this;
}

bool OrderOfBattleEmitterType::hasRecordOwner() const noexcept {
  return static_cast<bool>(recordOwner_Accessor);
}

uci::type::OrderOfBattleRecordOwnerType& OrderOfBattleEmitterType::enableRecordOwner(uci::base::accessorType::AccessorType type) {
  if (!recordOwner_Accessor) {
    recordOwner_Accessor = OrderOfBattleRecordOwnerType::create(type);
  }
  return *recordOwner_Accessor;
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::clearRecordOwner() noexcept {
  recordOwner_Accessor.reset();
  return *this;
}

uci::type::VisibleString512Type& OrderOfBattleEmitterType::getRemarksText_() const {
  if (remarksText_Accessor) {
    return *remarksText_Accessor;
  }
  throw uci::base::UCIException("Error in getRemarksText(): An attempt was made to get an optional field that was not enabled, call hasRemarksText() to determine if it is safe to call getRemarksText()");
}

const uci::type::VisibleString512Type& OrderOfBattleEmitterType::getRemarksText() const {
  return getRemarksText_();
}

uci::type::VisibleString512Type& OrderOfBattleEmitterType::getRemarksText() {
  return getRemarksText_();
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setRemarksText(const uci::type::VisibleString512Type& value) {
  return setRemarksText(value.c_str());
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setRemarksText(const std::string& value) {
  return setRemarksText(value.c_str());
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setRemarksText(const char* value) {
  enableRemarksText().setStringValue(value);
  return *this;
}

bool OrderOfBattleEmitterType::hasRemarksText() const noexcept {
  return static_cast<bool>(remarksText_Accessor);
}

uci::type::VisibleString512Type& OrderOfBattleEmitterType::enableRemarksText(uci::base::accessorType::AccessorType type) {
  if (!remarksText_Accessor) {
    remarksText_Accessor = VisibleString512Type::create(type);
  }
  return *remarksText_Accessor;
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::clearRemarksText() noexcept {
  remarksText_Accessor.reset();
  return *this;
}

const uci::type::OrderOfBattleEmitterType::Mode& OrderOfBattleEmitterType::getMode() const {
  return *mode_Accessor;
}

uci::type::OrderOfBattleEmitterType::Mode& OrderOfBattleEmitterType::getMode() {
  return *mode_Accessor;
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setMode(const uci::type::OrderOfBattleEmitterType::Mode& accessor) {
  if (&accessor != mode_Accessor.get()) {
    mode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::OperationalScheduleType& OrderOfBattleEmitterType::getOperationalSchedule_() const {
  if (operationalSchedule_Accessor) {
    return *operationalSchedule_Accessor;
  }
  throw uci::base::UCIException("Error in getOperationalSchedule(): An attempt was made to get an optional field that was not enabled, call hasOperationalSchedule() to determine if it is safe to call getOperationalSchedule()");
}

const uci::type::OperationalScheduleType& OrderOfBattleEmitterType::getOperationalSchedule() const {
  return getOperationalSchedule_();
}

uci::type::OperationalScheduleType& OrderOfBattleEmitterType::getOperationalSchedule() {
  return getOperationalSchedule_();
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::setOperationalSchedule(const uci::type::OperationalScheduleType& accessor) {
  enableOperationalSchedule();
  if (&accessor != operationalSchedule_Accessor.get()) {
    operationalSchedule_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrderOfBattleEmitterType::hasOperationalSchedule() const noexcept {
  return static_cast<bool>(operationalSchedule_Accessor);
}

uci::type::OperationalScheduleType& OrderOfBattleEmitterType::enableOperationalSchedule(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::operationalScheduleType : type};
  if ((!operationalSchedule_Accessor) || (operationalSchedule_Accessor->getAccessorType() != requestedType)) {
    operationalSchedule_Accessor = OperationalScheduleType::create(requestedType);
    if (!operationalSchedule_Accessor) {
      throw uci::base::UCIException("Error in enableOperationalSchedule(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *operationalSchedule_Accessor;
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::clearOperationalSchedule() noexcept {
  operationalSchedule_Accessor.reset();
  return *this;
}

std::unique_ptr<OrderOfBattleEmitterType> OrderOfBattleEmitterType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orderOfBattleEmitterType : type};
  return std::unique_ptr<OrderOfBattleEmitterType>(dynamic_cast<OrderOfBattleEmitterType*>(asb_uci::util::DerivedTypesCreator::create(requestedType)));
}

/**  */
namespace OrderOfBattleEmitterType_Names {

constexpr const char* Extern_Type_Name{"OrderOfBattleEmitterType"};
constexpr const char* EmitterID_Name{"EmitterID"};
constexpr const char* Identity_Name{"Identity"};
constexpr const char* Timestamps_Name{"Timestamps"};
constexpr const char* LastCollector_Name{"LastCollector"};
constexpr const char* RecordOwner_Name{"RecordOwner"};
constexpr const char* RemarksText_Name{"RemarksText"};
constexpr const char* Mode_Name{"Mode"};
constexpr const char* OperationalSchedule_Name{"OperationalSchedule"};

} // namespace OrderOfBattleEmitterType_Names

void OrderOfBattleEmitterType::deserialize(const boost::property_tree::ptree& propTree, uci::type::OrderOfBattleEmitterType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = OrderOfBattleEmitterType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + OrderOfBattleEmitterType_Names::EmitterID_Name) {
      EOB_EmitterID_Type::deserialize(valueType.second, accessor.getEmitterID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrderOfBattleEmitterType_Names::Identity_Name) {
      EOB_EmitterIdentityType::deserialize(valueType.second, accessor.enableIdentity(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrderOfBattleEmitterType_Names::Timestamps_Name) {
      OrderOfBattleTimestampsType::deserialize(valueType.second, accessor.enableTimestamps(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrderOfBattleEmitterType_Names::LastCollector_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setLastCollector(*value);
      }
    } else if (valueType.first == nsPrefix + OrderOfBattleEmitterType_Names::RecordOwner_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setRecordOwner(*value);
      }
    } else if (valueType.first == nsPrefix + OrderOfBattleEmitterType_Names::RemarksText_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setRemarksText(*value);
      }
    } else if (valueType.first == nsPrefix + OrderOfBattleEmitterType_Names::Mode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::OrderOfBattleEmitterType::Mode& boundedList = accessor.getMode();
        const uci::type::OrderOfBattleEmitterType::Mode::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::EOB_EmitterModeType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + OrderOfBattleEmitterType_Names::OperationalSchedule_Name) {
      OperationalScheduleType::deserialize(valueType.second, accessor.enableOperationalSchedule(), nodeName, nsPrefix);
    }
  }
}

std::string OrderOfBattleEmitterType::serialize(const uci::type::OrderOfBattleEmitterType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool checkIfDerivation, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? OrderOfBattleEmitterType_Names::Extern_Type_Name : nodeName)};
  if (!checkIfDerivation || (accessor.getAccessorType() == uci::type::accessorType::orderOfBattleEmitterType)) {
    boost::property_tree::ptree newNode;
    boost::property_tree::ptree& node = (createNode ? newNode : propTree);
    if (addTypeAttribute) {
      asb_uci::util::SerializationHelpers::addTypeAttribute(node, OrderOfBattleEmitterType_Names::Extern_Type_Name);
    }
    EOB_EmitterID_Type::serialize(accessor.getEmitterID(), node, OrderOfBattleEmitterType_Names::EmitterID_Name);
    if (accessor.hasIdentity()) {
      EOB_EmitterIdentityType::serialize(accessor.getIdentity(), node, OrderOfBattleEmitterType_Names::Identity_Name);
    }
    if (accessor.hasTimestamps()) {
      OrderOfBattleTimestampsType::serialize(accessor.getTimestamps(), node, OrderOfBattleEmitterType_Names::Timestamps_Name);
    }
    if (accessor.hasLastCollector()) {
      asb_uci::util::SerializationHelpers::serializeString(accessor.getLastCollector(), node, OrderOfBattleEmitterType_Names::LastCollector_Name);
    }
    if (accessor.hasRecordOwner()) {
      asb_uci::util::SerializationHelpers::serializeString(accessor.getRecordOwner(), node, OrderOfBattleEmitterType_Names::RecordOwner_Name);
    }
    if (accessor.hasRemarksText()) {
      asb_uci::util::SerializationHelpers::serializeString(accessor.getRemarksText(), node, OrderOfBattleEmitterType_Names::RemarksText_Name);
    }
    {
      const uci::type::OrderOfBattleEmitterType::Mode& boundedList = accessor.getMode();
      for (uci::type::OrderOfBattleEmitterType::Mode::size_type i = 0, end = boundedList.size(); i < end; ++i) {
        asb_uci::type::EOB_EmitterModeType::serialize(boundedList.at(i), node, OrderOfBattleEmitterType_Names::Mode_Name);
      }
    }
    if (accessor.hasOperationalSchedule()) {
      OperationalScheduleType::serialize(accessor.getOperationalSchedule(), node, OrderOfBattleEmitterType_Names::OperationalSchedule_Name);
    }
    if (createNode) {
      propTree.add_child(generatedNodeName, node);
    }
  } else {
    asb_uci::util::DerivedTypesSerializer::serialize(accessor, propTree, nodeName, createNode);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::OrderOfBattleEmitterType>().release());
}

uci::type::OrderOfBattleEmitterType& OrderOfBattleEmitterType::create(const uci::type::OrderOfBattleEmitterType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::OrderOfBattleEmitterType> newAccessor{boost::make_unique<asb_uci::type::OrderOfBattleEmitterType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void OrderOfBattleEmitterType::destroy(uci::type::OrderOfBattleEmitterType& accessor) {
  delete dynamic_cast<asb_uci::type::OrderOfBattleEmitterType*>(&accessor);
}

} // namespace type

} // namespace uci

