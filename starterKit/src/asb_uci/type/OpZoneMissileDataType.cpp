/** @file OpZoneMissileDataType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/OpZoneMissileDataType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/LaunchPointCalculationEnum.h"
#include "../../../include/asb_uci/type/PercentRangeType.h"
#include "../../../include/asb_uci/type/SpaceObjectEnum.h"
#include "../../../include/asb_uci/type/TrackNumberOrEntityType.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/LaunchPointCalculationEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OpZoneMissileDataType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PercentRangeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SpaceObjectEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/TrackNumberOrEntityType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

OpZoneMissileDataType::OpZoneMissileDataType() = default;

OpZoneMissileDataType::~OpZoneMissileDataType() = default;

void OpZoneMissileDataType::copy(const uci::type::OpZoneMissileDataType& accessor) {
  copyImpl(accessor, false);
}

void OpZoneMissileDataType::copyImpl(const uci::type::OpZoneMissileDataType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const OpZoneMissileDataType&>(accessor);
    if (accessorImpl.spaceObject_Accessor) {
      setSpaceObject(*(accessorImpl.spaceObject_Accessor));
    } else {
      spaceObject_Accessor.reset();
    }
    if (accessorImpl.confidence_Accessor) {
      setConfidence(*(accessorImpl.confidence_Accessor));
    } else {
      confidence_Accessor.reset();
    }
    if (accessorImpl.relatedTrack_Accessor) {
      setRelatedTrack(*(accessorImpl.relatedTrack_Accessor));
    } else {
      relatedTrack_Accessor.reset();
    }
    if (accessorImpl.launchPointCalculation_Accessor) {
      setLaunchPointCalculation(*(accessorImpl.launchPointCalculation_Accessor));
    } else {
      launchPointCalculation_Accessor.reset();
    }
  }
}

void OpZoneMissileDataType::reset() noexcept {
  spaceObject_Accessor.reset();
  confidence_Accessor.reset();
  relatedTrack_Accessor.reset();
  launchPointCalculation_Accessor.reset();
}

uci::type::SpaceObjectEnum& OpZoneMissileDataType::getSpaceObject_() const {
  if (spaceObject_Accessor) {
    return *spaceObject_Accessor;
  }
  throw uci::base::UCIException("Error in getSpaceObject(): An attempt was made to get an optional field that was not enabled, call hasSpaceObject() to determine if it is safe to call getSpaceObject()");
}

const uci::type::SpaceObjectEnum& OpZoneMissileDataType::getSpaceObject() const {
  return getSpaceObject_();
}

uci::type::SpaceObjectEnum& OpZoneMissileDataType::getSpaceObject() {
  return getSpaceObject_();
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::setSpaceObject(const uci::type::SpaceObjectEnum& accessor) {
  enableSpaceObject();
  if (&accessor != spaceObject_Accessor.get()) {
    spaceObject_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::setSpaceObject(const uci::type::SpaceObjectEnum::EnumerationItem value) {
  enableSpaceObject().setValue(value);
  return *this;
}

bool OpZoneMissileDataType::hasSpaceObject() const noexcept {
  return static_cast<bool>(spaceObject_Accessor);
}

uci::type::SpaceObjectEnum& OpZoneMissileDataType::enableSpaceObject(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::spaceObjectEnum : type};
  if ((!spaceObject_Accessor) || (spaceObject_Accessor->getAccessorType() != requestedType)) {
    spaceObject_Accessor = SpaceObjectEnum::create(requestedType);
    if (!spaceObject_Accessor) {
      throw uci::base::UCIException("Error in enableSpaceObject(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *spaceObject_Accessor;
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::clearSpaceObject() noexcept {
  spaceObject_Accessor.reset();
  return *this;
}

uci::type::PercentRangeType& OpZoneMissileDataType::getConfidence_() const {
  if (confidence_Accessor) {
    return *confidence_Accessor;
  }
  throw uci::base::UCIException("Error in getConfidence(): An attempt was made to get an optional field that was not enabled, call hasConfidence() to determine if it is safe to call getConfidence()");
}

const uci::type::PercentRangeType& OpZoneMissileDataType::getConfidence() const {
  return getConfidence_();
}

uci::type::PercentRangeType& OpZoneMissileDataType::getConfidence() {
  return getConfidence_();
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::setConfidence(const uci::type::PercentRangeType& accessor) {
  enableConfidence();
  if (&accessor != confidence_Accessor.get()) {
    confidence_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OpZoneMissileDataType::hasConfidence() const noexcept {
  return static_cast<bool>(confidence_Accessor);
}

uci::type::PercentRangeType& OpZoneMissileDataType::enableConfidence(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::percentRangeType : type};
  if ((!confidence_Accessor) || (confidence_Accessor->getAccessorType() != requestedType)) {
    confidence_Accessor = PercentRangeType::create(requestedType);
    if (!confidence_Accessor) {
      throw uci::base::UCIException("Error in enableConfidence(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *confidence_Accessor;
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::clearConfidence() noexcept {
  confidence_Accessor.reset();
  return *this;
}

uci::type::TrackNumberOrEntityType& OpZoneMissileDataType::getRelatedTrack_() const {
  if (relatedTrack_Accessor) {
    return *relatedTrack_Accessor;
  }
  throw uci::base::UCIException("Error in getRelatedTrack(): An attempt was made to get an optional field that was not enabled, call hasRelatedTrack() to determine if it is safe to call getRelatedTrack()");
}

const uci::type::TrackNumberOrEntityType& OpZoneMissileDataType::getRelatedTrack() const {
  return getRelatedTrack_();
}

uci::type::TrackNumberOrEntityType& OpZoneMissileDataType::getRelatedTrack() {
  return getRelatedTrack_();
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::setRelatedTrack(const uci::type::TrackNumberOrEntityType& accessor) {
  enableRelatedTrack();
  if (&accessor != relatedTrack_Accessor.get()) {
    relatedTrack_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OpZoneMissileDataType::hasRelatedTrack() const noexcept {
  return static_cast<bool>(relatedTrack_Accessor);
}

uci::type::TrackNumberOrEntityType& OpZoneMissileDataType::enableRelatedTrack(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::trackNumberOrEntityType : type};
  if ((!relatedTrack_Accessor) || (relatedTrack_Accessor->getAccessorType() != requestedType)) {
    relatedTrack_Accessor = TrackNumberOrEntityType::create(requestedType);
    if (!relatedTrack_Accessor) {
      throw uci::base::UCIException("Error in enableRelatedTrack(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *relatedTrack_Accessor;
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::clearRelatedTrack() noexcept {
  relatedTrack_Accessor.reset();
  return *this;
}

uci::type::LaunchPointCalculationEnum& OpZoneMissileDataType::getLaunchPointCalculation_() const {
  if (launchPointCalculation_Accessor) {
    return *launchPointCalculation_Accessor;
  }
  throw uci::base::UCIException("Error in getLaunchPointCalculation(): An attempt was made to get an optional field that was not enabled, call hasLaunchPointCalculation() to determine if it is safe to call getLaunchPointCalculation()");
}

const uci::type::LaunchPointCalculationEnum& OpZoneMissileDataType::getLaunchPointCalculation() const {
  return getLaunchPointCalculation_();
}

uci::type::LaunchPointCalculationEnum& OpZoneMissileDataType::getLaunchPointCalculation() {
  return getLaunchPointCalculation_();
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::setLaunchPointCalculation(const uci::type::LaunchPointCalculationEnum& accessor) {
  enableLaunchPointCalculation();
  if (&accessor != launchPointCalculation_Accessor.get()) {
    launchPointCalculation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::setLaunchPointCalculation(const uci::type::LaunchPointCalculationEnum::EnumerationItem value) {
  enableLaunchPointCalculation().setValue(value);
  return *this;
}

bool OpZoneMissileDataType::hasLaunchPointCalculation() const noexcept {
  return static_cast<bool>(launchPointCalculation_Accessor);
}

uci::type::LaunchPointCalculationEnum& OpZoneMissileDataType::enableLaunchPointCalculation(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::launchPointCalculationEnum : type};
  if ((!launchPointCalculation_Accessor) || (launchPointCalculation_Accessor->getAccessorType() != requestedType)) {
    launchPointCalculation_Accessor = LaunchPointCalculationEnum::create(requestedType);
    if (!launchPointCalculation_Accessor) {
      throw uci::base::UCIException("Error in enableLaunchPointCalculation(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *launchPointCalculation_Accessor;
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::clearLaunchPointCalculation() noexcept {
  launchPointCalculation_Accessor.reset();
  return *this;
}

std::unique_ptr<OpZoneMissileDataType> OpZoneMissileDataType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::opZoneMissileDataType : type};
  return (requestedType == uci::type::accessorType::opZoneMissileDataType) ? boost::make_unique<OpZoneMissileDataType>() : nullptr;
}

/**  */
namespace OpZoneMissileDataType_Names {

constexpr const char* Extern_Type_Name{"OpZoneMissileDataType"};
constexpr const char* SpaceObject_Name{"SpaceObject"};
constexpr const char* Confidence_Name{"Confidence"};
constexpr const char* RelatedTrack_Name{"RelatedTrack"};
constexpr const char* LaunchPointCalculation_Name{"LaunchPointCalculation"};

} // namespace OpZoneMissileDataType_Names

void OpZoneMissileDataType::deserialize(const boost::property_tree::ptree& propTree, uci::type::OpZoneMissileDataType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = OpZoneMissileDataType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + OpZoneMissileDataType_Names::SpaceObject_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableSpaceObject().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + OpZoneMissileDataType_Names::Confidence_Name) {
      PercentRangeType::deserialize(valueType.second, accessor.enableConfidence(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OpZoneMissileDataType_Names::RelatedTrack_Name) {
      TrackNumberOrEntityType::deserialize(valueType.second, accessor.enableRelatedTrack(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OpZoneMissileDataType_Names::LaunchPointCalculation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableLaunchPointCalculation().setValueFromName(*value);
      }
    }
  }
}

std::string OpZoneMissileDataType::serialize(const uci::type::OpZoneMissileDataType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? OpZoneMissileDataType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, OpZoneMissileDataType_Names::Extern_Type_Name);
  }
  if (accessor.hasSpaceObject()) {
    SpaceObjectEnum::serialize(accessor.getSpaceObject(), node, OpZoneMissileDataType_Names::SpaceObject_Name, false);
  }
  if (accessor.hasConfidence()) {
    PercentRangeType::serialize(accessor.getConfidence(), node, OpZoneMissileDataType_Names::Confidence_Name);
  }
  if (accessor.hasRelatedTrack()) {
    TrackNumberOrEntityType::serialize(accessor.getRelatedTrack(), node, OpZoneMissileDataType_Names::RelatedTrack_Name);
  }
  if (accessor.hasLaunchPointCalculation()) {
    LaunchPointCalculationEnum::serialize(accessor.getLaunchPointCalculation(), node, OpZoneMissileDataType_Names::LaunchPointCalculation_Name, false);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::OpZoneMissileDataType>().release());
}

uci::type::OpZoneMissileDataType& OpZoneMissileDataType::create(const uci::type::OpZoneMissileDataType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::OpZoneMissileDataType> newAccessor{boost::make_unique<asb_uci::type::OpZoneMissileDataType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void OpZoneMissileDataType::destroy(uci::type::OpZoneMissileDataType& accessor) {
  delete dynamic_cast<asb_uci::type::OpZoneMissileDataType*>(&accessor);
}

} // namespace type

} // namespace uci

