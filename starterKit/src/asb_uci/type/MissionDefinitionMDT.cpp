/** @file MissionDefinitionMDT.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/MissionDefinitionMDT.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/ArchiveRequestType.h"
#include "../../../include/asb_uci/type/DataRecordBaseType.h"
#include "../../../include/asb_uci/type/DateTimeRangeType.h"
#include "../../../include/asb_uci/type/MissionDefinitionID_Type.h"
#include "../../../include/asb_uci/type/MissionID_Type.h"
#include "../../../include/asb_uci/type/MissionStateEnum.h"
#include "../../../include/asb_uci/type/OrderTraceabilityType.h"
#include "../../../include/asb_uci/type/SystemID_Type.h"
#include "../../../include/asb_uci/type/UserIdentifierType.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ArchiveRequestType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DateTimeRangeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MissionCategoryType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MissionDefinitionID_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MissionDefinitionMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MissionID_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MissionStateEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OrderTraceabilityType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SystemID_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/UserIdentifierType.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

MissionDefinitionMDT::MissionDefinitionMDT()
  : missionDefinitionID_Accessor{boost::make_unique<MissionDefinitionID_Type>()},
    missionID_Accessor{boost::make_unique<MissionID_Type>()},
    parentMissionID_Accessor{boost::make_unique<ParentMissionID>(0, SIZE_MAX)},
    orderTraceability_Accessor{boost::make_unique<OrderTraceability>(0, SIZE_MAX)},
    missionType_Accessor{boost::make_unique<MissionType>(0, SIZE_MAX)},
    missionState_Accessor{boost::make_unique<MissionStateEnum>()},
    authorizedSystemID_Accessor{boost::make_unique<AuthorizedSystemID>(1, SIZE_MAX)},
    authorizedUserIdentifier_Accessor{boost::make_unique<AuthorizedUserIdentifier>(1, SIZE_MAX)} {
}

MissionDefinitionMDT::~MissionDefinitionMDT() = default;

void MissionDefinitionMDT::copy(const uci::type::MissionDefinitionMDT& accessor) {
  copyImpl(accessor, false);
}

void MissionDefinitionMDT::copyImpl(const uci::type::MissionDefinitionMDT& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    DataRecordBaseType::copyImpl(accessor, false);
    const auto& accessorImpl = dynamic_cast<const MissionDefinitionMDT&>(accessor);
    setMissionDefinitionID(*(accessorImpl.missionDefinitionID_Accessor));
    setMissionID(*(accessorImpl.missionID_Accessor));
    setParentMissionID(*(accessorImpl.parentMissionID_Accessor));
    setOrderTraceability(*(accessorImpl.orderTraceability_Accessor));
    setMissionType(*(accessorImpl.missionType_Accessor));
    setMissionState(*(accessorImpl.missionState_Accessor));
    if (accessorImpl.timeSpan_Accessor) {
      setTimeSpan(*(accessorImpl.timeSpan_Accessor));
    } else {
      timeSpan_Accessor.reset();
    }
    setExpired(accessorImpl.expired_Accessor);
    setAuthorizedSystemID(*(accessorImpl.authorizedSystemID_Accessor));
    setAuthorizedUserIdentifier(*(accessorImpl.authorizedUserIdentifier_Accessor));
    if (accessorImpl.archiveConfiguration_Accessor) {
      setArchiveConfiguration(*(accessorImpl.archiveConfiguration_Accessor));
    } else {
      archiveConfiguration_Accessor.reset();
    }
  }
}

void MissionDefinitionMDT::reset() noexcept {
  DataRecordBaseType::reset();
  missionDefinitionID_Accessor->reset();
  missionID_Accessor->reset();
  parentMissionID_Accessor->reset();
  orderTraceability_Accessor->reset();
  missionType_Accessor->reset();
  missionState_Accessor->reset();
  timeSpan_Accessor.reset();
  expired_Accessor = false;
  authorizedSystemID_Accessor->reset();
  authorizedUserIdentifier_Accessor->reset();
  archiveConfiguration_Accessor.reset();
}

const uci::type::MissionDefinitionID_Type& MissionDefinitionMDT::getMissionDefinitionID() const {
  return *missionDefinitionID_Accessor;
}

uci::type::MissionDefinitionID_Type& MissionDefinitionMDT::getMissionDefinitionID() {
  return *missionDefinitionID_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setMissionDefinitionID(const uci::type::MissionDefinitionID_Type& accessor) {
  if (&accessor != missionDefinitionID_Accessor.get()) {
    missionDefinitionID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::MissionID_Type& MissionDefinitionMDT::getMissionID() const {
  return *missionID_Accessor;
}

uci::type::MissionID_Type& MissionDefinitionMDT::getMissionID() {
  return *missionID_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setMissionID(const uci::type::MissionID_Type& accessor) {
  if (&accessor != missionID_Accessor.get()) {
    missionID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::MissionDefinitionMDT::ParentMissionID& MissionDefinitionMDT::getParentMissionID() const {
  return *parentMissionID_Accessor;
}

uci::type::MissionDefinitionMDT::ParentMissionID& MissionDefinitionMDT::getParentMissionID() {
  return *parentMissionID_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setParentMissionID(const uci::type::MissionDefinitionMDT::ParentMissionID& accessor) {
  if (&accessor != parentMissionID_Accessor.get()) {
    parentMissionID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::MissionDefinitionMDT::OrderTraceability& MissionDefinitionMDT::getOrderTraceability() const {
  return *orderTraceability_Accessor;
}

uci::type::MissionDefinitionMDT::OrderTraceability& MissionDefinitionMDT::getOrderTraceability() {
  return *orderTraceability_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setOrderTraceability(const uci::type::MissionDefinitionMDT::OrderTraceability& accessor) {
  if (&accessor != orderTraceability_Accessor.get()) {
    orderTraceability_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::MissionDefinitionMDT::MissionType& MissionDefinitionMDT::getMissionType() const {
  return *missionType_Accessor;
}

uci::type::MissionDefinitionMDT::MissionType& MissionDefinitionMDT::getMissionType() {
  return *missionType_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setMissionType(const uci::type::MissionDefinitionMDT::MissionType& accessor) {
  if (&accessor != missionType_Accessor.get()) {
    missionType_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::MissionStateEnum& MissionDefinitionMDT::getMissionState() const {
  return *missionState_Accessor;
}

uci::type::MissionStateEnum& MissionDefinitionMDT::getMissionState() {
  return *missionState_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setMissionState(const uci::type::MissionStateEnum& accessor) {
  if (&accessor != missionState_Accessor.get()) {
    missionState_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setMissionState(uci::type::MissionStateEnum::EnumerationItem value) {
  missionState_Accessor->setValue(value);
  return *this;
}


uci::type::DateTimeRangeType& MissionDefinitionMDT::getTimeSpan_() const {
  if (timeSpan_Accessor) {
    return *timeSpan_Accessor;
  }
  throw uci::base::UCIException("Error in getTimeSpan(): An attempt was made to get an optional field that was not enabled, call hasTimeSpan() to determine if it is safe to call getTimeSpan()");
}

const uci::type::DateTimeRangeType& MissionDefinitionMDT::getTimeSpan() const {
  return getTimeSpan_();
}

uci::type::DateTimeRangeType& MissionDefinitionMDT::getTimeSpan() {
  return getTimeSpan_();
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setTimeSpan(const uci::type::DateTimeRangeType& accessor) {
  enableTimeSpan();
  if (&accessor != timeSpan_Accessor.get()) {
    timeSpan_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionDefinitionMDT::hasTimeSpan() const noexcept {
  return static_cast<bool>(timeSpan_Accessor);
}

uci::type::DateTimeRangeType& MissionDefinitionMDT::enableTimeSpan(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::dateTimeRangeType : type};
  if ((!timeSpan_Accessor) || (timeSpan_Accessor->getAccessorType() != requestedType)) {
    timeSpan_Accessor = DateTimeRangeType::create(requestedType);
    if (!timeSpan_Accessor) {
      throw uci::base::UCIException("Error in enableTimeSpan(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *timeSpan_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::clearTimeSpan() noexcept {
  timeSpan_Accessor.reset();
  return *this;
}

xs::Boolean MissionDefinitionMDT::getExpired() const {
  return expired_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setExpired(xs::Boolean value) {
  expired_Accessor = value;
  return *this;
}


const uci::type::MissionDefinitionMDT::AuthorizedSystemID& MissionDefinitionMDT::getAuthorizedSystemID() const {
  return *authorizedSystemID_Accessor;
}

uci::type::MissionDefinitionMDT::AuthorizedSystemID& MissionDefinitionMDT::getAuthorizedSystemID() {
  return *authorizedSystemID_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setAuthorizedSystemID(const uci::type::MissionDefinitionMDT::AuthorizedSystemID& accessor) {
  if (&accessor != authorizedSystemID_Accessor.get()) {
    authorizedSystemID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::MissionDefinitionMDT::AuthorizedUserIdentifier& MissionDefinitionMDT::getAuthorizedUserIdentifier() const {
  return *authorizedUserIdentifier_Accessor;
}

uci::type::MissionDefinitionMDT::AuthorizedUserIdentifier& MissionDefinitionMDT::getAuthorizedUserIdentifier() {
  return *authorizedUserIdentifier_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setAuthorizedUserIdentifier(const uci::type::MissionDefinitionMDT::AuthorizedUserIdentifier& accessor) {
  if (&accessor != authorizedUserIdentifier_Accessor.get()) {
    authorizedUserIdentifier_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::ArchiveRequestType& MissionDefinitionMDT::getArchiveConfiguration_() const {
  if (archiveConfiguration_Accessor) {
    return *archiveConfiguration_Accessor;
  }
  throw uci::base::UCIException("Error in getArchiveConfiguration(): An attempt was made to get an optional field that was not enabled, call hasArchiveConfiguration() to determine if it is safe to call getArchiveConfiguration()");
}

const uci::type::ArchiveRequestType& MissionDefinitionMDT::getArchiveConfiguration() const {
  return getArchiveConfiguration_();
}

uci::type::ArchiveRequestType& MissionDefinitionMDT::getArchiveConfiguration() {
  return getArchiveConfiguration_();
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::setArchiveConfiguration(const uci::type::ArchiveRequestType& accessor) {
  enableArchiveConfiguration();
  if (&accessor != archiveConfiguration_Accessor.get()) {
    archiveConfiguration_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionDefinitionMDT::hasArchiveConfiguration() const noexcept {
  return static_cast<bool>(archiveConfiguration_Accessor);
}

uci::type::ArchiveRequestType& MissionDefinitionMDT::enableArchiveConfiguration(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::archiveRequestType : type};
  if ((!archiveConfiguration_Accessor) || (archiveConfiguration_Accessor->getAccessorType() != requestedType)) {
    archiveConfiguration_Accessor = ArchiveRequestType::create(requestedType);
    if (!archiveConfiguration_Accessor) {
      throw uci::base::UCIException("Error in enableArchiveConfiguration(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *archiveConfiguration_Accessor;
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::clearArchiveConfiguration() noexcept {
  archiveConfiguration_Accessor.reset();
  return *this;
}

std::unique_ptr<MissionDefinitionMDT> MissionDefinitionMDT::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::missionDefinitionMDT : type};
  return (requestedType == uci::type::accessorType::missionDefinitionMDT) ? boost::make_unique<MissionDefinitionMDT>() : nullptr;
}

/**  */
namespace MissionDefinitionMDT_Names {

constexpr const char* Extern_Type_Name{"MissionDefinitionMDT"};
constexpr const char* MissionDefinitionID_Name{"MissionDefinitionID"};
constexpr const char* MissionID_Name{"MissionID"};
constexpr const char* ParentMissionID_Name{"ParentMissionID"};
constexpr const char* OrderTraceability_Name{"OrderTraceability"};
constexpr const char* MissionType_Name{"MissionType"};
constexpr const char* MissionState_Name{"MissionState"};
constexpr const char* TimeSpan_Name{"TimeSpan"};
constexpr const char* Expired_Name{"Expired"};
constexpr const char* AuthorizedSystemID_Name{"AuthorizedSystemID"};
constexpr const char* AuthorizedUserIdentifier_Name{"AuthorizedUserIdentifier"};
constexpr const char* ArchiveConfiguration_Name{"ArchiveConfiguration"};

} // namespace MissionDefinitionMDT_Names

void MissionDefinitionMDT::deserialize(const boost::property_tree::ptree& propTree, uci::type::MissionDefinitionMDT& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = MissionDefinitionMDT_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::MissionDefinitionID_Name) {
      MissionDefinitionID_Type::deserialize(valueType.second, accessor.getMissionDefinitionID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::MissionID_Name) {
      MissionID_Type::deserialize(valueType.second, accessor.getMissionID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::ParentMissionID_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::MissionDefinitionMDT::ParentMissionID& boundedList = accessor.getParentMissionID();
        const uci::type::MissionDefinitionMDT::ParentMissionID::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::MissionID_Type::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::OrderTraceability_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::MissionDefinitionMDT::OrderTraceability& boundedList = accessor.getOrderTraceability();
        const uci::type::MissionDefinitionMDT::OrderTraceability::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::OrderTraceabilityType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::MissionType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::MissionDefinitionMDT::MissionType& boundedList = accessor.getMissionType();
        const uci::type::MissionDefinitionMDT::MissionType::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::MissionState_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.getMissionState().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::TimeSpan_Name) {
      DateTimeRangeType::deserialize(valueType.second, accessor.enableTimeSpan(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::Expired_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setExpired(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::AuthorizedSystemID_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::MissionDefinitionMDT::AuthorizedSystemID& boundedList = accessor.getAuthorizedSystemID();
        const uci::type::MissionDefinitionMDT::AuthorizedSystemID::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::SystemID_Type::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::AuthorizedUserIdentifier_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::MissionDefinitionMDT::AuthorizedUserIdentifier& boundedList = accessor.getAuthorizedUserIdentifier();
        const uci::type::MissionDefinitionMDT::AuthorizedUserIdentifier::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + MissionDefinitionMDT_Names::ArchiveConfiguration_Name) {
      ArchiveRequestType::deserialize(valueType.second, accessor.enableArchiveConfiguration(), nodeName, nsPrefix);
    }
  }
  DataRecordBaseType::deserialize(node, accessor, nodeName, nsPrefix);
}

std::string MissionDefinitionMDT::serialize(const uci::type::MissionDefinitionMDT& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? MissionDefinitionMDT_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, MissionDefinitionMDT_Names::Extern_Type_Name);
  }
  DataRecordBaseType::serialize(accessor, node, "", false, false, false);
  MissionDefinitionID_Type::serialize(accessor.getMissionDefinitionID(), node, MissionDefinitionMDT_Names::MissionDefinitionID_Name);
  MissionID_Type::serialize(accessor.getMissionID(), node, MissionDefinitionMDT_Names::MissionID_Name);
  {
    const uci::type::MissionDefinitionMDT::ParentMissionID& boundedList = accessor.getParentMissionID();
    for (uci::type::MissionDefinitionMDT::ParentMissionID::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::MissionID_Type::serialize(boundedList.at(i), node, MissionDefinitionMDT_Names::ParentMissionID_Name);
    }
  }
  {
    const uci::type::MissionDefinitionMDT::OrderTraceability& boundedList = accessor.getOrderTraceability();
    for (uci::type::MissionDefinitionMDT::OrderTraceability::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::OrderTraceabilityType::serialize(boundedList.at(i), node, MissionDefinitionMDT_Names::OrderTraceability_Name);
    }
  }
  {
    const uci::type::MissionDefinitionMDT::MissionType& boundedList = accessor.getMissionType();
    for (uci::type::MissionDefinitionMDT::MissionType::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::util::SerializationHelpers::serializeString(boundedList.at(i), node, MissionDefinitionMDT_Names::MissionType_Name);
    }
  }
  MissionStateEnum::serialize(accessor.getMissionState(), node, MissionDefinitionMDT_Names::MissionState_Name, false);
  if (accessor.hasTimeSpan()) {
    DateTimeRangeType::serialize(accessor.getTimeSpan(), node, MissionDefinitionMDT_Names::TimeSpan_Name);
  }
  asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getExpired(), node, MissionDefinitionMDT_Names::Expired_Name);
  {
    const uci::type::MissionDefinitionMDT::AuthorizedSystemID& boundedList = accessor.getAuthorizedSystemID();
    for (uci::type::MissionDefinitionMDT::AuthorizedSystemID::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::SystemID_Type::serialize(boundedList.at(i), node, MissionDefinitionMDT_Names::AuthorizedSystemID_Name);
    }
  }
  {
    const uci::type::MissionDefinitionMDT::AuthorizedUserIdentifier& boundedList = accessor.getAuthorizedUserIdentifier();
    for (uci::type::MissionDefinitionMDT::AuthorizedUserIdentifier::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::util::SerializationHelpers::serializeString(boundedList.at(i), node, MissionDefinitionMDT_Names::AuthorizedUserIdentifier_Name);
    }
  }
  if (accessor.hasArchiveConfiguration()) {
    ArchiveRequestType::serialize(accessor.getArchiveConfiguration(), node, MissionDefinitionMDT_Names::ArchiveConfiguration_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::MissionDefinitionMDT>().release());
}

uci::type::MissionDefinitionMDT& MissionDefinitionMDT::create(const uci::type::MissionDefinitionMDT& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::MissionDefinitionMDT> newAccessor{boost::make_unique<asb_uci::type::MissionDefinitionMDT>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void MissionDefinitionMDT::destroy(uci::type::MissionDefinitionMDT& accessor) {
  delete dynamic_cast<asb_uci::type::MissionDefinitionMDT*>(&accessor);
}

} // namespace type

} // namespace uci

