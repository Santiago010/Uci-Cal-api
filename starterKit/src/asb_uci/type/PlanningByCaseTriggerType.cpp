/** @file PlanningByCaseTriggerType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:14 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/PlanningByCaseTriggerType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/CapabilityTaxonomyType.h"
#include "asb_uci/type/CommsLostTriggerDataType.h"
#include "asb_uci/type/EmptyType.h"
#include "asb_uci/type/EnduranceType.h"
#include "asb_uci/type/PlanVulnerabilityType.h"
#include "asb_uci/type/RequirementFailedTriggerType.h"
#include "asb_uci/type/RequirementTriggerType.h"
#include "asb_uci/type/ResponseID_Type.h"
#include "asb_uci/type/SatelliteEnduranceType.h"
#include "asb_uci/type/SystemStateFilterType.h"
#include "asb_uci/type/ThresholdOffOrbitTriggerDataType.h"
#include "asb_uci/type/ThresholdOffRouteTriggerDataType.h"
#include "asb_uci/type/ZoneViolationTriggerDataType.h"
#include "asb_uci/util/DerivedTypesDeserializer.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/CapabilityTaxonomyType.h"
#include "uci/type/CommsLostTriggerDataType.h"
#include "uci/type/EmptyType.h"
#include "uci/type/EnduranceType.h"
#include "uci/type/PlanVulnerabilityType.h"
#include "uci/type/PlanningByCaseTriggerType.h"
#include "uci/type/RequirementFailedTriggerType.h"
#include "uci/type/RequirementTriggerType.h"
#include "uci/type/ResponseID_Type.h"
#include "uci/type/SatelliteEnduranceType.h"
#include "uci/type/SystemStateFilterType.h"
#include "uci/type/ThresholdOffOrbitTriggerDataType.h"
#include "uci/type/ThresholdOffRouteTriggerDataType.h"
#include "uci/type/ZoneViolationTriggerDataType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

PlanningByCaseTriggerType::PlanningByCaseTriggerType() = default;

PlanningByCaseTriggerType::~PlanningByCaseTriggerType() = default;

void PlanningByCaseTriggerType::copy(const uci::type::PlanningByCaseTriggerType& accessor) {
  copyImpl(accessor, false);
}

void PlanningByCaseTriggerType::copyImpl(const uci::type::PlanningByCaseTriggerType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const PlanningByCaseTriggerType&>(accessor);
    if (accessorImpl.capabilityAdded_Accessor) {
      setCapabilityAdded(*(accessorImpl.capabilityAdded_Accessor));
    } else {
      capabilityAdded_Accessor.reset();
    }
    if (accessorImpl.capabilityFailure_Accessor) {
      setCapabilityFailure(*(accessorImpl.capabilityFailure_Accessor));
    } else {
      capabilityFailure_Accessor.reset();
    }
    if (accessorImpl.commsLost_Accessor) {
      setCommsLost(*(accessorImpl.commsLost_Accessor));
    } else {
      commsLost_Accessor.reset();
    }
    if (accessorImpl.dMPI_OverDesignation_Accessor) {
      setDMPI_OverDesignation(*(accessorImpl.dMPI_OverDesignation_Accessor));
    } else {
      dMPI_OverDesignation_Accessor.reset();
    }
    if (accessorImpl.dMPI_UnderDesignation_Accessor) {
      setDMPI_UnderDesignation(*(accessorImpl.dMPI_UnderDesignation_Accessor));
    } else {
      dMPI_UnderDesignation_Accessor.reset();
    }
    if (accessorImpl.enduranceLow_Accessor) {
      setEnduranceLow(*(accessorImpl.enduranceLow_Accessor));
    } else {
      enduranceLow_Accessor.reset();
    }
    if (accessorImpl.offRoute_Accessor) {
      setOffRoute(*(accessorImpl.offRoute_Accessor));
    } else {
      offRoute_Accessor.reset();
    }
    if (accessorImpl.proximityConflict_Accessor) {
      setProximityConflict(*(accessorImpl.proximityConflict_Accessor));
    } else {
      proximityConflict_Accessor.reset();
    }
    if (accessorImpl.releasePointOutsideLAR_Accessor) {
      setReleasePointOutsideLAR(*(accessorImpl.releasePointOutsideLAR_Accessor));
    } else {
      releasePointOutsideLAR_Accessor.reset();
    }
    if (accessorImpl.routeConflict_Accessor) {
      setRouteConflict(*(accessorImpl.routeConflict_Accessor));
    } else {
      routeConflict_Accessor.reset();
    }
    if (accessorImpl.routeVulnerability_Accessor) {
      setRouteVulnerability(*(accessorImpl.routeVulnerability_Accessor));
    } else {
      routeVulnerability_Accessor.reset();
    }
    if (accessorImpl.systemStateChange_Accessor) {
      setSystemStateChange(*(accessorImpl.systemStateChange_Accessor));
    } else {
      systemStateChange_Accessor.reset();
    }
    if (accessorImpl.requirementAdded_Accessor) {
      setRequirementAdded(*(accessorImpl.requirementAdded_Accessor));
    } else {
      requirementAdded_Accessor.reset();
    }
    if (accessorImpl.requirementDependencyFailed_Accessor) {
      setRequirementDependencyFailed(*(accessorImpl.requirementDependencyFailed_Accessor));
    } else {
      requirementDependencyFailed_Accessor.reset();
    }
    if (accessorImpl.requirementDropped_Accessor) {
      setRequirementDropped(*(accessorImpl.requirementDropped_Accessor));
    } else {
      requirementDropped_Accessor.reset();
    }
    if (accessorImpl.requirementFailed_Accessor) {
      setRequirementFailed(*(accessorImpl.requirementFailed_Accessor));
    } else {
      requirementFailed_Accessor.reset();
    }
    if (accessorImpl.requirementChange_Accessor) {
      setRequirementChange(*(accessorImpl.requirementChange_Accessor));
    } else {
      requirementChange_Accessor.reset();
    }
    if (accessorImpl.requirementTiming_Accessor) {
      setRequirementTiming(*(accessorImpl.requirementTiming_Accessor));
    } else {
      requirementTiming_Accessor.reset();
    }
    if (accessorImpl.zoneViolation_Accessor) {
      setZoneViolation(*(accessorImpl.zoneViolation_Accessor));
    } else {
      zoneViolation_Accessor.reset();
    }
    if (accessorImpl.orbitConflict_Accessor) {
      setOrbitConflict(*(accessorImpl.orbitConflict_Accessor));
    } else {
      orbitConflict_Accessor.reset();
    }
    if (accessorImpl.offPlannedOrbit_Accessor) {
      setOffPlannedOrbit(*(accessorImpl.offPlannedOrbit_Accessor));
    } else {
      offPlannedOrbit_Accessor.reset();
    }
    if (accessorImpl.spacecraftEnduranceLow_Accessor) {
      setSpacecraftEnduranceLow(*(accessorImpl.spacecraftEnduranceLow_Accessor));
    } else {
      spacecraftEnduranceLow_Accessor.reset();
    }
    if (accessorImpl.spacecraftProximityConflict_Accessor) {
      setSpacecraftProximityConflict(*(accessorImpl.spacecraftProximityConflict_Accessor));
    } else {
      spacecraftProximityConflict_Accessor.reset();
    }
    if (accessorImpl.responseID_Accessor) {
      setResponseID(*(accessorImpl.responseID_Accessor));
    } else {
      responseID_Accessor.reset();
    }
  }
}

void PlanningByCaseTriggerType::reset() noexcept {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
}

uci::type::PlanningByCaseTriggerType::PlanningByCaseTriggerTypeChoice PlanningByCaseTriggerType::getPlanningByCaseTriggerTypeChoiceOrdinal() const noexcept {
  if (capabilityAdded_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_CAPABILITYADDED;
  }
  if (capabilityFailure_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_CAPABILITYFAILURE;
  }
  if (commsLost_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_COMMSLOST;
  }
  if (dMPI_OverDesignation_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_DMPI_OVERDESIGNATION;
  }
  if (dMPI_UnderDesignation_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_DMPI_UNDERDESIGNATION;
  }
  if (enduranceLow_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_ENDURANCELOW;
  }
  if (offRoute_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_OFFROUTE;
  }
  if (proximityConflict_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_PROXIMITYCONFLICT;
  }
  if (releasePointOutsideLAR_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_RELEASEPOINTOUTSIDELAR;
  }
  if (routeConflict_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_ROUTECONFLICT;
  }
  if (routeVulnerability_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_ROUTEVULNERABILITY;
  }
  if (systemStateChange_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_SYSTEMSTATECHANGE;
  }
  if (requirementAdded_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTADDED;
  }
  if (requirementDependencyFailed_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTDEPENDENCYFAILED;
  }
  if (requirementDropped_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTDROPPED;
  }
  if (requirementFailed_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTFAILED;
  }
  if (requirementChange_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTCHANGE;
  }
  if (requirementTiming_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTTIMING;
  }
  if (zoneViolation_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_ZONEVIOLATION;
  }
  if (orbitConflict_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_ORBITCONFLICT;
  }
  if (offPlannedOrbit_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_OFFPLANNEDORBIT;
  }
  if (spacecraftEnduranceLow_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_SPACECRAFTENDURANCELOW;
  }
  if (spacecraftProximityConflict_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_SPACECRAFTPROXIMITYCONFLICT;
  }
  if (responseID_Accessor) {
    return PLANNINGBYCASETRIGGERTYPE_CHOICE_RESPONSEID;
  }
  return PLANNINGBYCASETRIGGERTYPE_CHOICE_NONE;
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setPlanningByCaseTriggerTypeChoiceOrdinal(uci::type::PlanningByCaseTriggerType::PlanningByCaseTriggerTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_CAPABILITYADDED:
      chooseCapabilityAdded("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_CAPABILITYFAILURE:
      chooseCapabilityFailure("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_COMMSLOST:
      chooseCommsLost("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_DMPI_OVERDESIGNATION:
      chooseDMPI_OverDesignation("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_DMPI_UNDERDESIGNATION:
      chooseDMPI_UnderDesignation("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_ENDURANCELOW:
      chooseEnduranceLow("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_OFFROUTE:
      chooseOffRoute("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_PROXIMITYCONFLICT:
      chooseProximityConflict("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_RELEASEPOINTOUTSIDELAR:
      chooseReleasePointOutsideLAR("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_ROUTECONFLICT:
      chooseRouteConflict("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_ROUTEVULNERABILITY:
      chooseRouteVulnerability("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_SYSTEMSTATECHANGE:
      chooseSystemStateChange("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTADDED:
      chooseRequirementAdded("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTDEPENDENCYFAILED:
      chooseRequirementDependencyFailed("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTDROPPED:
      chooseRequirementDropped("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTFAILED:
      chooseRequirementFailed("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTCHANGE:
      chooseRequirementChange("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_REQUIREMENTTIMING:
      chooseRequirementTiming("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_ZONEVIOLATION:
      chooseZoneViolation("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_ORBITCONFLICT:
      chooseOrbitConflict("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_OFFPLANNEDORBIT:
      chooseOffPlannedOrbit("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_SPACECRAFTENDURANCELOW:
      chooseSpacecraftEnduranceLow("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_SPACECRAFTPROXIMITYCONFLICT:
      chooseSpacecraftProximityConflict("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    case PLANNINGBYCASETRIGGERTYPE_CHOICE_RESPONSEID:
      chooseResponseID("setPlanningByCaseTriggerTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setPlanningByCaseTriggerTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::getCapabilityAdded_() const {
  if (capabilityAdded_Accessor) {
    return *capabilityAdded_Accessor;
  }
  throw uci::base::UCIException("Error in getCapabilityAdded(): Unable to get CapabilityAdded, field not selected");
}

const uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::getCapabilityAdded() const {
  return getCapabilityAdded_();
}

uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::getCapabilityAdded() {
  return getCapabilityAdded_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setCapabilityAdded(const uci::type::CapabilityTaxonomyType& accessor) {
  chooseCapabilityAdded();
  if (&accessor != capabilityAdded_Accessor.get()) {
    capabilityAdded_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isCapabilityAdded() const noexcept {
  return static_cast<bool>(capabilityAdded_Accessor);
}

uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::chooseCapabilityAdded(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::capabilityTaxonomyType : type};
  if ((!capabilityAdded_Accessor) || (capabilityAdded_Accessor->getAccessorType() != requestedType)) {
    capabilityAdded_Accessor = CapabilityTaxonomyType::create(type);
    if (!capabilityAdded_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *capabilityAdded_Accessor;
}

uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::chooseCapabilityAdded(uci::base::accessorType::AccessorType type) {
  return chooseCapabilityAdded("chooseCapabilityAdded", type);
}

uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::getCapabilityFailure_() const {
  if (capabilityFailure_Accessor) {
    return *capabilityFailure_Accessor;
  }
  throw uci::base::UCIException("Error in getCapabilityFailure(): Unable to get CapabilityFailure, field not selected");
}

const uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::getCapabilityFailure() const {
  return getCapabilityFailure_();
}

uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::getCapabilityFailure() {
  return getCapabilityFailure_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setCapabilityFailure(const uci::type::CapabilityTaxonomyType& accessor) {
  chooseCapabilityFailure();
  if (&accessor != capabilityFailure_Accessor.get()) {
    capabilityFailure_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isCapabilityFailure() const noexcept {
  return static_cast<bool>(capabilityFailure_Accessor);
}

uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::chooseCapabilityFailure(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::capabilityTaxonomyType : type};
  if ((!capabilityFailure_Accessor) || (capabilityFailure_Accessor->getAccessorType() != requestedType)) {
    capabilityFailure_Accessor = CapabilityTaxonomyType::create(type);
    if (!capabilityFailure_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *capabilityFailure_Accessor;
}

uci::type::CapabilityTaxonomyType& PlanningByCaseTriggerType::chooseCapabilityFailure(uci::base::accessorType::AccessorType type) {
  return chooseCapabilityFailure("chooseCapabilityFailure", type);
}

uci::type::CommsLostTriggerDataType& PlanningByCaseTriggerType::getCommsLost_() const {
  if (commsLost_Accessor) {
    return *commsLost_Accessor;
  }
  throw uci::base::UCIException("Error in getCommsLost(): Unable to get CommsLost, field not selected");
}

const uci::type::CommsLostTriggerDataType& PlanningByCaseTriggerType::getCommsLost() const {
  return getCommsLost_();
}

uci::type::CommsLostTriggerDataType& PlanningByCaseTriggerType::getCommsLost() {
  return getCommsLost_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setCommsLost(const uci::type::CommsLostTriggerDataType& accessor) {
  chooseCommsLost();
  if (&accessor != commsLost_Accessor.get()) {
    commsLost_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isCommsLost() const noexcept {
  return static_cast<bool>(commsLost_Accessor);
}

uci::type::CommsLostTriggerDataType& PlanningByCaseTriggerType::chooseCommsLost(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commsLostTriggerDataType : type};
  if ((!commsLost_Accessor) || (commsLost_Accessor->getAccessorType() != requestedType)) {
    commsLost_Accessor = CommsLostTriggerDataType::create(type);
    if (!commsLost_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *commsLost_Accessor;
}

uci::type::CommsLostTriggerDataType& PlanningByCaseTriggerType::chooseCommsLost(uci::base::accessorType::AccessorType type) {
  return chooseCommsLost("chooseCommsLost", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getDMPI_OverDesignation_() const {
  if (dMPI_OverDesignation_Accessor) {
    return *dMPI_OverDesignation_Accessor;
  }
  throw uci::base::UCIException("Error in getDMPI_OverDesignation(): An attempt was made to get an optional field that was not enabled, call hasDMPI_OverDesignation() to determine if it is safe to call getDMPI_OverDesignation()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getDMPI_OverDesignation() const {
  return getDMPI_OverDesignation_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getDMPI_OverDesignation() {
  return getDMPI_OverDesignation_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setDMPI_OverDesignation(const uci::type::EmptyType& value) {
  return setDMPI_OverDesignation(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setDMPI_OverDesignation(const std::string& value) {
  return setDMPI_OverDesignation(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setDMPI_OverDesignation(const char * value) {
  chooseDMPI_OverDesignation().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isDMPI_OverDesignation() const noexcept {
  return static_cast<bool>(dMPI_OverDesignation_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseDMPI_OverDesignation(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  if (!dMPI_OverDesignation_Accessor) {
    dMPI_OverDesignation_Accessor = EmptyType::create(type);
  }
  return *dMPI_OverDesignation_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseDMPI_OverDesignation(uci::base::accessorType::AccessorType type) {
  return chooseDMPI_OverDesignation("chooseDMPI_OverDesignation", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getDMPI_UnderDesignation_() const {
  if (dMPI_UnderDesignation_Accessor) {
    return *dMPI_UnderDesignation_Accessor;
  }
  throw uci::base::UCIException("Error in getDMPI_UnderDesignation(): An attempt was made to get an optional field that was not enabled, call hasDMPI_UnderDesignation() to determine if it is safe to call getDMPI_UnderDesignation()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getDMPI_UnderDesignation() const {
  return getDMPI_UnderDesignation_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getDMPI_UnderDesignation() {
  return getDMPI_UnderDesignation_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setDMPI_UnderDesignation(const uci::type::EmptyType& value) {
  return setDMPI_UnderDesignation(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setDMPI_UnderDesignation(const std::string& value) {
  return setDMPI_UnderDesignation(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setDMPI_UnderDesignation(const char * value) {
  chooseDMPI_UnderDesignation().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isDMPI_UnderDesignation() const noexcept {
  return static_cast<bool>(dMPI_UnderDesignation_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseDMPI_UnderDesignation(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  if (!dMPI_UnderDesignation_Accessor) {
    dMPI_UnderDesignation_Accessor = EmptyType::create(type);
  }
  return *dMPI_UnderDesignation_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseDMPI_UnderDesignation(uci::base::accessorType::AccessorType type) {
  return chooseDMPI_UnderDesignation("chooseDMPI_UnderDesignation", type);
}

uci::type::EnduranceType& PlanningByCaseTriggerType::getEnduranceLow_() const {
  if (enduranceLow_Accessor) {
    return *enduranceLow_Accessor;
  }
  throw uci::base::UCIException("Error in getEnduranceLow(): Unable to get EnduranceLow, field not selected");
}

const uci::type::EnduranceType& PlanningByCaseTriggerType::getEnduranceLow() const {
  return getEnduranceLow_();
}

uci::type::EnduranceType& PlanningByCaseTriggerType::getEnduranceLow() {
  return getEnduranceLow_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setEnduranceLow(const uci::type::EnduranceType& accessor) {
  chooseEnduranceLow();
  if (&accessor != enduranceLow_Accessor.get()) {
    enduranceLow_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isEnduranceLow() const noexcept {
  return static_cast<bool>(enduranceLow_Accessor);
}

uci::type::EnduranceType& PlanningByCaseTriggerType::chooseEnduranceLow(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::enduranceType : type};
  if ((!enduranceLow_Accessor) || (enduranceLow_Accessor->getAccessorType() != requestedType)) {
    enduranceLow_Accessor = EnduranceType::create(type);
    if (!enduranceLow_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *enduranceLow_Accessor;
}

uci::type::EnduranceType& PlanningByCaseTriggerType::chooseEnduranceLow(uci::base::accessorType::AccessorType type) {
  return chooseEnduranceLow("chooseEnduranceLow", type);
}

uci::type::ThresholdOffRouteTriggerDataType& PlanningByCaseTriggerType::getOffRoute_() const {
  if (offRoute_Accessor) {
    return *offRoute_Accessor;
  }
  throw uci::base::UCIException("Error in getOffRoute(): Unable to get OffRoute, field not selected");
}

const uci::type::ThresholdOffRouteTriggerDataType& PlanningByCaseTriggerType::getOffRoute() const {
  return getOffRoute_();
}

uci::type::ThresholdOffRouteTriggerDataType& PlanningByCaseTriggerType::getOffRoute() {
  return getOffRoute_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setOffRoute(const uci::type::ThresholdOffRouteTriggerDataType& accessor) {
  chooseOffRoute();
  if (&accessor != offRoute_Accessor.get()) {
    offRoute_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isOffRoute() const noexcept {
  return static_cast<bool>(offRoute_Accessor);
}

uci::type::ThresholdOffRouteTriggerDataType& PlanningByCaseTriggerType::chooseOffRoute(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::thresholdOffRouteTriggerDataType : type};
  if ((!offRoute_Accessor) || (offRoute_Accessor->getAccessorType() != requestedType)) {
    offRoute_Accessor = ThresholdOffRouteTriggerDataType::create(type);
    if (!offRoute_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *offRoute_Accessor;
}

uci::type::ThresholdOffRouteTriggerDataType& PlanningByCaseTriggerType::chooseOffRoute(uci::base::accessorType::AccessorType type) {
  return chooseOffRoute("chooseOffRoute", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getProximityConflict_() const {
  if (proximityConflict_Accessor) {
    return *proximityConflict_Accessor;
  }
  throw uci::base::UCIException("Error in getProximityConflict(): An attempt was made to get an optional field that was not enabled, call hasProximityConflict() to determine if it is safe to call getProximityConflict()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getProximityConflict() const {
  return getProximityConflict_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getProximityConflict() {
  return getProximityConflict_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setProximityConflict(const uci::type::EmptyType& value) {
  return setProximityConflict(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setProximityConflict(const std::string& value) {
  return setProximityConflict(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setProximityConflict(const char * value) {
  chooseProximityConflict().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isProximityConflict() const noexcept {
  return static_cast<bool>(proximityConflict_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseProximityConflict(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  if (!proximityConflict_Accessor) {
    proximityConflict_Accessor = EmptyType::create(type);
  }
  return *proximityConflict_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseProximityConflict(uci::base::accessorType::AccessorType type) {
  return chooseProximityConflict("chooseProximityConflict", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getReleasePointOutsideLAR_() const {
  if (releasePointOutsideLAR_Accessor) {
    return *releasePointOutsideLAR_Accessor;
  }
  throw uci::base::UCIException("Error in getReleasePointOutsideLAR(): An attempt was made to get an optional field that was not enabled, call hasReleasePointOutsideLAR() to determine if it is safe to call getReleasePointOutsideLAR()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getReleasePointOutsideLAR() const {
  return getReleasePointOutsideLAR_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getReleasePointOutsideLAR() {
  return getReleasePointOutsideLAR_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setReleasePointOutsideLAR(const uci::type::EmptyType& value) {
  return setReleasePointOutsideLAR(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setReleasePointOutsideLAR(const std::string& value) {
  return setReleasePointOutsideLAR(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setReleasePointOutsideLAR(const char * value) {
  chooseReleasePointOutsideLAR().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isReleasePointOutsideLAR() const noexcept {
  return static_cast<bool>(releasePointOutsideLAR_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseReleasePointOutsideLAR(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  if (!releasePointOutsideLAR_Accessor) {
    releasePointOutsideLAR_Accessor = EmptyType::create(type);
  }
  return *releasePointOutsideLAR_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseReleasePointOutsideLAR(uci::base::accessorType::AccessorType type) {
  return chooseReleasePointOutsideLAR("chooseReleasePointOutsideLAR", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getRouteConflict_() const {
  if (routeConflict_Accessor) {
    return *routeConflict_Accessor;
  }
  throw uci::base::UCIException("Error in getRouteConflict(): An attempt was made to get an optional field that was not enabled, call hasRouteConflict() to determine if it is safe to call getRouteConflict()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getRouteConflict() const {
  return getRouteConflict_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getRouteConflict() {
  return getRouteConflict_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRouteConflict(const uci::type::EmptyType& value) {
  return setRouteConflict(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRouteConflict(const std::string& value) {
  return setRouteConflict(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRouteConflict(const char * value) {
  chooseRouteConflict().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isRouteConflict() const noexcept {
  return static_cast<bool>(routeConflict_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseRouteConflict(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  if (!routeConflict_Accessor) {
    routeConflict_Accessor = EmptyType::create(type);
  }
  return *routeConflict_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseRouteConflict(uci::base::accessorType::AccessorType type) {
  return chooseRouteConflict("chooseRouteConflict", type);
}

uci::type::PlanVulnerabilityType& PlanningByCaseTriggerType::getRouteVulnerability_() const {
  if (routeVulnerability_Accessor) {
    return *routeVulnerability_Accessor;
  }
  throw uci::base::UCIException("Error in getRouteVulnerability(): Unable to get RouteVulnerability, field not selected");
}

const uci::type::PlanVulnerabilityType& PlanningByCaseTriggerType::getRouteVulnerability() const {
  return getRouteVulnerability_();
}

uci::type::PlanVulnerabilityType& PlanningByCaseTriggerType::getRouteVulnerability() {
  return getRouteVulnerability_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRouteVulnerability(const uci::type::PlanVulnerabilityType& accessor) {
  chooseRouteVulnerability();
  if (&accessor != routeVulnerability_Accessor.get()) {
    routeVulnerability_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isRouteVulnerability() const noexcept {
  return static_cast<bool>(routeVulnerability_Accessor);
}

uci::type::PlanVulnerabilityType& PlanningByCaseTriggerType::chooseRouteVulnerability(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::planVulnerabilityType : type};
  if ((!routeVulnerability_Accessor) || (routeVulnerability_Accessor->getAccessorType() != requestedType)) {
    routeVulnerability_Accessor = PlanVulnerabilityType::create(type);
    if (!routeVulnerability_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *routeVulnerability_Accessor;
}

uci::type::PlanVulnerabilityType& PlanningByCaseTriggerType::chooseRouteVulnerability(uci::base::accessorType::AccessorType type) {
  return chooseRouteVulnerability("chooseRouteVulnerability", type);
}

uci::type::SystemStateFilterType& PlanningByCaseTriggerType::getSystemStateChange_() const {
  if (systemStateChange_Accessor) {
    return *systemStateChange_Accessor;
  }
  throw uci::base::UCIException("Error in getSystemStateChange(): Unable to get SystemStateChange, field not selected");
}

const uci::type::SystemStateFilterType& PlanningByCaseTriggerType::getSystemStateChange() const {
  return getSystemStateChange_();
}

uci::type::SystemStateFilterType& PlanningByCaseTriggerType::getSystemStateChange() {
  return getSystemStateChange_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setSystemStateChange(const uci::type::SystemStateFilterType& accessor) {
  chooseSystemStateChange();
  if (&accessor != systemStateChange_Accessor.get()) {
    systemStateChange_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isSystemStateChange() const noexcept {
  return static_cast<bool>(systemStateChange_Accessor);
}

uci::type::SystemStateFilterType& PlanningByCaseTriggerType::chooseSystemStateChange(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::systemStateFilterType : type};
  if ((!systemStateChange_Accessor) || (systemStateChange_Accessor->getAccessorType() != requestedType)) {
    systemStateChange_Accessor = SystemStateFilterType::create(type);
    if (!systemStateChange_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *systemStateChange_Accessor;
}

uci::type::SystemStateFilterType& PlanningByCaseTriggerType::chooseSystemStateChange(uci::base::accessorType::AccessorType type) {
  return chooseSystemStateChange("chooseSystemStateChange", type);
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementAdded_() const {
  if (requirementAdded_Accessor) {
    return *requirementAdded_Accessor;
  }
  throw uci::base::UCIException("Error in getRequirementAdded(): Unable to get RequirementAdded, field not selected");
}

const uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementAdded() const {
  return getRequirementAdded_();
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementAdded() {
  return getRequirementAdded_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementAdded(const uci::type::RequirementTriggerType& accessor) {
  chooseRequirementAdded("setRequirementAdded", accessor.getAccessorType());
  if (&accessor != requirementAdded_Accessor.get()) {
    requirementAdded_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isRequirementAdded() const noexcept {
  return static_cast<bool>(requirementAdded_Accessor);
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::chooseRequirementAdded(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementTriggerType : type};
  if ((!requirementAdded_Accessor) || (requirementAdded_Accessor->getAccessorType() != requestedType)) {
    requirementAdded_Accessor = RequirementTriggerType::create(type);
    if (!requirementAdded_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *requirementAdded_Accessor;
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::chooseRequirementAdded(uci::base::accessorType::AccessorType type) {
  return chooseRequirementAdded("chooseRequirementAdded", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getRequirementDependencyFailed_() const {
  if (requirementDependencyFailed_Accessor) {
    return *requirementDependencyFailed_Accessor;
  }
  throw uci::base::UCIException("Error in getRequirementDependencyFailed(): An attempt was made to get an optional field that was not enabled, call hasRequirementDependencyFailed() to determine if it is safe to call getRequirementDependencyFailed()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getRequirementDependencyFailed() const {
  return getRequirementDependencyFailed_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getRequirementDependencyFailed() {
  return getRequirementDependencyFailed_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementDependencyFailed(const uci::type::EmptyType& value) {
  return setRequirementDependencyFailed(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementDependencyFailed(const std::string& value) {
  return setRequirementDependencyFailed(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementDependencyFailed(const char * value) {
  chooseRequirementDependencyFailed().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isRequirementDependencyFailed() const noexcept {
  return static_cast<bool>(requirementDependencyFailed_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseRequirementDependencyFailed(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  if (!requirementDependencyFailed_Accessor) {
    requirementDependencyFailed_Accessor = EmptyType::create(type);
  }
  return *requirementDependencyFailed_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseRequirementDependencyFailed(uci::base::accessorType::AccessorType type) {
  return chooseRequirementDependencyFailed("chooseRequirementDependencyFailed", type);
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementDropped_() const {
  if (requirementDropped_Accessor) {
    return *requirementDropped_Accessor;
  }
  throw uci::base::UCIException("Error in getRequirementDropped(): Unable to get RequirementDropped, field not selected");
}

const uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementDropped() const {
  return getRequirementDropped_();
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementDropped() {
  return getRequirementDropped_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementDropped(const uci::type::RequirementTriggerType& accessor) {
  chooseRequirementDropped("setRequirementDropped", accessor.getAccessorType());
  if (&accessor != requirementDropped_Accessor.get()) {
    requirementDropped_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isRequirementDropped() const noexcept {
  return static_cast<bool>(requirementDropped_Accessor);
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::chooseRequirementDropped(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementTriggerType : type};
  if ((!requirementDropped_Accessor) || (requirementDropped_Accessor->getAccessorType() != requestedType)) {
    requirementDropped_Accessor = RequirementTriggerType::create(type);
    if (!requirementDropped_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *requirementDropped_Accessor;
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::chooseRequirementDropped(uci::base::accessorType::AccessorType type) {
  return chooseRequirementDropped("chooseRequirementDropped", type);
}

uci::type::RequirementFailedTriggerType& PlanningByCaseTriggerType::getRequirementFailed_() const {
  if (requirementFailed_Accessor) {
    return *requirementFailed_Accessor;
  }
  throw uci::base::UCIException("Error in getRequirementFailed(): Unable to get RequirementFailed, field not selected");
}

const uci::type::RequirementFailedTriggerType& PlanningByCaseTriggerType::getRequirementFailed() const {
  return getRequirementFailed_();
}

uci::type::RequirementFailedTriggerType& PlanningByCaseTriggerType::getRequirementFailed() {
  return getRequirementFailed_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementFailed(const uci::type::RequirementFailedTriggerType& accessor) {
  chooseRequirementFailed();
  if (&accessor != requirementFailed_Accessor.get()) {
    requirementFailed_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isRequirementFailed() const noexcept {
  return static_cast<bool>(requirementFailed_Accessor);
}

uci::type::RequirementFailedTriggerType& PlanningByCaseTriggerType::chooseRequirementFailed(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementFailedTriggerType : type};
  if ((!requirementFailed_Accessor) || (requirementFailed_Accessor->getAccessorType() != requestedType)) {
    requirementFailed_Accessor = RequirementFailedTriggerType::create(type);
    if (!requirementFailed_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *requirementFailed_Accessor;
}

uci::type::RequirementFailedTriggerType& PlanningByCaseTriggerType::chooseRequirementFailed(uci::base::accessorType::AccessorType type) {
  return chooseRequirementFailed("chooseRequirementFailed", type);
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementChange_() const {
  if (requirementChange_Accessor) {
    return *requirementChange_Accessor;
  }
  throw uci::base::UCIException("Error in getRequirementChange(): Unable to get RequirementChange, field not selected");
}

const uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementChange() const {
  return getRequirementChange_();
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::getRequirementChange() {
  return getRequirementChange_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementChange(const uci::type::RequirementTriggerType& accessor) {
  chooseRequirementChange("setRequirementChange", accessor.getAccessorType());
  if (&accessor != requirementChange_Accessor.get()) {
    requirementChange_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isRequirementChange() const noexcept {
  return static_cast<bool>(requirementChange_Accessor);
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::chooseRequirementChange(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementTriggerType : type};
  if ((!requirementChange_Accessor) || (requirementChange_Accessor->getAccessorType() != requestedType)) {
    requirementChange_Accessor = RequirementTriggerType::create(type);
    if (!requirementChange_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *requirementChange_Accessor;
}

uci::type::RequirementTriggerType& PlanningByCaseTriggerType::chooseRequirementChange(uci::base::accessorType::AccessorType type) {
  return chooseRequirementChange("chooseRequirementChange", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getRequirementTiming_() const {
  if (requirementTiming_Accessor) {
    return *requirementTiming_Accessor;
  }
  throw uci::base::UCIException("Error in getRequirementTiming(): An attempt was made to get an optional field that was not enabled, call hasRequirementTiming() to determine if it is safe to call getRequirementTiming()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getRequirementTiming() const {
  return getRequirementTiming_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getRequirementTiming() {
  return getRequirementTiming_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementTiming(const uci::type::EmptyType& value) {
  return setRequirementTiming(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementTiming(const std::string& value) {
  return setRequirementTiming(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setRequirementTiming(const char * value) {
  chooseRequirementTiming().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isRequirementTiming() const noexcept {
  return static_cast<bool>(requirementTiming_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseRequirementTiming(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  if (!requirementTiming_Accessor) {
    requirementTiming_Accessor = EmptyType::create(type);
  }
  return *requirementTiming_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseRequirementTiming(uci::base::accessorType::AccessorType type) {
  return chooseRequirementTiming("chooseRequirementTiming", type);
}

uci::type::ZoneViolationTriggerDataType& PlanningByCaseTriggerType::getZoneViolation_() const {
  if (zoneViolation_Accessor) {
    return *zoneViolation_Accessor;
  }
  throw uci::base::UCIException("Error in getZoneViolation(): Unable to get ZoneViolation, field not selected");
}

const uci::type::ZoneViolationTriggerDataType& PlanningByCaseTriggerType::getZoneViolation() const {
  return getZoneViolation_();
}

uci::type::ZoneViolationTriggerDataType& PlanningByCaseTriggerType::getZoneViolation() {
  return getZoneViolation_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setZoneViolation(const uci::type::ZoneViolationTriggerDataType& accessor) {
  chooseZoneViolation();
  if (&accessor != zoneViolation_Accessor.get()) {
    zoneViolation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isZoneViolation() const noexcept {
  return static_cast<bool>(zoneViolation_Accessor);
}

uci::type::ZoneViolationTriggerDataType& PlanningByCaseTriggerType::chooseZoneViolation(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::zoneViolationTriggerDataType : type};
  if ((!zoneViolation_Accessor) || (zoneViolation_Accessor->getAccessorType() != requestedType)) {
    zoneViolation_Accessor = ZoneViolationTriggerDataType::create(type);
    if (!zoneViolation_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *zoneViolation_Accessor;
}

uci::type::ZoneViolationTriggerDataType& PlanningByCaseTriggerType::chooseZoneViolation(uci::base::accessorType::AccessorType type) {
  return chooseZoneViolation("chooseZoneViolation", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getOrbitConflict_() const {
  if (orbitConflict_Accessor) {
    return *orbitConflict_Accessor;
  }
  throw uci::base::UCIException("Error in getOrbitConflict(): An attempt was made to get an optional field that was not enabled, call hasOrbitConflict() to determine if it is safe to call getOrbitConflict()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getOrbitConflict() const {
  return getOrbitConflict_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getOrbitConflict() {
  return getOrbitConflict_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setOrbitConflict(const uci::type::EmptyType& value) {
  return setOrbitConflict(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setOrbitConflict(const std::string& value) {
  return setOrbitConflict(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setOrbitConflict(const char * value) {
  chooseOrbitConflict().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isOrbitConflict() const noexcept {
  return static_cast<bool>(orbitConflict_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseOrbitConflict(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  if (!orbitConflict_Accessor) {
    orbitConflict_Accessor = EmptyType::create(type);
  }
  return *orbitConflict_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseOrbitConflict(uci::base::accessorType::AccessorType type) {
  return chooseOrbitConflict("chooseOrbitConflict", type);
}

uci::type::ThresholdOffOrbitTriggerDataType& PlanningByCaseTriggerType::getOffPlannedOrbit_() const {
  if (offPlannedOrbit_Accessor) {
    return *offPlannedOrbit_Accessor;
  }
  throw uci::base::UCIException("Error in getOffPlannedOrbit(): Unable to get OffPlannedOrbit, field not selected");
}

const uci::type::ThresholdOffOrbitTriggerDataType& PlanningByCaseTriggerType::getOffPlannedOrbit() const {
  return getOffPlannedOrbit_();
}

uci::type::ThresholdOffOrbitTriggerDataType& PlanningByCaseTriggerType::getOffPlannedOrbit() {
  return getOffPlannedOrbit_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setOffPlannedOrbit(const uci::type::ThresholdOffOrbitTriggerDataType& accessor) {
  chooseOffPlannedOrbit();
  if (&accessor != offPlannedOrbit_Accessor.get()) {
    offPlannedOrbit_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isOffPlannedOrbit() const noexcept {
  return static_cast<bool>(offPlannedOrbit_Accessor);
}

uci::type::ThresholdOffOrbitTriggerDataType& PlanningByCaseTriggerType::chooseOffPlannedOrbit(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::thresholdOffOrbitTriggerDataType : type};
  if ((!offPlannedOrbit_Accessor) || (offPlannedOrbit_Accessor->getAccessorType() != requestedType)) {
    offPlannedOrbit_Accessor = ThresholdOffOrbitTriggerDataType::create(type);
    if (!offPlannedOrbit_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *offPlannedOrbit_Accessor;
}

uci::type::ThresholdOffOrbitTriggerDataType& PlanningByCaseTriggerType::chooseOffPlannedOrbit(uci::base::accessorType::AccessorType type) {
  return chooseOffPlannedOrbit("chooseOffPlannedOrbit", type);
}

uci::type::SatelliteEnduranceType& PlanningByCaseTriggerType::getSpacecraftEnduranceLow_() const {
  if (spacecraftEnduranceLow_Accessor) {
    return *spacecraftEnduranceLow_Accessor;
  }
  throw uci::base::UCIException("Error in getSpacecraftEnduranceLow(): Unable to get SpacecraftEnduranceLow, field not selected");
}

const uci::type::SatelliteEnduranceType& PlanningByCaseTriggerType::getSpacecraftEnduranceLow() const {
  return getSpacecraftEnduranceLow_();
}

uci::type::SatelliteEnduranceType& PlanningByCaseTriggerType::getSpacecraftEnduranceLow() {
  return getSpacecraftEnduranceLow_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setSpacecraftEnduranceLow(const uci::type::SatelliteEnduranceType& accessor) {
  chooseSpacecraftEnduranceLow();
  if (&accessor != spacecraftEnduranceLow_Accessor.get()) {
    spacecraftEnduranceLow_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isSpacecraftEnduranceLow() const noexcept {
  return static_cast<bool>(spacecraftEnduranceLow_Accessor);
}

uci::type::SatelliteEnduranceType& PlanningByCaseTriggerType::chooseSpacecraftEnduranceLow(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  responseID_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::satelliteEnduranceType : type};
  if ((!spacecraftEnduranceLow_Accessor) || (spacecraftEnduranceLow_Accessor->getAccessorType() != requestedType)) {
    spacecraftEnduranceLow_Accessor = SatelliteEnduranceType::create(type);
    if (!spacecraftEnduranceLow_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *spacecraftEnduranceLow_Accessor;
}

uci::type::SatelliteEnduranceType& PlanningByCaseTriggerType::chooseSpacecraftEnduranceLow(uci::base::accessorType::AccessorType type) {
  return chooseSpacecraftEnduranceLow("chooseSpacecraftEnduranceLow", type);
}

uci::type::EmptyType& PlanningByCaseTriggerType::getSpacecraftProximityConflict_() const {
  if (spacecraftProximityConflict_Accessor) {
    return *spacecraftProximityConflict_Accessor;
  }
  throw uci::base::UCIException("Error in getSpacecraftProximityConflict(): An attempt was made to get an optional field that was not enabled, call hasSpacecraftProximityConflict() to determine if it is safe to call getSpacecraftProximityConflict()");
}

const uci::type::EmptyType& PlanningByCaseTriggerType::getSpacecraftProximityConflict() const {
  return getSpacecraftProximityConflict_();
}

uci::type::EmptyType& PlanningByCaseTriggerType::getSpacecraftProximityConflict() {
  return getSpacecraftProximityConflict_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setSpacecraftProximityConflict(const uci::type::EmptyType& value) {
  return setSpacecraftProximityConflict(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setSpacecraftProximityConflict(const std::string& value) {
  return setSpacecraftProximityConflict(value.c_str());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setSpacecraftProximityConflict(const char * value) {
  chooseSpacecraftProximityConflict().setStringValue(value);
  return *this;
}

bool PlanningByCaseTriggerType::isSpacecraftProximityConflict() const noexcept {
  return static_cast<bool>(spacecraftProximityConflict_Accessor);
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseSpacecraftProximityConflict(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  responseID_Accessor.reset();
  if (!spacecraftProximityConflict_Accessor) {
    spacecraftProximityConflict_Accessor = EmptyType::create(type);
  }
  return *spacecraftProximityConflict_Accessor;
}

uci::type::EmptyType& PlanningByCaseTriggerType::chooseSpacecraftProximityConflict(uci::base::accessorType::AccessorType type) {
  return chooseSpacecraftProximityConflict("chooseSpacecraftProximityConflict", type);
}

uci::type::ResponseID_Type& PlanningByCaseTriggerType::getResponseID_() const {
  if (responseID_Accessor) {
    return *responseID_Accessor;
  }
  throw uci::base::UCIException("Error in getResponseID(): Unable to get ResponseID, field not selected");
}

const uci::type::ResponseID_Type& PlanningByCaseTriggerType::getResponseID() const {
  return getResponseID_();
}

uci::type::ResponseID_Type& PlanningByCaseTriggerType::getResponseID() {
  return getResponseID_();
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::setResponseID(const uci::type::ResponseID_Type& accessor) {
  chooseResponseID();
  if (&accessor != responseID_Accessor.get()) {
    responseID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PlanningByCaseTriggerType::isResponseID() const noexcept {
  return static_cast<bool>(responseID_Accessor);
}

uci::type::ResponseID_Type& PlanningByCaseTriggerType::chooseResponseID(const std::string& method, uci::base::accessorType::AccessorType type) {
  capabilityAdded_Accessor.reset();
  capabilityFailure_Accessor.reset();
  commsLost_Accessor.reset();
  dMPI_OverDesignation_Accessor.reset();
  dMPI_UnderDesignation_Accessor.reset();
  enduranceLow_Accessor.reset();
  offRoute_Accessor.reset();
  proximityConflict_Accessor.reset();
  releasePointOutsideLAR_Accessor.reset();
  routeConflict_Accessor.reset();
  routeVulnerability_Accessor.reset();
  systemStateChange_Accessor.reset();
  requirementAdded_Accessor.reset();
  requirementDependencyFailed_Accessor.reset();
  requirementDropped_Accessor.reset();
  requirementFailed_Accessor.reset();
  requirementChange_Accessor.reset();
  requirementTiming_Accessor.reset();
  zoneViolation_Accessor.reset();
  orbitConflict_Accessor.reset();
  offPlannedOrbit_Accessor.reset();
  spacecraftEnduranceLow_Accessor.reset();
  spacecraftProximityConflict_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::responseID_Type : type};
  if ((!responseID_Accessor) || (responseID_Accessor->getAccessorType() != requestedType)) {
    responseID_Accessor = ResponseID_Type::create(type);
    if (!responseID_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *responseID_Accessor;
}

uci::type::ResponseID_Type& PlanningByCaseTriggerType::chooseResponseID(uci::base::accessorType::AccessorType type) {
  return chooseResponseID("chooseResponseID", type);
}

std::unique_ptr<PlanningByCaseTriggerType> PlanningByCaseTriggerType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::planningByCaseTriggerType : type};
  return (requestedType == uci::type::accessorType::planningByCaseTriggerType) ? boost::make_unique<PlanningByCaseTriggerType>() : nullptr;
}

/**  */
namespace PlanningByCaseTriggerType_Names {

constexpr const char* Extern_Type_Name{"PlanningByCaseTriggerType"};
constexpr const char* CapabilityAdded_Name{"CapabilityAdded"};
constexpr const char* CapabilityFailure_Name{"CapabilityFailure"};
constexpr const char* CommsLost_Name{"CommsLost"};
constexpr const char* DMPI_OverDesignation_Name{"DMPI_OverDesignation"};
constexpr const char* DMPI_UnderDesignation_Name{"DMPI_UnderDesignation"};
constexpr const char* EnduranceLow_Name{"EnduranceLow"};
constexpr const char* OffRoute_Name{"OffRoute"};
constexpr const char* ProximityConflict_Name{"ProximityConflict"};
constexpr const char* ReleasePointOutsideLAR_Name{"ReleasePointOutsideLAR"};
constexpr const char* RouteConflict_Name{"RouteConflict"};
constexpr const char* RouteVulnerability_Name{"RouteVulnerability"};
constexpr const char* SystemStateChange_Name{"SystemStateChange"};
constexpr const char* RequirementAdded_Name{"RequirementAdded"};
constexpr const char* RequirementDependencyFailed_Name{"RequirementDependencyFailed"};
constexpr const char* RequirementDropped_Name{"RequirementDropped"};
constexpr const char* RequirementFailed_Name{"RequirementFailed"};
constexpr const char* RequirementChange_Name{"RequirementChange"};
constexpr const char* RequirementTiming_Name{"RequirementTiming"};
constexpr const char* ZoneViolation_Name{"ZoneViolation"};
constexpr const char* OrbitConflict_Name{"OrbitConflict"};
constexpr const char* OffPlannedOrbit_Name{"OffPlannedOrbit"};
constexpr const char* SpacecraftEnduranceLow_Name{"SpacecraftEnduranceLow"};
constexpr const char* SpacecraftProximityConflict_Name{"SpacecraftProximityConflict"};
constexpr const char* ResponseID_Name{"ResponseID"};

} // namespace PlanningByCaseTriggerType_Names

void PlanningByCaseTriggerType::deserialize(const boost::property_tree::ptree& propTree, uci::type::PlanningByCaseTriggerType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = PlanningByCaseTriggerType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::CapabilityAdded_Name) {
      CapabilityTaxonomyType::deserialize(valueType.second, accessor.chooseCapabilityAdded(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::CapabilityFailure_Name) {
      CapabilityTaxonomyType::deserialize(valueType.second, accessor.chooseCapabilityFailure(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::CommsLost_Name) {
      CommsLostTriggerDataType::deserialize(valueType.second, accessor.chooseCommsLost(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::DMPI_OverDesignation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseDMPI_OverDesignation().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::DMPI_UnderDesignation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseDMPI_UnderDesignation().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::EnduranceLow_Name) {
      EnduranceType::deserialize(valueType.second, accessor.chooseEnduranceLow(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::OffRoute_Name) {
      ThresholdOffRouteTriggerDataType::deserialize(valueType.second, accessor.chooseOffRoute(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::ProximityConflict_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseProximityConflict().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::ReleasePointOutsideLAR_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseReleasePointOutsideLAR().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RouteConflict_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseRouteConflict().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RouteVulnerability_Name) {
      PlanVulnerabilityType::deserialize(valueType.second, accessor.chooseRouteVulnerability(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::SystemStateChange_Name) {
      SystemStateFilterType::deserialize(valueType.second, accessor.chooseSystemStateChange(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementAdded_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseRequirementAdded(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementDependencyFailed_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseRequirementDependencyFailed().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementDropped_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseRequirementDropped(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementFailed_Name) {
      RequirementFailedTriggerType::deserialize(valueType.second, accessor.chooseRequirementFailed(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementChange_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseRequirementChange(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::RequirementTiming_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseRequirementTiming().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::ZoneViolation_Name) {
      ZoneViolationTriggerDataType::deserialize(valueType.second, accessor.chooseZoneViolation(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::OrbitConflict_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseOrbitConflict().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::OffPlannedOrbit_Name) {
      ThresholdOffOrbitTriggerDataType::deserialize(valueType.second, accessor.chooseOffPlannedOrbit(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::SpacecraftEnduranceLow_Name) {
      SatelliteEnduranceType::deserialize(valueType.second, accessor.chooseSpacecraftEnduranceLow(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::SpacecraftProximityConflict_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseSpacecraftProximityConflict().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + PlanningByCaseTriggerType_Names::ResponseID_Name) {
      ResponseID_Type::deserialize(valueType.second, accessor.chooseResponseID(), nodeName, nsPrefix);
    }
  }
}

std::string PlanningByCaseTriggerType::serialize(const uci::type::PlanningByCaseTriggerType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? PlanningByCaseTriggerType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, PlanningByCaseTriggerType_Names::Extern_Type_Name);
  }
  if (accessor.isCapabilityAdded()) {
    CapabilityTaxonomyType::serialize(accessor.getCapabilityAdded(), node, PlanningByCaseTriggerType_Names::CapabilityAdded_Name);
  } else if (accessor.isCapabilityFailure()) {
    CapabilityTaxonomyType::serialize(accessor.getCapabilityFailure(), node, PlanningByCaseTriggerType_Names::CapabilityFailure_Name);
  } else if (accessor.isCommsLost()) {
    CommsLostTriggerDataType::serialize(accessor.getCommsLost(), node, PlanningByCaseTriggerType_Names::CommsLost_Name);
  } else if (accessor.isDMPI_OverDesignation()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getDMPI_OverDesignation(), node, PlanningByCaseTriggerType_Names::DMPI_OverDesignation_Name);
  } else if (accessor.isDMPI_UnderDesignation()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getDMPI_UnderDesignation(), node, PlanningByCaseTriggerType_Names::DMPI_UnderDesignation_Name);
  } else if (accessor.isEnduranceLow()) {
    EnduranceType::serialize(accessor.getEnduranceLow(), node, PlanningByCaseTriggerType_Names::EnduranceLow_Name);
  } else if (accessor.isOffRoute()) {
    ThresholdOffRouteTriggerDataType::serialize(accessor.getOffRoute(), node, PlanningByCaseTriggerType_Names::OffRoute_Name);
  } else if (accessor.isProximityConflict()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getProximityConflict(), node, PlanningByCaseTriggerType_Names::ProximityConflict_Name);
  } else if (accessor.isReleasePointOutsideLAR()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getReleasePointOutsideLAR(), node, PlanningByCaseTriggerType_Names::ReleasePointOutsideLAR_Name);
  } else if (accessor.isRouteConflict()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getRouteConflict(), node, PlanningByCaseTriggerType_Names::RouteConflict_Name);
  } else if (accessor.isRouteVulnerability()) {
    PlanVulnerabilityType::serialize(accessor.getRouteVulnerability(), node, PlanningByCaseTriggerType_Names::RouteVulnerability_Name);
  } else if (accessor.isSystemStateChange()) {
    SystemStateFilterType::serialize(accessor.getSystemStateChange(), node, PlanningByCaseTriggerType_Names::SystemStateChange_Name);
  } else if (accessor.isRequirementAdded()) {
    RequirementTriggerType::serialize(accessor.getRequirementAdded(), node, PlanningByCaseTriggerType_Names::RequirementAdded_Name);
  } else if (accessor.isRequirementDependencyFailed()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getRequirementDependencyFailed(), node, PlanningByCaseTriggerType_Names::RequirementDependencyFailed_Name);
  } else if (accessor.isRequirementDropped()) {
    RequirementTriggerType::serialize(accessor.getRequirementDropped(), node, PlanningByCaseTriggerType_Names::RequirementDropped_Name);
  } else if (accessor.isRequirementFailed()) {
    RequirementFailedTriggerType::serialize(accessor.getRequirementFailed(), node, PlanningByCaseTriggerType_Names::RequirementFailed_Name);
  } else if (accessor.isRequirementChange()) {
    RequirementTriggerType::serialize(accessor.getRequirementChange(), node, PlanningByCaseTriggerType_Names::RequirementChange_Name);
  } else if (accessor.isRequirementTiming()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getRequirementTiming(), node, PlanningByCaseTriggerType_Names::RequirementTiming_Name);
  } else if (accessor.isZoneViolation()) {
    ZoneViolationTriggerDataType::serialize(accessor.getZoneViolation(), node, PlanningByCaseTriggerType_Names::ZoneViolation_Name);
  } else if (accessor.isOrbitConflict()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getOrbitConflict(), node, PlanningByCaseTriggerType_Names::OrbitConflict_Name);
  } else if (accessor.isOffPlannedOrbit()) {
    ThresholdOffOrbitTriggerDataType::serialize(accessor.getOffPlannedOrbit(), node, PlanningByCaseTriggerType_Names::OffPlannedOrbit_Name);
  } else if (accessor.isSpacecraftEnduranceLow()) {
    SatelliteEnduranceType::serialize(accessor.getSpacecraftEnduranceLow(), node, PlanningByCaseTriggerType_Names::SpacecraftEnduranceLow_Name);
  } else if (accessor.isSpacecraftProximityConflict()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getSpacecraftProximityConflict(), node, PlanningByCaseTriggerType_Names::SpacecraftProximityConflict_Name);
  } else if (accessor.isResponseID()) {
    ResponseID_Type::serialize(accessor.getResponseID(), node, PlanningByCaseTriggerType_Names::ResponseID_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::PlanningByCaseTriggerType>().release());
}

uci::type::PlanningByCaseTriggerType& PlanningByCaseTriggerType::create(const uci::type::PlanningByCaseTriggerType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::PlanningByCaseTriggerType> newAccessor{boost::make_unique<asb_uci::type::PlanningByCaseTriggerType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void PlanningByCaseTriggerType::destroy(uci::type::PlanningByCaseTriggerType& accessor) {
  delete dynamic_cast<asb_uci::type::PlanningByCaseTriggerType*>(&accessor);
}

} // namespace type

} // namespace uci

