/** @file UnitType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/UnitType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/AirDefenseAreaType.h"
#include "asb_uci/type/BaseEOB_RecordType.h"
#include "asb_uci/type/CountryCodeType.h"
#include "asb_uci/type/EOB_EquipmentRecordType.h"
#include "asb_uci/type/EOB_FixedPositionType.h"
#include "asb_uci/type/ID_Type.h"
#include "asb_uci/type/OB_OperationalStatusEnum.h"
#include "asb_uci/type/OrderOfBattleTimestampsType.h"
#include "asb_uci/type/SecurityInformationType.h"
#include "asb_uci/type/StandardIdentityConfidenceType.h"
#include "asb_uci/type/String20Type.h"
#include "asb_uci/type/String4Type.h"
#include "asb_uci/type/UnitIdentityType.h"
#include "asb_uci/type/VisibleString256Type.h"
#include "asb_uci/util/DerivedTypesDeserializer.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/AirDefenseAreaType.h"
#include "uci/type/BaseEOB_RecordType.h"
#include "uci/type/CountryCodeType.h"
#include "uci/type/EOB_EquipmentRecordType.h"
#include "uci/type/EOB_FixedPositionType.h"
#include "uci/type/ID_Type.h"
#include "uci/type/OB_OperationalStatusEnum.h"
#include "uci/type/OrderOfBattleTimestampsType.h"
#include "uci/type/SecurityInformationType.h"
#include "uci/type/StandardIdentityConfidenceType.h"
#include "uci/type/String20Type.h"
#include "uci/type/String4Type.h"
#include "uci/type/UnitIdentityType.h"
#include "uci/type/UnitType.h"
#include "uci/type/VisibleString256Type.h"
#include "xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

UnitType::UnitType()
  : securityInformation_Accessor{boost::make_unique<SecurityInformationType>()},
    identity_Accessor{boost::make_unique<UnitIdentityType>()},
    site_Accessor{boost::make_unique<Site>(0, SIZE_MAX)},
    equipment_Accessor{boost::make_unique<Equipment>(0, SIZE_MAX)} {
}

UnitType::~UnitType() = default;

void UnitType::copy(const uci::type::UnitType& accessor) {
  copyImpl(accessor, false);
}

void UnitType::copyImpl(const uci::type::UnitType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const UnitType&>(accessor);
    setSecurityInformation(*(accessorImpl.securityInformation_Accessor));
    setIdentity(*(accessorImpl.identity_Accessor));
    if (accessorImpl.standardIdentity_Accessor) {
      setStandardIdentity(*(accessorImpl.standardIdentity_Accessor));
    } else {
      standardIdentity_Accessor.reset();
    }
    if (accessorImpl.countryCode_Accessor) {
      setCountryCode(*(accessorImpl.countryCode_Accessor));
    } else {
      countryCode_Accessor.reset();
    }
    if (accessorImpl.position_Accessor) {
      setPosition(*(accessorImpl.position_Accessor));
    } else {
      position_Accessor.reset();
    }
    if (accessorImpl.timestamps_Accessor) {
      setTimestamps(*(accessorImpl.timestamps_Accessor));
    } else {
      timestamps_Accessor.reset();
    }
    if (accessorImpl.hasEvaluation()) {
      setEvaluation(accessorImpl.getEvaluation());
    } else {
      clearEvaluation();
    }
    if (accessorImpl.operationalStatus_Accessor) {
      setOperationalStatus(*(accessorImpl.operationalStatus_Accessor));
    } else {
      operationalStatus_Accessor.reset();
    }
    if (accessorImpl.politicalSubdivision_Accessor) {
      setPoliticalSubdivision(*(accessorImpl.politicalSubdivision_Accessor));
    } else {
      politicalSubdivision_Accessor.reset();
    }
    if (accessorImpl.allegianceAlternate_Accessor) {
      setAllegianceAlternate(*(accessorImpl.allegianceAlternate_Accessor));
    } else {
      allegianceAlternate_Accessor.reset();
    }
    if (accessorImpl.deploymentStatus_Accessor) {
      setDeploymentStatus(*(accessorImpl.deploymentStatus_Accessor));
    } else {
      deploymentStatus_Accessor.reset();
    }
    if (accessorImpl.divisionCategory_Accessor) {
      setDivisionCategory(*(accessorImpl.divisionCategory_Accessor));
    } else {
      divisionCategory_Accessor.reset();
    }
    if (accessorImpl.echelon_Accessor) {
      setEchelon(*(accessorImpl.echelon_Accessor));
    } else {
      echelon_Accessor.reset();
    }
    if (accessorImpl.hasEchelonTier()) {
      setEchelonTier(accessorImpl.getEchelonTier());
    } else {
      clearEchelonTier();
    }
    if (accessorImpl.flagFlown_Accessor) {
      setFlagFlown(*(accessorImpl.flagFlown_Accessor));
    } else {
      flagFlown_Accessor.reset();
    }
    if (accessorImpl.fleetAssignment_Accessor) {
      setFleetAssignment(*(accessorImpl.fleetAssignment_Accessor));
    } else {
      fleetAssignment_Accessor.reset();
    }
    if (accessorImpl.airDefenseArea_Accessor) {
      setAirDefenseArea(*(accessorImpl.airDefenseArea_Accessor));
    } else {
      airDefenseArea_Accessor.reset();
    }
    if (accessorImpl.forceAssignment_Accessor) {
      setForceAssignment(*(accessorImpl.forceAssignment_Accessor));
    } else {
      forceAssignment_Accessor.reset();
    }
    if (accessorImpl.forceName_Accessor) {
      setForceName(*(accessorImpl.forceName_Accessor));
    } else {
      forceName_Accessor.reset();
    }
    if (accessorImpl.functionRole_Accessor) {
      setFunctionRole(*(accessorImpl.functionRole_Accessor));
    } else {
      functionRole_Accessor.reset();
    }
    if (accessorImpl.missionPrimary_Accessor) {
      setMissionPrimary(*(accessorImpl.missionPrimary_Accessor));
    } else {
      missionPrimary_Accessor.reset();
    }
    if (accessorImpl.missionPrimarySpecialty_Accessor) {
      setMissionPrimarySpecialty(*(accessorImpl.missionPrimarySpecialty_Accessor));
    } else {
      missionPrimarySpecialty_Accessor.reset();
    }
    if (accessorImpl.missionSecondary_Accessor) {
      setMissionSecondary(*(accessorImpl.missionSecondary_Accessor));
    } else {
      missionSecondary_Accessor.reset();
    }
    if (accessorImpl.missionSecondarySpecialty_Accessor) {
      setMissionSecondarySpecialty(*(accessorImpl.missionSecondarySpecialty_Accessor));
    } else {
      missionSecondarySpecialty_Accessor.reset();
    }
    if (accessorImpl.nuclearCapacity_Accessor) {
      setNuclearCapacity(*(accessorImpl.nuclearCapacity_Accessor));
    } else {
      nuclearCapacity_Accessor.reset();
    }
    if (accessorImpl.parentUnitID_Accessor) {
      setParentUnitID(*(accessorImpl.parentUnitID_Accessor));
    } else {
      parentUnitID_Accessor.reset();
    }
    setSite(*(accessorImpl.site_Accessor));
    setEquipment(*(accessorImpl.equipment_Accessor));
  }
}

void UnitType::reset() noexcept {
  securityInformation_Accessor->reset();
  identity_Accessor->reset();
  standardIdentity_Accessor.reset();
  countryCode_Accessor.reset();
  position_Accessor.reset();
  timestamps_Accessor.reset();
  clearEvaluation();
  operationalStatus_Accessor.reset();
  politicalSubdivision_Accessor.reset();
  allegianceAlternate_Accessor.reset();
  deploymentStatus_Accessor.reset();
  divisionCategory_Accessor.reset();
  echelon_Accessor.reset();
  clearEchelonTier();
  flagFlown_Accessor.reset();
  fleetAssignment_Accessor.reset();
  airDefenseArea_Accessor.reset();
  forceAssignment_Accessor.reset();
  forceName_Accessor.reset();
  functionRole_Accessor.reset();
  missionPrimary_Accessor.reset();
  missionPrimarySpecialty_Accessor.reset();
  missionSecondary_Accessor.reset();
  missionSecondarySpecialty_Accessor.reset();
  nuclearCapacity_Accessor.reset();
  parentUnitID_Accessor.reset();
  site_Accessor->reset();
  equipment_Accessor->reset();
}

const uci::type::SecurityInformationType& UnitType::getSecurityInformation() const {
  return *securityInformation_Accessor;
}

uci::type::SecurityInformationType& UnitType::getSecurityInformation() {
  return *securityInformation_Accessor;
}

uci::type::UnitType& UnitType::setSecurityInformation(const uci::type::SecurityInformationType& accessor) {
  if (&accessor != securityInformation_Accessor.get()) {
    securityInformation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::UnitIdentityType& UnitType::getIdentity() const {
  return *identity_Accessor;
}

uci::type::UnitIdentityType& UnitType::getIdentity() {
  return *identity_Accessor;
}

uci::type::UnitType& UnitType::setIdentity(const uci::type::UnitIdentityType& accessor) {
  if (&accessor != identity_Accessor.get()) {
    identity_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::StandardIdentityConfidenceType& UnitType::getStandardIdentity_() const {
  if (standardIdentity_Accessor) {
    return *standardIdentity_Accessor;
  }
  throw uci::base::UCIException("Error in getStandardIdentity(): An attempt was made to get an optional field that was not enabled, call hasStandardIdentity() to determine if it is safe to call getStandardIdentity()");
}

const uci::type::StandardIdentityConfidenceType& UnitType::getStandardIdentity() const {
  return getStandardIdentity_();
}

uci::type::StandardIdentityConfidenceType& UnitType::getStandardIdentity() {
  return getStandardIdentity_();
}

uci::type::UnitType& UnitType::setStandardIdentity(const uci::type::StandardIdentityConfidenceType& accessor) {
  enableStandardIdentity();
  if (&accessor != standardIdentity_Accessor.get()) {
    standardIdentity_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool UnitType::hasStandardIdentity() const noexcept {
  return static_cast<bool>(standardIdentity_Accessor);
}

uci::type::StandardIdentityConfidenceType& UnitType::enableStandardIdentity(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::standardIdentityConfidenceType : type};
  if ((!standardIdentity_Accessor) || (standardIdentity_Accessor->getAccessorType() != requestedType)) {
    standardIdentity_Accessor = StandardIdentityConfidenceType::create(requestedType);
    if (!standardIdentity_Accessor) {
      throw uci::base::UCIException("Error in enableStandardIdentity(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *standardIdentity_Accessor;
}

uci::type::UnitType& UnitType::clearStandardIdentity() noexcept {
  standardIdentity_Accessor.reset();
  return *this;
}

uci::type::CountryCodeType& UnitType::getCountryCode_() const {
  if (countryCode_Accessor) {
    return *countryCode_Accessor;
  }
  throw uci::base::UCIException("Error in getCountryCode(): An attempt was made to get an optional field that was not enabled, call hasCountryCode() to determine if it is safe to call getCountryCode()");
}

const uci::type::CountryCodeType& UnitType::getCountryCode() const {
  return getCountryCode_();
}

uci::type::CountryCodeType& UnitType::getCountryCode() {
  return getCountryCode_();
}

uci::type::UnitType& UnitType::setCountryCode(const uci::type::CountryCodeType& accessor) {
  enableCountryCode();
  if (&accessor != countryCode_Accessor.get()) {
    countryCode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool UnitType::hasCountryCode() const noexcept {
  return static_cast<bool>(countryCode_Accessor);
}

uci::type::CountryCodeType& UnitType::enableCountryCode(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::countryCodeType : type};
  if ((!countryCode_Accessor) || (countryCode_Accessor->getAccessorType() != requestedType)) {
    countryCode_Accessor = CountryCodeType::create(requestedType);
    if (!countryCode_Accessor) {
      throw uci::base::UCIException("Error in enableCountryCode(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *countryCode_Accessor;
}

uci::type::UnitType& UnitType::clearCountryCode() noexcept {
  countryCode_Accessor.reset();
  return *this;
}

uci::type::EOB_FixedPositionType& UnitType::getPosition_() const {
  if (position_Accessor) {
    return *position_Accessor;
  }
  throw uci::base::UCIException("Error in getPosition(): An attempt was made to get an optional field that was not enabled, call hasPosition() to determine if it is safe to call getPosition()");
}

const uci::type::EOB_FixedPositionType& UnitType::getPosition() const {
  return getPosition_();
}

uci::type::EOB_FixedPositionType& UnitType::getPosition() {
  return getPosition_();
}

uci::type::UnitType& UnitType::setPosition(const uci::type::EOB_FixedPositionType& accessor) {
  enablePosition();
  if (&accessor != position_Accessor.get()) {
    position_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool UnitType::hasPosition() const noexcept {
  return static_cast<bool>(position_Accessor);
}

uci::type::EOB_FixedPositionType& UnitType::enablePosition(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::eOB_FixedPositionType : type};
  if ((!position_Accessor) || (position_Accessor->getAccessorType() != requestedType)) {
    position_Accessor = EOB_FixedPositionType::create(requestedType);
    if (!position_Accessor) {
      throw uci::base::UCIException("Error in enablePosition(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *position_Accessor;
}

uci::type::UnitType& UnitType::clearPosition() noexcept {
  position_Accessor.reset();
  return *this;
}

uci::type::OrderOfBattleTimestampsType& UnitType::getTimestamps_() const {
  if (timestamps_Accessor) {
    return *timestamps_Accessor;
  }
  throw uci::base::UCIException("Error in getTimestamps(): An attempt was made to get an optional field that was not enabled, call hasTimestamps() to determine if it is safe to call getTimestamps()");
}

const uci::type::OrderOfBattleTimestampsType& UnitType::getTimestamps() const {
  return getTimestamps_();
}

uci::type::OrderOfBattleTimestampsType& UnitType::getTimestamps() {
  return getTimestamps_();
}

uci::type::UnitType& UnitType::setTimestamps(const uci::type::OrderOfBattleTimestampsType& accessor) {
  enableTimestamps();
  if (&accessor != timestamps_Accessor.get()) {
    timestamps_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool UnitType::hasTimestamps() const noexcept {
  return static_cast<bool>(timestamps_Accessor);
}

uci::type::OrderOfBattleTimestampsType& UnitType::enableTimestamps(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orderOfBattleTimestampsType : type};
  if ((!timestamps_Accessor) || (timestamps_Accessor->getAccessorType() != requestedType)) {
    timestamps_Accessor = OrderOfBattleTimestampsType::create(requestedType);
    if (!timestamps_Accessor) {
      throw uci::base::UCIException("Error in enableTimestamps(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *timestamps_Accessor;
}

uci::type::UnitType& UnitType::clearTimestamps() noexcept {
  timestamps_Accessor.reset();
  return *this;
}

xs::UnsignedByte UnitType::getEvaluation() const {
  if (evaluation_Accessor) {
    return *evaluation_Accessor;
  }
  throw uci::base::UCIException("Error in getEvaluation(): An attempt was made to get an optional field that was not enabled, call hasEvaluation() to determine if it is safe to call getEvaluation()");
}

uci::type::UnitType& UnitType::setEvaluation(xs::UnsignedByte value) {
  evaluation_Accessor = value;
  return *this;
}

bool UnitType::hasEvaluation() const noexcept {
  return evaluation_Accessor.has_value();
}

uci::type::UnitType& UnitType::clearEvaluation() noexcept {
  evaluation_Accessor.reset();
  return *this;
}

uci::type::OB_OperationalStatusEnum& UnitType::getOperationalStatus_() const {
  if (operationalStatus_Accessor) {
    return *operationalStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getOperationalStatus(): An attempt was made to get an optional field that was not enabled, call hasOperationalStatus() to determine if it is safe to call getOperationalStatus()");
}

const uci::type::OB_OperationalStatusEnum& UnitType::getOperationalStatus() const {
  return getOperationalStatus_();
}

uci::type::OB_OperationalStatusEnum& UnitType::getOperationalStatus() {
  return getOperationalStatus_();
}

uci::type::UnitType& UnitType::setOperationalStatus(const uci::type::OB_OperationalStatusEnum& accessor) {
  enableOperationalStatus();
  if (&accessor != operationalStatus_Accessor.get()) {
    operationalStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::UnitType& UnitType::setOperationalStatus(const uci::type::OB_OperationalStatusEnum::EnumerationItem value) {
  enableOperationalStatus().setValue(value);
  return *this;
}

bool UnitType::hasOperationalStatus() const noexcept {
  return static_cast<bool>(operationalStatus_Accessor);
}

uci::type::OB_OperationalStatusEnum& UnitType::enableOperationalStatus(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::oB_OperationalStatusEnum : type};
  if ((!operationalStatus_Accessor) || (operationalStatus_Accessor->getAccessorType() != requestedType)) {
    operationalStatus_Accessor = OB_OperationalStatusEnum::create(requestedType);
    if (!operationalStatus_Accessor) {
      throw uci::base::UCIException("Error in enableOperationalStatus(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *operationalStatus_Accessor;
}

uci::type::UnitType& UnitType::clearOperationalStatus() noexcept {
  operationalStatus_Accessor.reset();
  return *this;
}

uci::type::VisibleString256Type& UnitType::getPoliticalSubdivision_() const {
  if (politicalSubdivision_Accessor) {
    return *politicalSubdivision_Accessor;
  }
  throw uci::base::UCIException("Error in getPoliticalSubdivision(): An attempt was made to get an optional field that was not enabled, call hasPoliticalSubdivision() to determine if it is safe to call getPoliticalSubdivision()");
}

const uci::type::VisibleString256Type& UnitType::getPoliticalSubdivision() const {
  return getPoliticalSubdivision_();
}

uci::type::VisibleString256Type& UnitType::getPoliticalSubdivision() {
  return getPoliticalSubdivision_();
}

uci::type::UnitType& UnitType::setPoliticalSubdivision(const uci::type::VisibleString256Type& value) {
  return setPoliticalSubdivision(value.c_str());
}

uci::type::UnitType& UnitType::setPoliticalSubdivision(const std::string& value) {
  return setPoliticalSubdivision(value.c_str());
}

uci::type::UnitType& UnitType::setPoliticalSubdivision(const char* value) {
  enablePoliticalSubdivision().setStringValue(value);
  return *this;
}

bool UnitType::hasPoliticalSubdivision() const noexcept {
  return static_cast<bool>(politicalSubdivision_Accessor);
}

uci::type::VisibleString256Type& UnitType::enablePoliticalSubdivision(uci::base::accessorType::AccessorType type) {
  if (!politicalSubdivision_Accessor) {
    politicalSubdivision_Accessor = VisibleString256Type::create(type);
  }
  return *politicalSubdivision_Accessor;
}

uci::type::UnitType& UnitType::clearPoliticalSubdivision() noexcept {
  politicalSubdivision_Accessor.reset();
  return *this;
}

uci::type::CountryCodeType& UnitType::getAllegianceAlternate_() const {
  if (allegianceAlternate_Accessor) {
    return *allegianceAlternate_Accessor;
  }
  throw uci::base::UCIException("Error in getAllegianceAlternate(): An attempt was made to get an optional field that was not enabled, call hasAllegianceAlternate() to determine if it is safe to call getAllegianceAlternate()");
}

const uci::type::CountryCodeType& UnitType::getAllegianceAlternate() const {
  return getAllegianceAlternate_();
}

uci::type::CountryCodeType& UnitType::getAllegianceAlternate() {
  return getAllegianceAlternate_();
}

uci::type::UnitType& UnitType::setAllegianceAlternate(const uci::type::CountryCodeType& accessor) {
  enableAllegianceAlternate();
  if (&accessor != allegianceAlternate_Accessor.get()) {
    allegianceAlternate_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool UnitType::hasAllegianceAlternate() const noexcept {
  return static_cast<bool>(allegianceAlternate_Accessor);
}

uci::type::CountryCodeType& UnitType::enableAllegianceAlternate(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::countryCodeType : type};
  if ((!allegianceAlternate_Accessor) || (allegianceAlternate_Accessor->getAccessorType() != requestedType)) {
    allegianceAlternate_Accessor = CountryCodeType::create(requestedType);
    if (!allegianceAlternate_Accessor) {
      throw uci::base::UCIException("Error in enableAllegianceAlternate(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *allegianceAlternate_Accessor;
}

uci::type::UnitType& UnitType::clearAllegianceAlternate() noexcept {
  allegianceAlternate_Accessor.reset();
  return *this;
}

uci::type::String20Type& UnitType::getDeploymentStatus_() const {
  if (deploymentStatus_Accessor) {
    return *deploymentStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getDeploymentStatus(): An attempt was made to get an optional field that was not enabled, call hasDeploymentStatus() to determine if it is safe to call getDeploymentStatus()");
}

const uci::type::String20Type& UnitType::getDeploymentStatus() const {
  return getDeploymentStatus_();
}

uci::type::String20Type& UnitType::getDeploymentStatus() {
  return getDeploymentStatus_();
}

uci::type::UnitType& UnitType::setDeploymentStatus(const uci::type::String20Type& value) {
  return setDeploymentStatus(value.c_str());
}

uci::type::UnitType& UnitType::setDeploymentStatus(const std::string& value) {
  return setDeploymentStatus(value.c_str());
}

uci::type::UnitType& UnitType::setDeploymentStatus(const char* value) {
  enableDeploymentStatus().setStringValue(value);
  return *this;
}

bool UnitType::hasDeploymentStatus() const noexcept {
  return static_cast<bool>(deploymentStatus_Accessor);
}

uci::type::String20Type& UnitType::enableDeploymentStatus(uci::base::accessorType::AccessorType type) {
  if (!deploymentStatus_Accessor) {
    deploymentStatus_Accessor = String20Type::create(type);
  }
  return *deploymentStatus_Accessor;
}

uci::type::UnitType& UnitType::clearDeploymentStatus() noexcept {
  deploymentStatus_Accessor.reset();
  return *this;
}

uci::type::VisibleString256Type& UnitType::getDivisionCategory_() const {
  if (divisionCategory_Accessor) {
    return *divisionCategory_Accessor;
  }
  throw uci::base::UCIException("Error in getDivisionCategory(): An attempt was made to get an optional field that was not enabled, call hasDivisionCategory() to determine if it is safe to call getDivisionCategory()");
}

const uci::type::VisibleString256Type& UnitType::getDivisionCategory() const {
  return getDivisionCategory_();
}

uci::type::VisibleString256Type& UnitType::getDivisionCategory() {
  return getDivisionCategory_();
}

uci::type::UnitType& UnitType::setDivisionCategory(const uci::type::VisibleString256Type& value) {
  return setDivisionCategory(value.c_str());
}

uci::type::UnitType& UnitType::setDivisionCategory(const std::string& value) {
  return setDivisionCategory(value.c_str());
}

uci::type::UnitType& UnitType::setDivisionCategory(const char* value) {
  enableDivisionCategory().setStringValue(value);
  return *this;
}

bool UnitType::hasDivisionCategory() const noexcept {
  return static_cast<bool>(divisionCategory_Accessor);
}

uci::type::VisibleString256Type& UnitType::enableDivisionCategory(uci::base::accessorType::AccessorType type) {
  if (!divisionCategory_Accessor) {
    divisionCategory_Accessor = VisibleString256Type::create(type);
  }
  return *divisionCategory_Accessor;
}

uci::type::UnitType& UnitType::clearDivisionCategory() noexcept {
  divisionCategory_Accessor.reset();
  return *this;
}

uci::type::String20Type& UnitType::getEchelon_() const {
  if (echelon_Accessor) {
    return *echelon_Accessor;
  }
  throw uci::base::UCIException("Error in getEchelon(): An attempt was made to get an optional field that was not enabled, call hasEchelon() to determine if it is safe to call getEchelon()");
}

const uci::type::String20Type& UnitType::getEchelon() const {
  return getEchelon_();
}

uci::type::String20Type& UnitType::getEchelon() {
  return getEchelon_();
}

uci::type::UnitType& UnitType::setEchelon(const uci::type::String20Type& value) {
  return setEchelon(value.c_str());
}

uci::type::UnitType& UnitType::setEchelon(const std::string& value) {
  return setEchelon(value.c_str());
}

uci::type::UnitType& UnitType::setEchelon(const char* value) {
  enableEchelon().setStringValue(value);
  return *this;
}

bool UnitType::hasEchelon() const noexcept {
  return static_cast<bool>(echelon_Accessor);
}

uci::type::String20Type& UnitType::enableEchelon(uci::base::accessorType::AccessorType type) {
  if (!echelon_Accessor) {
    echelon_Accessor = String20Type::create(type);
  }
  return *echelon_Accessor;
}

uci::type::UnitType& UnitType::clearEchelon() noexcept {
  echelon_Accessor.reset();
  return *this;
}

xs::UnsignedByte UnitType::getEchelonTier() const {
  if (echelonTier_Accessor) {
    return *echelonTier_Accessor;
  }
  throw uci::base::UCIException("Error in getEchelonTier(): An attempt was made to get an optional field that was not enabled, call hasEchelonTier() to determine if it is safe to call getEchelonTier()");
}

uci::type::UnitType& UnitType::setEchelonTier(xs::UnsignedByte value) {
  echelonTier_Accessor = value;
  return *this;
}

bool UnitType::hasEchelonTier() const noexcept {
  return echelonTier_Accessor.has_value();
}

uci::type::UnitType& UnitType::clearEchelonTier() noexcept {
  echelonTier_Accessor.reset();
  return *this;
}

uci::type::CountryCodeType& UnitType::getFlagFlown_() const {
  if (flagFlown_Accessor) {
    return *flagFlown_Accessor;
  }
  throw uci::base::UCIException("Error in getFlagFlown(): An attempt was made to get an optional field that was not enabled, call hasFlagFlown() to determine if it is safe to call getFlagFlown()");
}

const uci::type::CountryCodeType& UnitType::getFlagFlown() const {
  return getFlagFlown_();
}

uci::type::CountryCodeType& UnitType::getFlagFlown() {
  return getFlagFlown_();
}

uci::type::UnitType& UnitType::setFlagFlown(const uci::type::CountryCodeType& accessor) {
  enableFlagFlown();
  if (&accessor != flagFlown_Accessor.get()) {
    flagFlown_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool UnitType::hasFlagFlown() const noexcept {
  return static_cast<bool>(flagFlown_Accessor);
}

uci::type::CountryCodeType& UnitType::enableFlagFlown(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::countryCodeType : type};
  if ((!flagFlown_Accessor) || (flagFlown_Accessor->getAccessorType() != requestedType)) {
    flagFlown_Accessor = CountryCodeType::create(requestedType);
    if (!flagFlown_Accessor) {
      throw uci::base::UCIException("Error in enableFlagFlown(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *flagFlown_Accessor;
}

uci::type::UnitType& UnitType::clearFlagFlown() noexcept {
  flagFlown_Accessor.reset();
  return *this;
}

uci::type::String4Type& UnitType::getFleetAssignment_() const {
  if (fleetAssignment_Accessor) {
    return *fleetAssignment_Accessor;
  }
  throw uci::base::UCIException("Error in getFleetAssignment(): An attempt was made to get an optional field that was not enabled, call hasFleetAssignment() to determine if it is safe to call getFleetAssignment()");
}

const uci::type::String4Type& UnitType::getFleetAssignment() const {
  return getFleetAssignment_();
}

uci::type::String4Type& UnitType::getFleetAssignment() {
  return getFleetAssignment_();
}

uci::type::UnitType& UnitType::setFleetAssignment(const uci::type::String4Type& value) {
  return setFleetAssignment(value.c_str());
}

uci::type::UnitType& UnitType::setFleetAssignment(const std::string& value) {
  return setFleetAssignment(value.c_str());
}

uci::type::UnitType& UnitType::setFleetAssignment(const char* value) {
  enableFleetAssignment().setStringValue(value);
  return *this;
}

bool UnitType::hasFleetAssignment() const noexcept {
  return static_cast<bool>(fleetAssignment_Accessor);
}

uci::type::String4Type& UnitType::enableFleetAssignment(uci::base::accessorType::AccessorType type) {
  if (!fleetAssignment_Accessor) {
    fleetAssignment_Accessor = String4Type::create(type);
  }
  return *fleetAssignment_Accessor;
}

uci::type::UnitType& UnitType::clearFleetAssignment() noexcept {
  fleetAssignment_Accessor.reset();
  return *this;
}

uci::type::AirDefenseAreaType& UnitType::getAirDefenseArea_() const {
  if (airDefenseArea_Accessor) {
    return *airDefenseArea_Accessor;
  }
  throw uci::base::UCIException("Error in getAirDefenseArea(): An attempt was made to get an optional field that was not enabled, call hasAirDefenseArea() to determine if it is safe to call getAirDefenseArea()");
}

const uci::type::AirDefenseAreaType& UnitType::getAirDefenseArea() const {
  return getAirDefenseArea_();
}

uci::type::AirDefenseAreaType& UnitType::getAirDefenseArea() {
  return getAirDefenseArea_();
}

uci::type::UnitType& UnitType::setAirDefenseArea(const uci::type::AirDefenseAreaType& value) {
  return setAirDefenseArea(value.c_str());
}

uci::type::UnitType& UnitType::setAirDefenseArea(const std::string& value) {
  return setAirDefenseArea(value.c_str());
}

uci::type::UnitType& UnitType::setAirDefenseArea(const char* value) {
  enableAirDefenseArea().setStringValue(value);
  return *this;
}

bool UnitType::hasAirDefenseArea() const noexcept {
  return static_cast<bool>(airDefenseArea_Accessor);
}

uci::type::AirDefenseAreaType& UnitType::enableAirDefenseArea(uci::base::accessorType::AccessorType type) {
  if (!airDefenseArea_Accessor) {
    airDefenseArea_Accessor = AirDefenseAreaType::create(type);
  }
  return *airDefenseArea_Accessor;
}

uci::type::UnitType& UnitType::clearAirDefenseArea() noexcept {
  airDefenseArea_Accessor.reset();
  return *this;
}

uci::type::VisibleString256Type& UnitType::getForceAssignment_() const {
  if (forceAssignment_Accessor) {
    return *forceAssignment_Accessor;
  }
  throw uci::base::UCIException("Error in getForceAssignment(): An attempt was made to get an optional field that was not enabled, call hasForceAssignment() to determine if it is safe to call getForceAssignment()");
}

const uci::type::VisibleString256Type& UnitType::getForceAssignment() const {
  return getForceAssignment_();
}

uci::type::VisibleString256Type& UnitType::getForceAssignment() {
  return getForceAssignment_();
}

uci::type::UnitType& UnitType::setForceAssignment(const uci::type::VisibleString256Type& value) {
  return setForceAssignment(value.c_str());
}

uci::type::UnitType& UnitType::setForceAssignment(const std::string& value) {
  return setForceAssignment(value.c_str());
}

uci::type::UnitType& UnitType::setForceAssignment(const char* value) {
  enableForceAssignment().setStringValue(value);
  return *this;
}

bool UnitType::hasForceAssignment() const noexcept {
  return static_cast<bool>(forceAssignment_Accessor);
}

uci::type::VisibleString256Type& UnitType::enableForceAssignment(uci::base::accessorType::AccessorType type) {
  if (!forceAssignment_Accessor) {
    forceAssignment_Accessor = VisibleString256Type::create(type);
  }
  return *forceAssignment_Accessor;
}

uci::type::UnitType& UnitType::clearForceAssignment() noexcept {
  forceAssignment_Accessor.reset();
  return *this;
}

uci::type::VisibleString256Type& UnitType::getForceName_() const {
  if (forceName_Accessor) {
    return *forceName_Accessor;
  }
  throw uci::base::UCIException("Error in getForceName(): An attempt was made to get an optional field that was not enabled, call hasForceName() to determine if it is safe to call getForceName()");
}

const uci::type::VisibleString256Type& UnitType::getForceName() const {
  return getForceName_();
}

uci::type::VisibleString256Type& UnitType::getForceName() {
  return getForceName_();
}

uci::type::UnitType& UnitType::setForceName(const uci::type::VisibleString256Type& value) {
  return setForceName(value.c_str());
}

uci::type::UnitType& UnitType::setForceName(const std::string& value) {
  return setForceName(value.c_str());
}

uci::type::UnitType& UnitType::setForceName(const char* value) {
  enableForceName().setStringValue(value);
  return *this;
}

bool UnitType::hasForceName() const noexcept {
  return static_cast<bool>(forceName_Accessor);
}

uci::type::VisibleString256Type& UnitType::enableForceName(uci::base::accessorType::AccessorType type) {
  if (!forceName_Accessor) {
    forceName_Accessor = VisibleString256Type::create(type);
  }
  return *forceName_Accessor;
}

uci::type::UnitType& UnitType::clearForceName() noexcept {
  forceName_Accessor.reset();
  return *this;
}

uci::type::String20Type& UnitType::getFunctionRole_() const {
  if (functionRole_Accessor) {
    return *functionRole_Accessor;
  }
  throw uci::base::UCIException("Error in getFunctionRole(): An attempt was made to get an optional field that was not enabled, call hasFunctionRole() to determine if it is safe to call getFunctionRole()");
}

const uci::type::String20Type& UnitType::getFunctionRole() const {
  return getFunctionRole_();
}

uci::type::String20Type& UnitType::getFunctionRole() {
  return getFunctionRole_();
}

uci::type::UnitType& UnitType::setFunctionRole(const uci::type::String20Type& value) {
  return setFunctionRole(value.c_str());
}

uci::type::UnitType& UnitType::setFunctionRole(const std::string& value) {
  return setFunctionRole(value.c_str());
}

uci::type::UnitType& UnitType::setFunctionRole(const char* value) {
  enableFunctionRole().setStringValue(value);
  return *this;
}

bool UnitType::hasFunctionRole() const noexcept {
  return static_cast<bool>(functionRole_Accessor);
}

uci::type::String20Type& UnitType::enableFunctionRole(uci::base::accessorType::AccessorType type) {
  if (!functionRole_Accessor) {
    functionRole_Accessor = String20Type::create(type);
  }
  return *functionRole_Accessor;
}

uci::type::UnitType& UnitType::clearFunctionRole() noexcept {
  functionRole_Accessor.reset();
  return *this;
}

uci::type::String4Type& UnitType::getMissionPrimary_() const {
  if (missionPrimary_Accessor) {
    return *missionPrimary_Accessor;
  }
  throw uci::base::UCIException("Error in getMissionPrimary(): An attempt was made to get an optional field that was not enabled, call hasMissionPrimary() to determine if it is safe to call getMissionPrimary()");
}

const uci::type::String4Type& UnitType::getMissionPrimary() const {
  return getMissionPrimary_();
}

uci::type::String4Type& UnitType::getMissionPrimary() {
  return getMissionPrimary_();
}

uci::type::UnitType& UnitType::setMissionPrimary(const uci::type::String4Type& value) {
  return setMissionPrimary(value.c_str());
}

uci::type::UnitType& UnitType::setMissionPrimary(const std::string& value) {
  return setMissionPrimary(value.c_str());
}

uci::type::UnitType& UnitType::setMissionPrimary(const char* value) {
  enableMissionPrimary().setStringValue(value);
  return *this;
}

bool UnitType::hasMissionPrimary() const noexcept {
  return static_cast<bool>(missionPrimary_Accessor);
}

uci::type::String4Type& UnitType::enableMissionPrimary(uci::base::accessorType::AccessorType type) {
  if (!missionPrimary_Accessor) {
    missionPrimary_Accessor = String4Type::create(type);
  }
  return *missionPrimary_Accessor;
}

uci::type::UnitType& UnitType::clearMissionPrimary() noexcept {
  missionPrimary_Accessor.reset();
  return *this;
}

uci::type::String4Type& UnitType::getMissionPrimarySpecialty_() const {
  if (missionPrimarySpecialty_Accessor) {
    return *missionPrimarySpecialty_Accessor;
  }
  throw uci::base::UCIException("Error in getMissionPrimarySpecialty(): An attempt was made to get an optional field that was not enabled, call hasMissionPrimarySpecialty() to determine if it is safe to call getMissionPrimarySpecialty()");
}

const uci::type::String4Type& UnitType::getMissionPrimarySpecialty() const {
  return getMissionPrimarySpecialty_();
}

uci::type::String4Type& UnitType::getMissionPrimarySpecialty() {
  return getMissionPrimarySpecialty_();
}

uci::type::UnitType& UnitType::setMissionPrimarySpecialty(const uci::type::String4Type& value) {
  return setMissionPrimarySpecialty(value.c_str());
}

uci::type::UnitType& UnitType::setMissionPrimarySpecialty(const std::string& value) {
  return setMissionPrimarySpecialty(value.c_str());
}

uci::type::UnitType& UnitType::setMissionPrimarySpecialty(const char* value) {
  enableMissionPrimarySpecialty().setStringValue(value);
  return *this;
}

bool UnitType::hasMissionPrimarySpecialty() const noexcept {
  return static_cast<bool>(missionPrimarySpecialty_Accessor);
}

uci::type::String4Type& UnitType::enableMissionPrimarySpecialty(uci::base::accessorType::AccessorType type) {
  if (!missionPrimarySpecialty_Accessor) {
    missionPrimarySpecialty_Accessor = String4Type::create(type);
  }
  return *missionPrimarySpecialty_Accessor;
}

uci::type::UnitType& UnitType::clearMissionPrimarySpecialty() noexcept {
  missionPrimarySpecialty_Accessor.reset();
  return *this;
}

uci::type::String4Type& UnitType::getMissionSecondary_() const {
  if (missionSecondary_Accessor) {
    return *missionSecondary_Accessor;
  }
  throw uci::base::UCIException("Error in getMissionSecondary(): An attempt was made to get an optional field that was not enabled, call hasMissionSecondary() to determine if it is safe to call getMissionSecondary()");
}

const uci::type::String4Type& UnitType::getMissionSecondary() const {
  return getMissionSecondary_();
}

uci::type::String4Type& UnitType::getMissionSecondary() {
  return getMissionSecondary_();
}

uci::type::UnitType& UnitType::setMissionSecondary(const uci::type::String4Type& value) {
  return setMissionSecondary(value.c_str());
}

uci::type::UnitType& UnitType::setMissionSecondary(const std::string& value) {
  return setMissionSecondary(value.c_str());
}

uci::type::UnitType& UnitType::setMissionSecondary(const char* value) {
  enableMissionSecondary().setStringValue(value);
  return *this;
}

bool UnitType::hasMissionSecondary() const noexcept {
  return static_cast<bool>(missionSecondary_Accessor);
}

uci::type::String4Type& UnitType::enableMissionSecondary(uci::base::accessorType::AccessorType type) {
  if (!missionSecondary_Accessor) {
    missionSecondary_Accessor = String4Type::create(type);
  }
  return *missionSecondary_Accessor;
}

uci::type::UnitType& UnitType::clearMissionSecondary() noexcept {
  missionSecondary_Accessor.reset();
  return *this;
}

uci::type::String4Type& UnitType::getMissionSecondarySpecialty_() const {
  if (missionSecondarySpecialty_Accessor) {
    return *missionSecondarySpecialty_Accessor;
  }
  throw uci::base::UCIException("Error in getMissionSecondarySpecialty(): An attempt was made to get an optional field that was not enabled, call hasMissionSecondarySpecialty() to determine if it is safe to call getMissionSecondarySpecialty()");
}

const uci::type::String4Type& UnitType::getMissionSecondarySpecialty() const {
  return getMissionSecondarySpecialty_();
}

uci::type::String4Type& UnitType::getMissionSecondarySpecialty() {
  return getMissionSecondarySpecialty_();
}

uci::type::UnitType& UnitType::setMissionSecondarySpecialty(const uci::type::String4Type& value) {
  return setMissionSecondarySpecialty(value.c_str());
}

uci::type::UnitType& UnitType::setMissionSecondarySpecialty(const std::string& value) {
  return setMissionSecondarySpecialty(value.c_str());
}

uci::type::UnitType& UnitType::setMissionSecondarySpecialty(const char* value) {
  enableMissionSecondarySpecialty().setStringValue(value);
  return *this;
}

bool UnitType::hasMissionSecondarySpecialty() const noexcept {
  return static_cast<bool>(missionSecondarySpecialty_Accessor);
}

uci::type::String4Type& UnitType::enableMissionSecondarySpecialty(uci::base::accessorType::AccessorType type) {
  if (!missionSecondarySpecialty_Accessor) {
    missionSecondarySpecialty_Accessor = String4Type::create(type);
  }
  return *missionSecondarySpecialty_Accessor;
}

uci::type::UnitType& UnitType::clearMissionSecondarySpecialty() noexcept {
  missionSecondarySpecialty_Accessor.reset();
  return *this;
}

uci::type::String20Type& UnitType::getNuclearCapacity_() const {
  if (nuclearCapacity_Accessor) {
    return *nuclearCapacity_Accessor;
  }
  throw uci::base::UCIException("Error in getNuclearCapacity(): An attempt was made to get an optional field that was not enabled, call hasNuclearCapacity() to determine if it is safe to call getNuclearCapacity()");
}

const uci::type::String20Type& UnitType::getNuclearCapacity() const {
  return getNuclearCapacity_();
}

uci::type::String20Type& UnitType::getNuclearCapacity() {
  return getNuclearCapacity_();
}

uci::type::UnitType& UnitType::setNuclearCapacity(const uci::type::String20Type& value) {
  return setNuclearCapacity(value.c_str());
}

uci::type::UnitType& UnitType::setNuclearCapacity(const std::string& value) {
  return setNuclearCapacity(value.c_str());
}

uci::type::UnitType& UnitType::setNuclearCapacity(const char* value) {
  enableNuclearCapacity().setStringValue(value);
  return *this;
}

bool UnitType::hasNuclearCapacity() const noexcept {
  return static_cast<bool>(nuclearCapacity_Accessor);
}

uci::type::String20Type& UnitType::enableNuclearCapacity(uci::base::accessorType::AccessorType type) {
  if (!nuclearCapacity_Accessor) {
    nuclearCapacity_Accessor = String20Type::create(type);
  }
  return *nuclearCapacity_Accessor;
}

uci::type::UnitType& UnitType::clearNuclearCapacity() noexcept {
  nuclearCapacity_Accessor.reset();
  return *this;
}

uci::type::ID_Type& UnitType::getParentUnitID_() const {
  if (parentUnitID_Accessor) {
    return *parentUnitID_Accessor;
  }
  throw uci::base::UCIException("Error in getParentUnitID(): An attempt was made to get an optional field that was not enabled, call hasParentUnitID() to determine if it is safe to call getParentUnitID()");
}

const uci::type::ID_Type& UnitType::getParentUnitID() const {
  return getParentUnitID_();
}

uci::type::ID_Type& UnitType::getParentUnitID() {
  return getParentUnitID_();
}

uci::type::UnitType& UnitType::setParentUnitID(const uci::type::ID_Type& accessor) {
  enableParentUnitID(accessor.getAccessorType());
  if (&accessor != parentUnitID_Accessor.get()) {
    parentUnitID_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool UnitType::hasParentUnitID() const noexcept {
  return static_cast<bool>(parentUnitID_Accessor);
}

uci::type::ID_Type& UnitType::enableParentUnitID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::iD_Type : type};
  if ((!parentUnitID_Accessor) || (parentUnitID_Accessor->getAccessorType() != requestedType)) {
    parentUnitID_Accessor = ID_Type::create(requestedType);
    if (!parentUnitID_Accessor) {
      throw uci::base::UCIException("Error in enableParentUnitID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *parentUnitID_Accessor;
}

uci::type::UnitType& UnitType::clearParentUnitID() noexcept {
  parentUnitID_Accessor.reset();
  return *this;
}

const uci::type::UnitType::Site& UnitType::getSite() const {
  return *site_Accessor;
}

uci::type::UnitType::Site& UnitType::getSite() {
  return *site_Accessor;
}

uci::type::UnitType& UnitType::setSite(const uci::type::UnitType::Site& accessor) {
  if (&accessor != site_Accessor.get()) {
    site_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::UnitType::Equipment& UnitType::getEquipment() const {
  return *equipment_Accessor;
}

uci::type::UnitType::Equipment& UnitType::getEquipment() {
  return *equipment_Accessor;
}

uci::type::UnitType& UnitType::setEquipment(const uci::type::UnitType::Equipment& accessor) {
  if (&accessor != equipment_Accessor.get()) {
    equipment_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

std::unique_ptr<UnitType> UnitType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::unitType : type};
  return (requestedType == uci::type::accessorType::unitType) ? boost::make_unique<UnitType>() : nullptr;
}

/**  */
namespace UnitType_Names {

constexpr const char* Extern_Type_Name{"UnitType"};
constexpr const char* SecurityInformation_Name{"SecurityInformation"};
constexpr const char* Identity_Name{"Identity"};
constexpr const char* StandardIdentity_Name{"StandardIdentity"};
constexpr const char* CountryCode_Name{"CountryCode"};
constexpr const char* Position_Name{"Position"};
constexpr const char* Timestamps_Name{"Timestamps"};
constexpr const char* Evaluation_Name{"Evaluation"};
constexpr const char* OperationalStatus_Name{"OperationalStatus"};
constexpr const char* PoliticalSubdivision_Name{"PoliticalSubdivision"};
constexpr const char* AllegianceAlternate_Name{"AllegianceAlternate"};
constexpr const char* DeploymentStatus_Name{"DeploymentStatus"};
constexpr const char* DivisionCategory_Name{"DivisionCategory"};
constexpr const char* Echelon_Name{"Echelon"};
constexpr const char* EchelonTier_Name{"EchelonTier"};
constexpr const char* FlagFlown_Name{"FlagFlown"};
constexpr const char* FleetAssignment_Name{"FleetAssignment"};
constexpr const char* AirDefenseArea_Name{"AirDefenseArea"};
constexpr const char* ForceAssignment_Name{"ForceAssignment"};
constexpr const char* ForceName_Name{"ForceName"};
constexpr const char* FunctionRole_Name{"FunctionRole"};
constexpr const char* MissionPrimary_Name{"MissionPrimary"};
constexpr const char* MissionPrimarySpecialty_Name{"MissionPrimarySpecialty"};
constexpr const char* MissionSecondary_Name{"MissionSecondary"};
constexpr const char* MissionSecondarySpecialty_Name{"MissionSecondarySpecialty"};
constexpr const char* NuclearCapacity_Name{"NuclearCapacity"};
constexpr const char* ParentUnitID_Name{"ParentUnitID"};
constexpr const char* Site_Name{"Site"};
constexpr const char* Equipment_Name{"Equipment"};

} // namespace UnitType_Names

void UnitType::deserialize(const boost::property_tree::ptree& propTree, uci::type::UnitType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = UnitType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + UnitType_Names::SecurityInformation_Name) {
      SecurityInformationType::deserialize(valueType.second, accessor.getSecurityInformation(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::Identity_Name) {
      UnitIdentityType::deserialize(valueType.second, accessor.getIdentity(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::StandardIdentity_Name) {
      StandardIdentityConfidenceType::deserialize(valueType.second, accessor.enableStandardIdentity(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::CountryCode_Name) {
      CountryCodeType::deserialize(valueType.second, accessor.enableCountryCode(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::Position_Name) {
      EOB_FixedPositionType::deserialize(valueType.second, accessor.enablePosition(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::Timestamps_Name) {
      OrderOfBattleTimestampsType::deserialize(valueType.second, accessor.enableTimestamps(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::Evaluation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setEvaluation(asb_uci::util::SerializationHelpers::deserializeUnsignedByte(*value));
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::OperationalStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableOperationalStatus().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::PoliticalSubdivision_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPoliticalSubdivision(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::AllegianceAlternate_Name) {
      CountryCodeType::deserialize(valueType.second, accessor.enableAllegianceAlternate(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::DeploymentStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setDeploymentStatus(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::DivisionCategory_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setDivisionCategory(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::Echelon_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setEchelon(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::EchelonTier_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setEchelonTier(asb_uci::util::SerializationHelpers::deserializeUnsignedByte(*value));
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::FlagFlown_Name) {
      CountryCodeType::deserialize(valueType.second, accessor.enableFlagFlown(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::FleetAssignment_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFleetAssignment(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::AirDefenseArea_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAirDefenseArea(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::ForceAssignment_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setForceAssignment(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::ForceName_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setForceName(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::FunctionRole_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFunctionRole(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::MissionPrimary_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMissionPrimary(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::MissionPrimarySpecialty_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMissionPrimarySpecialty(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::MissionSecondary_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMissionSecondary(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::MissionSecondarySpecialty_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMissionSecondarySpecialty(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::NuclearCapacity_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setNuclearCapacity(*value);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::ParentUnitID_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableParentUnitID(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + UnitType_Names::Site_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::UnitType::Site& boundedList = accessor.getSite();
        const uci::type::UnitType::Site::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1, asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix));
        asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + UnitType_Names::Equipment_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::UnitType::Equipment& boundedList = accessor.getEquipment();
        const uci::type::UnitType::Equipment::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::EOB_EquipmentRecordType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    }
  }
}

std::string UnitType::serialize(const uci::type::UnitType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? UnitType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, UnitType_Names::Extern_Type_Name);
  }
  SecurityInformationType::serialize(accessor.getSecurityInformation(), node, UnitType_Names::SecurityInformation_Name);
  UnitIdentityType::serialize(accessor.getIdentity(), node, UnitType_Names::Identity_Name);
  if (accessor.hasStandardIdentity()) {
    StandardIdentityConfidenceType::serialize(accessor.getStandardIdentity(), node, UnitType_Names::StandardIdentity_Name);
  }
  if (accessor.hasCountryCode()) {
    CountryCodeType::serialize(accessor.getCountryCode(), node, UnitType_Names::CountryCode_Name);
  }
  if (accessor.hasPosition()) {
    EOB_FixedPositionType::serialize(accessor.getPosition(), node, UnitType_Names::Position_Name);
  }
  if (accessor.hasTimestamps()) {
    OrderOfBattleTimestampsType::serialize(accessor.getTimestamps(), node, UnitType_Names::Timestamps_Name);
  }
  if (accessor.hasEvaluation()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedByte(accessor.getEvaluation(), node, UnitType_Names::Evaluation_Name);
  }
  if (accessor.hasOperationalStatus()) {
    OB_OperationalStatusEnum::serialize(accessor.getOperationalStatus(), node, UnitType_Names::OperationalStatus_Name, false);
  }
  if (accessor.hasPoliticalSubdivision()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getPoliticalSubdivision(), node, UnitType_Names::PoliticalSubdivision_Name);
  }
  if (accessor.hasAllegianceAlternate()) {
    CountryCodeType::serialize(accessor.getAllegianceAlternate(), node, UnitType_Names::AllegianceAlternate_Name);
  }
  if (accessor.hasDeploymentStatus()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getDeploymentStatus(), node, UnitType_Names::DeploymentStatus_Name);
  }
  if (accessor.hasDivisionCategory()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getDivisionCategory(), node, UnitType_Names::DivisionCategory_Name);
  }
  if (accessor.hasEchelon()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getEchelon(), node, UnitType_Names::Echelon_Name);
  }
  if (accessor.hasEchelonTier()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedByte(accessor.getEchelonTier(), node, UnitType_Names::EchelonTier_Name);
  }
  if (accessor.hasFlagFlown()) {
    CountryCodeType::serialize(accessor.getFlagFlown(), node, UnitType_Names::FlagFlown_Name);
  }
  if (accessor.hasFleetAssignment()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFleetAssignment(), node, UnitType_Names::FleetAssignment_Name);
  }
  if (accessor.hasAirDefenseArea()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getAirDefenseArea(), node, UnitType_Names::AirDefenseArea_Name);
  }
  if (accessor.hasForceAssignment()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getForceAssignment(), node, UnitType_Names::ForceAssignment_Name);
  }
  if (accessor.hasForceName()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getForceName(), node, UnitType_Names::ForceName_Name);
  }
  if (accessor.hasFunctionRole()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFunctionRole(), node, UnitType_Names::FunctionRole_Name);
  }
  if (accessor.hasMissionPrimary()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getMissionPrimary(), node, UnitType_Names::MissionPrimary_Name);
  }
  if (accessor.hasMissionPrimarySpecialty()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getMissionPrimarySpecialty(), node, UnitType_Names::MissionPrimarySpecialty_Name);
  }
  if (accessor.hasMissionSecondary()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getMissionSecondary(), node, UnitType_Names::MissionSecondary_Name);
  }
  if (accessor.hasMissionSecondarySpecialty()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getMissionSecondarySpecialty(), node, UnitType_Names::MissionSecondarySpecialty_Name);
  }
  if (accessor.hasNuclearCapacity()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getNuclearCapacity(), node, UnitType_Names::NuclearCapacity_Name);
  }
  if (accessor.hasParentUnitID()) {
    ID_Type::serialize(accessor.getParentUnitID(), node, UnitType_Names::ParentUnitID_Name);
  }
  {
    const uci::type::UnitType::Site& boundedList = accessor.getSite();
    for (uci::type::UnitType::Site::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::BaseEOB_RecordType::serialize(boundedList.at(i), node, UnitType_Names::Site_Name);
    }
  }
  {
    const uci::type::UnitType::Equipment& boundedList = accessor.getEquipment();
    for (uci::type::UnitType::Equipment::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::EOB_EquipmentRecordType::serialize(boundedList.at(i), node, UnitType_Names::Equipment_Name);
    }
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::UnitType& UnitType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::UnitType>().release());
}

uci::type::UnitType& UnitType::create(const uci::type::UnitType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::UnitType> newAccessor{boost::make_unique<asb_uci::type::UnitType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void UnitType::destroy(uci::type::UnitType& accessor) {
  delete dynamic_cast<asb_uci::type::UnitType*>(&accessor);
}

} // namespace type

} // namespace uci

