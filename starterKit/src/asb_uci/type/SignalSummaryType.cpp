/** @file SignalSummaryType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/SignalSummaryType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/CoverageEffortEnum.h"
#include "asb_uci/type/EmitterUrgencyEnum.h"
#include "asb_uci/type/EmptyType.h"
#include "asb_uci/type/FrequencyControlType.h"
#include "asb_uci/type/FrequencyModulationVariationEnum.h"
#include "asb_uci/type/FrequencyRangeType.h"
#include "asb_uci/type/ModulationEnum.h"
#include "asb_uci/type/PRI_TypeEnum.h"
#include "asb_uci/type/RadarBeamPersistenceEnum.h"
#include "asb_uci/type/RadarBeamTypeEnum.h"
#include "asb_uci/type/SignalLocationEnum.h"
#include "asb_uci/type/TrackModeEnum.h"
#include "asb_uci/type/VisibleString64Type.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/CoverageEffortEnum.h"
#include "uci/type/DurationType.h"
#include "uci/type/EmitterUrgencyEnum.h"
#include "uci/type/EmptyType.h"
#include "uci/type/FrequencyControlType.h"
#include "uci/type/FrequencyModulationVariationEnum.h"
#include "uci/type/FrequencyRangeType.h"
#include "uci/type/FrequencyType.h"
#include "uci/type/MilliwattPowerRatioType.h"
#include "uci/type/ModulationEnum.h"
#include "uci/type/PRI_TypeEnum.h"
#include "uci/type/RadarBeamPersistenceEnum.h"
#include "uci/type/RadarBeamTypeEnum.h"
#include "uci/type/SignalLocationEnum.h"
#include "uci/type/SignalSummaryType.h"
#include "uci/type/TrackModeEnum.h"
#include "uci/type/VisibleString64Type.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

SignalSummaryType::SignalSummaryType()
  : modulation_Accessor{boost::make_unique<Modulation>(0, 62)},
    frequencyCoverage_Accessor{boost::make_unique<FrequencyCoverage>(0, SIZE_MAX)} {
}

SignalSummaryType::~SignalSummaryType() = default;

void SignalSummaryType::copy(const uci::type::SignalSummaryType& accessor) {
  copyImpl(accessor, false);
}

void SignalSummaryType::copyImpl(const uci::type::SignalSummaryType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const SignalSummaryType&>(accessor);
    setModulation(*(accessorImpl.modulation_Accessor));
    if (accessorImpl.vendorSpecificModulation_Accessor) {
      setVendorSpecificModulation(*(accessorImpl.vendorSpecificModulation_Accessor));
    } else {
      vendorSpecificModulation_Accessor.reset();
    }
    if (accessorImpl.frequencyModulationVariation_Accessor) {
      setFrequencyModulationVariation(*(accessorImpl.frequencyModulationVariation_Accessor));
    } else {
      frequencyModulationVariation_Accessor.reset();
    }
    if (accessorImpl.hasFrequencyAverage()) {
      setFrequencyAverage(accessorImpl.getFrequencyAverage());
    } else {
      clearFrequencyAverage();
    }
    if (accessorImpl.hasFrequencyMin()) {
      setFrequencyMin(accessorImpl.getFrequencyMin());
    } else {
      clearFrequencyMin();
    }
    if (accessorImpl.hasFrequencyMax()) {
      setFrequencyMax(accessorImpl.getFrequencyMax());
    } else {
      clearFrequencyMax();
    }
    if (accessorImpl.frequencyRangeControlOptions_Accessor) {
      setFrequencyRangeControlOptions(*(accessorImpl.frequencyRangeControlOptions_Accessor));
    } else {
      frequencyRangeControlOptions_Accessor.reset();
    }
    if (accessorImpl.pRI_Type_Accessor) {
      setPRI_Type(*(accessorImpl.pRI_Type_Accessor));
    } else {
      pRI_Type_Accessor.reset();
    }
    if (accessorImpl.hasPRI_Average()) {
      setPRI_Average(accessorImpl.getPRI_Average());
    } else {
      clearPRI_Average();
    }
    if (accessorImpl.hasPRI_Min()) {
      setPRI_Min(accessorImpl.getPRI_Min());
    } else {
      clearPRI_Min();
    }
    if (accessorImpl.hasPRI_Max()) {
      setPRI_Max(accessorImpl.getPRI_Max());
    } else {
      clearPRI_Max();
    }
    if (accessorImpl.hasPulseWidthAverage()) {
      setPulseWidthAverage(accessorImpl.getPulseWidthAverage());
    } else {
      clearPulseWidthAverage();
    }
    if (accessorImpl.hasPulseWidthMin()) {
      setPulseWidthMin(accessorImpl.getPulseWidthMin());
    } else {
      clearPulseWidthMin();
    }
    if (accessorImpl.hasPulseWidthMax()) {
      setPulseWidthMax(accessorImpl.getPulseWidthMax());
    } else {
      clearPulseWidthMax();
    }
    if (accessorImpl.signalBandwidth_Accessor) {
      setSignalBandwidth(*(accessorImpl.signalBandwidth_Accessor));
    } else {
      signalBandwidth_Accessor.reset();
    }
    if (accessorImpl.hasAmplitudeAverage()) {
      setAmplitudeAverage(accessorImpl.getAmplitudeAverage());
    } else {
      clearAmplitudeAverage();
    }
    if (accessorImpl.trackMode_Accessor) {
      setTrackMode(*(accessorImpl.trackMode_Accessor));
    } else {
      trackMode_Accessor.reset();
    }
    if (accessorImpl.urgency_Accessor) {
      setUrgency(*(accessorImpl.urgency_Accessor));
    } else {
      urgency_Accessor.reset();
    }
    if (accessorImpl.wartimeReserve_Accessor) {
      setWartimeReserve(*(accessorImpl.wartimeReserve_Accessor));
    } else {
      wartimeReserve_Accessor.reset();
    }
    if (accessorImpl.locationCategory_Accessor) {
      setLocationCategory(*(accessorImpl.locationCategory_Accessor));
    } else {
      locationCategory_Accessor.reset();
    }
    if (accessorImpl.typeOfBeam_Accessor) {
      setTypeOfBeam(*(accessorImpl.typeOfBeam_Accessor));
    } else {
      typeOfBeam_Accessor.reset();
    }
    if (accessorImpl.beamPersistence_Accessor) {
      setBeamPersistence(*(accessorImpl.beamPersistence_Accessor));
    } else {
      beamPersistence_Accessor.reset();
    }
    setFrequencyCoverage(*(accessorImpl.frequencyCoverage_Accessor));
  }
}

void SignalSummaryType::reset() noexcept {
  modulation_Accessor->reset();
  vendorSpecificModulation_Accessor.reset();
  frequencyModulationVariation_Accessor.reset();
  clearFrequencyAverage();
  clearFrequencyMin();
  clearFrequencyMax();
  frequencyRangeControlOptions_Accessor.reset();
  pRI_Type_Accessor.reset();
  clearPRI_Average();
  clearPRI_Min();
  clearPRI_Max();
  clearPulseWidthAverage();
  clearPulseWidthMin();
  clearPulseWidthMax();
  signalBandwidth_Accessor.reset();
  clearAmplitudeAverage();
  trackMode_Accessor.reset();
  urgency_Accessor.reset();
  wartimeReserve_Accessor.reset();
  locationCategory_Accessor.reset();
  typeOfBeam_Accessor.reset();
  beamPersistence_Accessor.reset();
  frequencyCoverage_Accessor->reset();
}

const uci::type::SignalSummaryType::Modulation& SignalSummaryType::getModulation() const {
  return *modulation_Accessor;
}

uci::type::SignalSummaryType::Modulation& SignalSummaryType::getModulation() {
  return *modulation_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::setModulation(const uci::type::SignalSummaryType::Modulation& accessor) {
  if (&accessor != modulation_Accessor.get()) {
    modulation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::VisibleString64Type& SignalSummaryType::getVendorSpecificModulation_() const {
  if (vendorSpecificModulation_Accessor) {
    return *vendorSpecificModulation_Accessor;
  }
  throw uci::base::UCIException("Error in getVendorSpecificModulation(): An attempt was made to get an optional field that was not enabled, call hasVendorSpecificModulation() to determine if it is safe to call getVendorSpecificModulation()");
}

const uci::type::VisibleString64Type& SignalSummaryType::getVendorSpecificModulation() const {
  return getVendorSpecificModulation_();
}

uci::type::VisibleString64Type& SignalSummaryType::getVendorSpecificModulation() {
  return getVendorSpecificModulation_();
}

uci::type::SignalSummaryType& SignalSummaryType::setVendorSpecificModulation(const uci::type::VisibleString64Type& value) {
  return setVendorSpecificModulation(value.c_str());
}

uci::type::SignalSummaryType& SignalSummaryType::setVendorSpecificModulation(const std::string& value) {
  return setVendorSpecificModulation(value.c_str());
}

uci::type::SignalSummaryType& SignalSummaryType::setVendorSpecificModulation(const char* value) {
  enableVendorSpecificModulation().setStringValue(value);
  return *this;
}

bool SignalSummaryType::hasVendorSpecificModulation() const noexcept {
  return static_cast<bool>(vendorSpecificModulation_Accessor);
}

uci::type::VisibleString64Type& SignalSummaryType::enableVendorSpecificModulation(uci::base::accessorType::AccessorType type) {
  if (!vendorSpecificModulation_Accessor) {
    vendorSpecificModulation_Accessor = VisibleString64Type::create(type);
  }
  return *vendorSpecificModulation_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearVendorSpecificModulation() noexcept {
  vendorSpecificModulation_Accessor.reset();
  return *this;
}

uci::type::FrequencyModulationVariationEnum& SignalSummaryType::getFrequencyModulationVariation_() const {
  if (frequencyModulationVariation_Accessor) {
    return *frequencyModulationVariation_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyModulationVariation(): An attempt was made to get an optional field that was not enabled, call hasFrequencyModulationVariation() to determine if it is safe to call getFrequencyModulationVariation()");
}

const uci::type::FrequencyModulationVariationEnum& SignalSummaryType::getFrequencyModulationVariation() const {
  return getFrequencyModulationVariation_();
}

uci::type::FrequencyModulationVariationEnum& SignalSummaryType::getFrequencyModulationVariation() {
  return getFrequencyModulationVariation_();
}

uci::type::SignalSummaryType& SignalSummaryType::setFrequencyModulationVariation(const uci::type::FrequencyModulationVariationEnum& accessor) {
  enableFrequencyModulationVariation();
  if (&accessor != frequencyModulationVariation_Accessor.get()) {
    frequencyModulationVariation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalSummaryType& SignalSummaryType::setFrequencyModulationVariation(const uci::type::FrequencyModulationVariationEnum::EnumerationItem value) {
  enableFrequencyModulationVariation().setValue(value);
  return *this;
}

bool SignalSummaryType::hasFrequencyModulationVariation() const noexcept {
  return static_cast<bool>(frequencyModulationVariation_Accessor);
}

uci::type::FrequencyModulationVariationEnum& SignalSummaryType::enableFrequencyModulationVariation(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::frequencyModulationVariationEnum : type};
  if ((!frequencyModulationVariation_Accessor) || (frequencyModulationVariation_Accessor->getAccessorType() != requestedType)) {
    frequencyModulationVariation_Accessor = FrequencyModulationVariationEnum::create(requestedType);
    if (!frequencyModulationVariation_Accessor) {
      throw uci::base::UCIException("Error in enableFrequencyModulationVariation(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *frequencyModulationVariation_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearFrequencyModulationVariation() noexcept {
  frequencyModulationVariation_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalSummaryType::getFrequencyAverage() const {
  if (frequencyAverage_Accessor) {
    return *frequencyAverage_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyAverage(): An attempt was made to get an optional field that was not enabled, call hasFrequencyAverage() to determine if it is safe to call getFrequencyAverage()");
}

uci::type::SignalSummaryType& SignalSummaryType::setFrequencyAverage(uci::type::FrequencyTypeValue value) {
  frequencyAverage_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasFrequencyAverage() const noexcept {
  return frequencyAverage_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearFrequencyAverage() noexcept {
  frequencyAverage_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalSummaryType::getFrequencyMin() const {
  if (frequencyMin_Accessor) {
    return *frequencyMin_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyMin(): An attempt was made to get an optional field that was not enabled, call hasFrequencyMin() to determine if it is safe to call getFrequencyMin()");
}

uci::type::SignalSummaryType& SignalSummaryType::setFrequencyMin(uci::type::FrequencyTypeValue value) {
  frequencyMin_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasFrequencyMin() const noexcept {
  return frequencyMin_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearFrequencyMin() noexcept {
  frequencyMin_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue SignalSummaryType::getFrequencyMax() const {
  if (frequencyMax_Accessor) {
    return *frequencyMax_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyMax(): An attempt was made to get an optional field that was not enabled, call hasFrequencyMax() to determine if it is safe to call getFrequencyMax()");
}

uci::type::SignalSummaryType& SignalSummaryType::setFrequencyMax(uci::type::FrequencyTypeValue value) {
  frequencyMax_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasFrequencyMax() const noexcept {
  return frequencyMax_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearFrequencyMax() noexcept {
  frequencyMax_Accessor.reset();
  return *this;
}

uci::type::CoverageEffortEnum& SignalSummaryType::getFrequencyRangeControlOptions_() const {
  if (frequencyRangeControlOptions_Accessor) {
    return *frequencyRangeControlOptions_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequencyRangeControlOptions(): An attempt was made to get an optional field that was not enabled, call hasFrequencyRangeControlOptions() to determine if it is safe to call getFrequencyRangeControlOptions()");
}

const uci::type::CoverageEffortEnum& SignalSummaryType::getFrequencyRangeControlOptions() const {
  return getFrequencyRangeControlOptions_();
}

uci::type::CoverageEffortEnum& SignalSummaryType::getFrequencyRangeControlOptions() {
  return getFrequencyRangeControlOptions_();
}

uci::type::SignalSummaryType& SignalSummaryType::setFrequencyRangeControlOptions(const uci::type::CoverageEffortEnum& accessor) {
  enableFrequencyRangeControlOptions();
  if (&accessor != frequencyRangeControlOptions_Accessor.get()) {
    frequencyRangeControlOptions_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalSummaryType& SignalSummaryType::setFrequencyRangeControlOptions(const uci::type::CoverageEffortEnum::EnumerationItem value) {
  enableFrequencyRangeControlOptions().setValue(value);
  return *this;
}

bool SignalSummaryType::hasFrequencyRangeControlOptions() const noexcept {
  return static_cast<bool>(frequencyRangeControlOptions_Accessor);
}

uci::type::CoverageEffortEnum& SignalSummaryType::enableFrequencyRangeControlOptions(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::coverageEffortEnum : type};
  if ((!frequencyRangeControlOptions_Accessor) || (frequencyRangeControlOptions_Accessor->getAccessorType() != requestedType)) {
    frequencyRangeControlOptions_Accessor = CoverageEffortEnum::create(requestedType);
    if (!frequencyRangeControlOptions_Accessor) {
      throw uci::base::UCIException("Error in enableFrequencyRangeControlOptions(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *frequencyRangeControlOptions_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearFrequencyRangeControlOptions() noexcept {
  frequencyRangeControlOptions_Accessor.reset();
  return *this;
}

uci::type::PRI_TypeEnum& SignalSummaryType::getPRI_Type_() const {
  if (pRI_Type_Accessor) {
    return *pRI_Type_Accessor;
  }
  throw uci::base::UCIException("Error in getPRI_Type(): An attempt was made to get an optional field that was not enabled, call hasPRI_Type() to determine if it is safe to call getPRI_Type()");
}

const uci::type::PRI_TypeEnum& SignalSummaryType::getPRI_Type() const {
  return getPRI_Type_();
}

uci::type::PRI_TypeEnum& SignalSummaryType::getPRI_Type() {
  return getPRI_Type_();
}

uci::type::SignalSummaryType& SignalSummaryType::setPRI_Type(const uci::type::PRI_TypeEnum& accessor) {
  enablePRI_Type();
  if (&accessor != pRI_Type_Accessor.get()) {
    pRI_Type_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalSummaryType& SignalSummaryType::setPRI_Type(const uci::type::PRI_TypeEnum::EnumerationItem value) {
  enablePRI_Type().setValue(value);
  return *this;
}

bool SignalSummaryType::hasPRI_Type() const noexcept {
  return static_cast<bool>(pRI_Type_Accessor);
}

uci::type::PRI_TypeEnum& SignalSummaryType::enablePRI_Type(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::pRI_TypeEnum : type};
  if ((!pRI_Type_Accessor) || (pRI_Type_Accessor->getAccessorType() != requestedType)) {
    pRI_Type_Accessor = PRI_TypeEnum::create(requestedType);
    if (!pRI_Type_Accessor) {
      throw uci::base::UCIException("Error in enablePRI_Type(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *pRI_Type_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearPRI_Type() noexcept {
  pRI_Type_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalSummaryType::getPRI_Average() const {
  if (pRI_Average_Accessor) {
    return *pRI_Average_Accessor;
  }
  throw uci::base::UCIException("Error in getPRI_Average(): An attempt was made to get an optional field that was not enabled, call hasPRI_Average() to determine if it is safe to call getPRI_Average()");
}

uci::type::SignalSummaryType& SignalSummaryType::setPRI_Average(uci::type::DurationTypeValue value) {
  pRI_Average_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasPRI_Average() const noexcept {
  return pRI_Average_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearPRI_Average() noexcept {
  pRI_Average_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalSummaryType::getPRI_Min() const {
  if (pRI_Min_Accessor) {
    return *pRI_Min_Accessor;
  }
  throw uci::base::UCIException("Error in getPRI_Min(): An attempt was made to get an optional field that was not enabled, call hasPRI_Min() to determine if it is safe to call getPRI_Min()");
}

uci::type::SignalSummaryType& SignalSummaryType::setPRI_Min(uci::type::DurationTypeValue value) {
  pRI_Min_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasPRI_Min() const noexcept {
  return pRI_Min_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearPRI_Min() noexcept {
  pRI_Min_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalSummaryType::getPRI_Max() const {
  if (pRI_Max_Accessor) {
    return *pRI_Max_Accessor;
  }
  throw uci::base::UCIException("Error in getPRI_Max(): An attempt was made to get an optional field that was not enabled, call hasPRI_Max() to determine if it is safe to call getPRI_Max()");
}

uci::type::SignalSummaryType& SignalSummaryType::setPRI_Max(uci::type::DurationTypeValue value) {
  pRI_Max_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasPRI_Max() const noexcept {
  return pRI_Max_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearPRI_Max() noexcept {
  pRI_Max_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalSummaryType::getPulseWidthAverage() const {
  if (pulseWidthAverage_Accessor) {
    return *pulseWidthAverage_Accessor;
  }
  throw uci::base::UCIException("Error in getPulseWidthAverage(): An attempt was made to get an optional field that was not enabled, call hasPulseWidthAverage() to determine if it is safe to call getPulseWidthAverage()");
}

uci::type::SignalSummaryType& SignalSummaryType::setPulseWidthAverage(uci::type::DurationTypeValue value) {
  pulseWidthAverage_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasPulseWidthAverage() const noexcept {
  return pulseWidthAverage_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearPulseWidthAverage() noexcept {
  pulseWidthAverage_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalSummaryType::getPulseWidthMin() const {
  if (pulseWidthMin_Accessor) {
    return *pulseWidthMin_Accessor;
  }
  throw uci::base::UCIException("Error in getPulseWidthMin(): An attempt was made to get an optional field that was not enabled, call hasPulseWidthMin() to determine if it is safe to call getPulseWidthMin()");
}

uci::type::SignalSummaryType& SignalSummaryType::setPulseWidthMin(uci::type::DurationTypeValue value) {
  pulseWidthMin_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasPulseWidthMin() const noexcept {
  return pulseWidthMin_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearPulseWidthMin() noexcept {
  pulseWidthMin_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue SignalSummaryType::getPulseWidthMax() const {
  if (pulseWidthMax_Accessor) {
    return *pulseWidthMax_Accessor;
  }
  throw uci::base::UCIException("Error in getPulseWidthMax(): An attempt was made to get an optional field that was not enabled, call hasPulseWidthMax() to determine if it is safe to call getPulseWidthMax()");
}

uci::type::SignalSummaryType& SignalSummaryType::setPulseWidthMax(uci::type::DurationTypeValue value) {
  pulseWidthMax_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasPulseWidthMax() const noexcept {
  return pulseWidthMax_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearPulseWidthMax() noexcept {
  pulseWidthMax_Accessor.reset();
  return *this;
}

uci::type::FrequencyRangeType& SignalSummaryType::getSignalBandwidth_() const {
  if (signalBandwidth_Accessor) {
    return *signalBandwidth_Accessor;
  }
  throw uci::base::UCIException("Error in getSignalBandwidth(): An attempt was made to get an optional field that was not enabled, call hasSignalBandwidth() to determine if it is safe to call getSignalBandwidth()");
}

const uci::type::FrequencyRangeType& SignalSummaryType::getSignalBandwidth() const {
  return getSignalBandwidth_();
}

uci::type::FrequencyRangeType& SignalSummaryType::getSignalBandwidth() {
  return getSignalBandwidth_();
}

uci::type::SignalSummaryType& SignalSummaryType::setSignalBandwidth(const uci::type::FrequencyRangeType& accessor) {
  enableSignalBandwidth();
  if (&accessor != signalBandwidth_Accessor.get()) {
    signalBandwidth_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalSummaryType::hasSignalBandwidth() const noexcept {
  return static_cast<bool>(signalBandwidth_Accessor);
}

uci::type::FrequencyRangeType& SignalSummaryType::enableSignalBandwidth(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::frequencyRangeType : type};
  if ((!signalBandwidth_Accessor) || (signalBandwidth_Accessor->getAccessorType() != requestedType)) {
    signalBandwidth_Accessor = FrequencyRangeType::create(requestedType);
    if (!signalBandwidth_Accessor) {
      throw uci::base::UCIException("Error in enableSignalBandwidth(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *signalBandwidth_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearSignalBandwidth() noexcept {
  signalBandwidth_Accessor.reset();
  return *this;
}

uci::type::MilliwattPowerRatioTypeValue SignalSummaryType::getAmplitudeAverage() const {
  if (amplitudeAverage_Accessor) {
    return *amplitudeAverage_Accessor;
  }
  throw uci::base::UCIException("Error in getAmplitudeAverage(): An attempt was made to get an optional field that was not enabled, call hasAmplitudeAverage() to determine if it is safe to call getAmplitudeAverage()");
}

uci::type::SignalSummaryType& SignalSummaryType::setAmplitudeAverage(uci::type::MilliwattPowerRatioTypeValue value) {
  amplitudeAverage_Accessor = value;
  return *this;
}

bool SignalSummaryType::hasAmplitudeAverage() const noexcept {
  return amplitudeAverage_Accessor.has_value();
}

uci::type::SignalSummaryType& SignalSummaryType::clearAmplitudeAverage() noexcept {
  amplitudeAverage_Accessor.reset();
  return *this;
}

uci::type::TrackModeEnum& SignalSummaryType::getTrackMode_() const {
  if (trackMode_Accessor) {
    return *trackMode_Accessor;
  }
  throw uci::base::UCIException("Error in getTrackMode(): An attempt was made to get an optional field that was not enabled, call hasTrackMode() to determine if it is safe to call getTrackMode()");
}

const uci::type::TrackModeEnum& SignalSummaryType::getTrackMode() const {
  return getTrackMode_();
}

uci::type::TrackModeEnum& SignalSummaryType::getTrackMode() {
  return getTrackMode_();
}

uci::type::SignalSummaryType& SignalSummaryType::setTrackMode(const uci::type::TrackModeEnum& accessor) {
  enableTrackMode();
  if (&accessor != trackMode_Accessor.get()) {
    trackMode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalSummaryType& SignalSummaryType::setTrackMode(const uci::type::TrackModeEnum::EnumerationItem value) {
  enableTrackMode().setValue(value);
  return *this;
}

bool SignalSummaryType::hasTrackMode() const noexcept {
  return static_cast<bool>(trackMode_Accessor);
}

uci::type::TrackModeEnum& SignalSummaryType::enableTrackMode(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::trackModeEnum : type};
  if ((!trackMode_Accessor) || (trackMode_Accessor->getAccessorType() != requestedType)) {
    trackMode_Accessor = TrackModeEnum::create(requestedType);
    if (!trackMode_Accessor) {
      throw uci::base::UCIException("Error in enableTrackMode(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *trackMode_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearTrackMode() noexcept {
  trackMode_Accessor.reset();
  return *this;
}

uci::type::EmitterUrgencyEnum& SignalSummaryType::getUrgency_() const {
  if (urgency_Accessor) {
    return *urgency_Accessor;
  }
  throw uci::base::UCIException("Error in getUrgency(): An attempt was made to get an optional field that was not enabled, call hasUrgency() to determine if it is safe to call getUrgency()");
}

const uci::type::EmitterUrgencyEnum& SignalSummaryType::getUrgency() const {
  return getUrgency_();
}

uci::type::EmitterUrgencyEnum& SignalSummaryType::getUrgency() {
  return getUrgency_();
}

uci::type::SignalSummaryType& SignalSummaryType::setUrgency(const uci::type::EmitterUrgencyEnum& accessor) {
  enableUrgency();
  if (&accessor != urgency_Accessor.get()) {
    urgency_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalSummaryType& SignalSummaryType::setUrgency(const uci::type::EmitterUrgencyEnum::EnumerationItem value) {
  enableUrgency().setValue(value);
  return *this;
}

bool SignalSummaryType::hasUrgency() const noexcept {
  return static_cast<bool>(urgency_Accessor);
}

uci::type::EmitterUrgencyEnum& SignalSummaryType::enableUrgency(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::emitterUrgencyEnum : type};
  if ((!urgency_Accessor) || (urgency_Accessor->getAccessorType() != requestedType)) {
    urgency_Accessor = EmitterUrgencyEnum::create(requestedType);
    if (!urgency_Accessor) {
      throw uci::base::UCIException("Error in enableUrgency(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *urgency_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearUrgency() noexcept {
  urgency_Accessor.reset();
  return *this;
}

uci::type::EmptyType& SignalSummaryType::getWartimeReserve_() const {
  if (wartimeReserve_Accessor) {
    return *wartimeReserve_Accessor;
  }
  throw uci::base::UCIException("Error in getWartimeReserve(): An attempt was made to get an optional field that was not enabled, call hasWartimeReserve() to determine if it is safe to call getWartimeReserve()");
}

const uci::type::EmptyType& SignalSummaryType::getWartimeReserve() const {
  return getWartimeReserve_();
}

uci::type::EmptyType& SignalSummaryType::getWartimeReserve() {
  return getWartimeReserve_();
}

uci::type::SignalSummaryType& SignalSummaryType::setWartimeReserve(const uci::type::EmptyType& value) {
  return setWartimeReserve(value.c_str());
}

uci::type::SignalSummaryType& SignalSummaryType::setWartimeReserve(const std::string& value) {
  return setWartimeReserve(value.c_str());
}

uci::type::SignalSummaryType& SignalSummaryType::setWartimeReserve(const char* value) {
  enableWartimeReserve().setStringValue(value);
  return *this;
}

bool SignalSummaryType::hasWartimeReserve() const noexcept {
  return static_cast<bool>(wartimeReserve_Accessor);
}

uci::type::EmptyType& SignalSummaryType::enableWartimeReserve(uci::base::accessorType::AccessorType type) {
  if (!wartimeReserve_Accessor) {
    wartimeReserve_Accessor = EmptyType::create(type);
  }
  return *wartimeReserve_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearWartimeReserve() noexcept {
  wartimeReserve_Accessor.reset();
  return *this;
}

uci::type::SignalLocationEnum& SignalSummaryType::getLocationCategory_() const {
  if (locationCategory_Accessor) {
    return *locationCategory_Accessor;
  }
  throw uci::base::UCIException("Error in getLocationCategory(): An attempt was made to get an optional field that was not enabled, call hasLocationCategory() to determine if it is safe to call getLocationCategory()");
}

const uci::type::SignalLocationEnum& SignalSummaryType::getLocationCategory() const {
  return getLocationCategory_();
}

uci::type::SignalLocationEnum& SignalSummaryType::getLocationCategory() {
  return getLocationCategory_();
}

uci::type::SignalSummaryType& SignalSummaryType::setLocationCategory(const uci::type::SignalLocationEnum& accessor) {
  enableLocationCategory();
  if (&accessor != locationCategory_Accessor.get()) {
    locationCategory_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalSummaryType& SignalSummaryType::setLocationCategory(const uci::type::SignalLocationEnum::EnumerationItem value) {
  enableLocationCategory().setValue(value);
  return *this;
}

bool SignalSummaryType::hasLocationCategory() const noexcept {
  return static_cast<bool>(locationCategory_Accessor);
}

uci::type::SignalLocationEnum& SignalSummaryType::enableLocationCategory(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalLocationEnum : type};
  if ((!locationCategory_Accessor) || (locationCategory_Accessor->getAccessorType() != requestedType)) {
    locationCategory_Accessor = SignalLocationEnum::create(requestedType);
    if (!locationCategory_Accessor) {
      throw uci::base::UCIException("Error in enableLocationCategory(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *locationCategory_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearLocationCategory() noexcept {
  locationCategory_Accessor.reset();
  return *this;
}

uci::type::RadarBeamTypeEnum& SignalSummaryType::getTypeOfBeam_() const {
  if (typeOfBeam_Accessor) {
    return *typeOfBeam_Accessor;
  }
  throw uci::base::UCIException("Error in getTypeOfBeam(): An attempt was made to get an optional field that was not enabled, call hasTypeOfBeam() to determine if it is safe to call getTypeOfBeam()");
}

const uci::type::RadarBeamTypeEnum& SignalSummaryType::getTypeOfBeam() const {
  return getTypeOfBeam_();
}

uci::type::RadarBeamTypeEnum& SignalSummaryType::getTypeOfBeam() {
  return getTypeOfBeam_();
}

uci::type::SignalSummaryType& SignalSummaryType::setTypeOfBeam(const uci::type::RadarBeamTypeEnum& accessor) {
  enableTypeOfBeam();
  if (&accessor != typeOfBeam_Accessor.get()) {
    typeOfBeam_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalSummaryType& SignalSummaryType::setTypeOfBeam(const uci::type::RadarBeamTypeEnum::EnumerationItem value) {
  enableTypeOfBeam().setValue(value);
  return *this;
}

bool SignalSummaryType::hasTypeOfBeam() const noexcept {
  return static_cast<bool>(typeOfBeam_Accessor);
}

uci::type::RadarBeamTypeEnum& SignalSummaryType::enableTypeOfBeam(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::radarBeamTypeEnum : type};
  if ((!typeOfBeam_Accessor) || (typeOfBeam_Accessor->getAccessorType() != requestedType)) {
    typeOfBeam_Accessor = RadarBeamTypeEnum::create(requestedType);
    if (!typeOfBeam_Accessor) {
      throw uci::base::UCIException("Error in enableTypeOfBeam(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *typeOfBeam_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearTypeOfBeam() noexcept {
  typeOfBeam_Accessor.reset();
  return *this;
}

uci::type::RadarBeamPersistenceEnum& SignalSummaryType::getBeamPersistence_() const {
  if (beamPersistence_Accessor) {
    return *beamPersistence_Accessor;
  }
  throw uci::base::UCIException("Error in getBeamPersistence(): An attempt was made to get an optional field that was not enabled, call hasBeamPersistence() to determine if it is safe to call getBeamPersistence()");
}

const uci::type::RadarBeamPersistenceEnum& SignalSummaryType::getBeamPersistence() const {
  return getBeamPersistence_();
}

uci::type::RadarBeamPersistenceEnum& SignalSummaryType::getBeamPersistence() {
  return getBeamPersistence_();
}

uci::type::SignalSummaryType& SignalSummaryType::setBeamPersistence(const uci::type::RadarBeamPersistenceEnum& accessor) {
  enableBeamPersistence();
  if (&accessor != beamPersistence_Accessor.get()) {
    beamPersistence_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalSummaryType& SignalSummaryType::setBeamPersistence(const uci::type::RadarBeamPersistenceEnum::EnumerationItem value) {
  enableBeamPersistence().setValue(value);
  return *this;
}

bool SignalSummaryType::hasBeamPersistence() const noexcept {
  return static_cast<bool>(beamPersistence_Accessor);
}

uci::type::RadarBeamPersistenceEnum& SignalSummaryType::enableBeamPersistence(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::radarBeamPersistenceEnum : type};
  if ((!beamPersistence_Accessor) || (beamPersistence_Accessor->getAccessorType() != requestedType)) {
    beamPersistence_Accessor = RadarBeamPersistenceEnum::create(requestedType);
    if (!beamPersistence_Accessor) {
      throw uci::base::UCIException("Error in enableBeamPersistence(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *beamPersistence_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::clearBeamPersistence() noexcept {
  beamPersistence_Accessor.reset();
  return *this;
}

const uci::type::SignalSummaryType::FrequencyCoverage& SignalSummaryType::getFrequencyCoverage() const {
  return *frequencyCoverage_Accessor;
}

uci::type::SignalSummaryType::FrequencyCoverage& SignalSummaryType::getFrequencyCoverage() {
  return *frequencyCoverage_Accessor;
}

uci::type::SignalSummaryType& SignalSummaryType::setFrequencyCoverage(const uci::type::SignalSummaryType::FrequencyCoverage& accessor) {
  if (&accessor != frequencyCoverage_Accessor.get()) {
    frequencyCoverage_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

std::unique_ptr<SignalSummaryType> SignalSummaryType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalSummaryType : type};
  return (requestedType == uci::type::accessorType::signalSummaryType) ? boost::make_unique<SignalSummaryType>() : nullptr;
}

/**  */
namespace SignalSummaryType_Names {

constexpr const char* Extern_Type_Name{"SignalSummaryType"};
constexpr const char* Modulation_Name{"Modulation"};
constexpr const char* VendorSpecificModulation_Name{"VendorSpecificModulation"};
constexpr const char* FrequencyModulationVariation_Name{"FrequencyModulationVariation"};
constexpr const char* FrequencyAverage_Name{"FrequencyAverage"};
constexpr const char* FrequencyMin_Name{"FrequencyMin"};
constexpr const char* FrequencyMax_Name{"FrequencyMax"};
constexpr const char* FrequencyRangeControlOptions_Name{"FrequencyRangeControlOptions"};
constexpr const char* PRI_Type_Name{"PRI_Type"};
constexpr const char* PRI_Average_Name{"PRI_Average"};
constexpr const char* PRI_Min_Name{"PRI_Min"};
constexpr const char* PRI_Max_Name{"PRI_Max"};
constexpr const char* PulseWidthAverage_Name{"PulseWidthAverage"};
constexpr const char* PulseWidthMin_Name{"PulseWidthMin"};
constexpr const char* PulseWidthMax_Name{"PulseWidthMax"};
constexpr const char* SignalBandwidth_Name{"SignalBandwidth"};
constexpr const char* AmplitudeAverage_Name{"AmplitudeAverage"};
constexpr const char* TrackMode_Name{"TrackMode"};
constexpr const char* Urgency_Name{"Urgency"};
constexpr const char* WartimeReserve_Name{"WartimeReserve"};
constexpr const char* LocationCategory_Name{"LocationCategory"};
constexpr const char* TypeOfBeam_Name{"TypeOfBeam"};
constexpr const char* BeamPersistence_Name{"BeamPersistence"};
constexpr const char* FrequencyCoverage_Name{"FrequencyCoverage"};

} // namespace SignalSummaryType_Names

void SignalSummaryType::deserialize(const boost::property_tree::ptree& propTree, uci::type::SignalSummaryType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = SignalSummaryType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::Modulation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SignalSummaryType::Modulation& boundedList = accessor.getModulation();
        const uci::type::SignalSummaryType::Modulation::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::VendorSpecificModulation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setVendorSpecificModulation(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::FrequencyModulationVariation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableFrequencyModulationVariation().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::FrequencyAverage_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFrequencyAverage(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::FrequencyMin_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFrequencyMin(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::FrequencyMax_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFrequencyMax(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::FrequencyRangeControlOptions_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableFrequencyRangeControlOptions().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::PRI_Type_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enablePRI_Type().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::PRI_Average_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPRI_Average(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::PRI_Min_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPRI_Min(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::PRI_Max_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPRI_Max(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::PulseWidthAverage_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPulseWidthAverage(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::PulseWidthMin_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPulseWidthMin(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::PulseWidthMax_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPulseWidthMax(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::SignalBandwidth_Name) {
      FrequencyRangeType::deserialize(valueType.second, accessor.enableSignalBandwidth(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::AmplitudeAverage_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAmplitudeAverage(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::TrackMode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableTrackMode().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::Urgency_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableUrgency().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::WartimeReserve_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setWartimeReserve(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::LocationCategory_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableLocationCategory().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::TypeOfBeam_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableTypeOfBeam().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::BeamPersistence_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableBeamPersistence().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalSummaryType_Names::FrequencyCoverage_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SignalSummaryType::FrequencyCoverage& boundedList = accessor.getFrequencyCoverage();
        const uci::type::SignalSummaryType::FrequencyCoverage::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::FrequencyControlType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    }
  }
}

std::string SignalSummaryType::serialize(const uci::type::SignalSummaryType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? SignalSummaryType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, SignalSummaryType_Names::Extern_Type_Name);
  }
  {
    const uci::type::SignalSummaryType::Modulation& boundedList = accessor.getModulation();
    for (uci::type::SignalSummaryType::Modulation::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      ModulationEnum::serialize(boundedList.at(i), node, SignalSummaryType_Names::Modulation_Name, false);
    }
  }
  if (accessor.hasVendorSpecificModulation()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getVendorSpecificModulation(), node, SignalSummaryType_Names::VendorSpecificModulation_Name);
  }
  if (accessor.hasFrequencyModulationVariation()) {
    FrequencyModulationVariationEnum::serialize(accessor.getFrequencyModulationVariation(), node, SignalSummaryType_Names::FrequencyModulationVariation_Name, false);
  }
  if (accessor.hasFrequencyAverage()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getFrequencyAverage(), node, SignalSummaryType_Names::FrequencyAverage_Name);
  }
  if (accessor.hasFrequencyMin()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getFrequencyMin(), node, SignalSummaryType_Names::FrequencyMin_Name);
  }
  if (accessor.hasFrequencyMax()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getFrequencyMax(), node, SignalSummaryType_Names::FrequencyMax_Name);
  }
  if (accessor.hasFrequencyRangeControlOptions()) {
    CoverageEffortEnum::serialize(accessor.getFrequencyRangeControlOptions(), node, SignalSummaryType_Names::FrequencyRangeControlOptions_Name, false);
  }
  if (accessor.hasPRI_Type()) {
    PRI_TypeEnum::serialize(accessor.getPRI_Type(), node, SignalSummaryType_Names::PRI_Type_Name, false);
  }
  if (accessor.hasPRI_Average()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getPRI_Average(), node, SignalSummaryType_Names::PRI_Average_Name);
  }
  if (accessor.hasPRI_Min()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getPRI_Min(), node, SignalSummaryType_Names::PRI_Min_Name);
  }
  if (accessor.hasPRI_Max()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getPRI_Max(), node, SignalSummaryType_Names::PRI_Max_Name);
  }
  if (accessor.hasPulseWidthAverage()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getPulseWidthAverage(), node, SignalSummaryType_Names::PulseWidthAverage_Name);
  }
  if (accessor.hasPulseWidthMin()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getPulseWidthMin(), node, SignalSummaryType_Names::PulseWidthMin_Name);
  }
  if (accessor.hasPulseWidthMax()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getPulseWidthMax(), node, SignalSummaryType_Names::PulseWidthMax_Name);
  }
  if (accessor.hasSignalBandwidth()) {
    FrequencyRangeType::serialize(accessor.getSignalBandwidth(), node, SignalSummaryType_Names::SignalBandwidth_Name);
  }
  if (accessor.hasAmplitudeAverage()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getAmplitudeAverage(), node, SignalSummaryType_Names::AmplitudeAverage_Name);
  }
  if (accessor.hasTrackMode()) {
    TrackModeEnum::serialize(accessor.getTrackMode(), node, SignalSummaryType_Names::TrackMode_Name, false);
  }
  if (accessor.hasUrgency()) {
    EmitterUrgencyEnum::serialize(accessor.getUrgency(), node, SignalSummaryType_Names::Urgency_Name, false);
  }
  if (accessor.hasWartimeReserve()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getWartimeReserve(), node, SignalSummaryType_Names::WartimeReserve_Name);
  }
  if (accessor.hasLocationCategory()) {
    SignalLocationEnum::serialize(accessor.getLocationCategory(), node, SignalSummaryType_Names::LocationCategory_Name, false);
  }
  if (accessor.hasTypeOfBeam()) {
    RadarBeamTypeEnum::serialize(accessor.getTypeOfBeam(), node, SignalSummaryType_Names::TypeOfBeam_Name, false);
  }
  if (accessor.hasBeamPersistence()) {
    RadarBeamPersistenceEnum::serialize(accessor.getBeamPersistence(), node, SignalSummaryType_Names::BeamPersistence_Name, false);
  }
  {
    const uci::type::SignalSummaryType::FrequencyCoverage& boundedList = accessor.getFrequencyCoverage();
    for (uci::type::SignalSummaryType::FrequencyCoverage::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::FrequencyControlType::serialize(boundedList.at(i), node, SignalSummaryType_Names::FrequencyCoverage_Name);
    }
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::SignalSummaryType& SignalSummaryType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::SignalSummaryType>().release());
}

uci::type::SignalSummaryType& SignalSummaryType::create(const uci::type::SignalSummaryType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::SignalSummaryType> newAccessor{boost::make_unique<asb_uci::type::SignalSummaryType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void SignalSummaryType::destroy(uci::type::SignalSummaryType& accessor) {
  delete dynamic_cast<asb_uci::type::SignalSummaryType*>(&accessor);
}

} // namespace type

} // namespace uci

