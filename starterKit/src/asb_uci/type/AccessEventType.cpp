/** @file AccessEventType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:11 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/AccessEventType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/AccessEffortEnum.h"
#include "../../../include/asb_uci/type/EnduranceMultiStandardType.h"
#include "../../../include/asb_uci/type/KinematicsMultiStandardType.h"
#include "../../../include/asb_uci/type/ManeuverMultiStandardType.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/AccessEffortEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/AccessEventType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DateTimeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DistanceType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DurationType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/EnduranceMultiStandardType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/KinematicsMultiStandardType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ManeuverMultiStandardType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PercentType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

AccessEventType::AccessEventType()
  : effort_Accessor{boost::make_unique<AccessEffortEnum>()} {
}

AccessEventType::~AccessEventType() = default;

void AccessEventType::copy(const uci::type::AccessEventType& accessor) {
  copyImpl(accessor, false);
}

void AccessEventType::copyImpl(const uci::type::AccessEventType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const AccessEventType&>(accessor);
    setEffort(*(accessorImpl.effort_Accessor));
    setTime(accessorImpl.time_Accessor);
    if (accessorImpl.hasDuration()) {
      setDuration(accessorImpl.getDuration());
    } else {
      clearDuration();
    }
    if (accessorImpl.hasProbabilityOfAccessAttempt()) {
      setProbabilityOfAccessAttempt(accessorImpl.getProbabilityOfAccessAttempt());
    } else {
      clearProbabilityOfAccessAttempt();
    }
    if (accessorImpl.hasProbabilityOfSuccessfulAccess()) {
      setProbabilityOfSuccessfulAccess(accessorImpl.getProbabilityOfSuccessfulAccess());
    } else {
      clearProbabilityOfSuccessfulAccess();
    }
    if (accessorImpl.subjectObjectKinematics_Accessor) {
      setSubjectObjectKinematics(*(accessorImpl.subjectObjectKinematics_Accessor));
    } else {
      subjectObjectKinematics_Accessor.reset();
    }
    if (accessorImpl.assessedObjectKinematics_Accessor) {
      setAssessedObjectKinematics(*(accessorImpl.assessedObjectKinematics_Accessor));
    } else {
      assessedObjectKinematics_Accessor.reset();
    }
    if (accessorImpl.hasObjectSeparation()) {
      setObjectSeparation(accessorImpl.getObjectSeparation());
    } else {
      clearObjectSeparation();
    }
    if (accessorImpl.hasUnambiguousTime()) {
      setUnambiguousTime(accessorImpl.getUnambiguousTime());
    } else {
      clearUnambiguousTime();
    }
    if (accessorImpl.resourceConsumption_Accessor) {
      setResourceConsumption(*(accessorImpl.resourceConsumption_Accessor));
    } else {
      resourceConsumption_Accessor.reset();
    }
    if (accessorImpl.assessedObjectManeuver_Accessor) {
      setAssessedObjectManeuver(*(accessorImpl.assessedObjectManeuver_Accessor));
    } else {
      assessedObjectManeuver_Accessor.reset();
    }
  }
}

void AccessEventType::reset() noexcept {
  effort_Accessor->reset();
  time_Accessor = 0;
  clearDuration();
  clearProbabilityOfAccessAttempt();
  clearProbabilityOfSuccessfulAccess();
  subjectObjectKinematics_Accessor.reset();
  assessedObjectKinematics_Accessor.reset();
  clearObjectSeparation();
  clearUnambiguousTime();
  resourceConsumption_Accessor.reset();
  assessedObjectManeuver_Accessor.reset();
}

const uci::type::AccessEffortEnum& AccessEventType::getEffort() const {
  return *effort_Accessor;
}

uci::type::AccessEffortEnum& AccessEventType::getEffort() {
  return *effort_Accessor;
}

uci::type::AccessEventType& AccessEventType::setEffort(const uci::type::AccessEffortEnum& accessor) {
  if (&accessor != effort_Accessor.get()) {
    effort_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::AccessEventType& AccessEventType::setEffort(uci::type::AccessEffortEnum::EnumerationItem value) {
  effort_Accessor->setValue(value);
  return *this;
}


uci::type::DateTimeTypeValue AccessEventType::getTime() const {
  return time_Accessor;
}

uci::type::AccessEventType& AccessEventType::setTime(uci::type::DateTimeTypeValue value) {
  time_Accessor = value;
  return *this;
}


uci::type::DurationTypeValue AccessEventType::getDuration() const {
  if (duration_Accessor) {
    return *duration_Accessor;
  }
  throw uci::base::UCIException("Error in getDuration(): An attempt was made to get an optional field that was not enabled, call hasDuration() to determine if it is safe to call getDuration()");
}

uci::type::AccessEventType& AccessEventType::setDuration(uci::type::DurationTypeValue value) {
  duration_Accessor = value;
  return *this;
}

bool AccessEventType::hasDuration() const noexcept {
  return duration_Accessor.has_value();
}

uci::type::AccessEventType& AccessEventType::clearDuration() noexcept {
  duration_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue AccessEventType::getProbabilityOfAccessAttempt() const {
  if (probabilityOfAccessAttempt_Accessor) {
    return *probabilityOfAccessAttempt_Accessor;
  }
  throw uci::base::UCIException("Error in getProbabilityOfAccessAttempt(): An attempt was made to get an optional field that was not enabled, call hasProbabilityOfAccessAttempt() to determine if it is safe to call getProbabilityOfAccessAttempt()");
}

uci::type::AccessEventType& AccessEventType::setProbabilityOfAccessAttempt(uci::type::PercentTypeValue value) {
  probabilityOfAccessAttempt_Accessor = value;
  return *this;
}

bool AccessEventType::hasProbabilityOfAccessAttempt() const noexcept {
  return probabilityOfAccessAttempt_Accessor.has_value();
}

uci::type::AccessEventType& AccessEventType::clearProbabilityOfAccessAttempt() noexcept {
  probabilityOfAccessAttempt_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue AccessEventType::getProbabilityOfSuccessfulAccess() const {
  if (probabilityOfSuccessfulAccess_Accessor) {
    return *probabilityOfSuccessfulAccess_Accessor;
  }
  throw uci::base::UCIException("Error in getProbabilityOfSuccessfulAccess(): An attempt was made to get an optional field that was not enabled, call hasProbabilityOfSuccessfulAccess() to determine if it is safe to call getProbabilityOfSuccessfulAccess()");
}

uci::type::AccessEventType& AccessEventType::setProbabilityOfSuccessfulAccess(uci::type::PercentTypeValue value) {
  probabilityOfSuccessfulAccess_Accessor = value;
  return *this;
}

bool AccessEventType::hasProbabilityOfSuccessfulAccess() const noexcept {
  return probabilityOfSuccessfulAccess_Accessor.has_value();
}

uci::type::AccessEventType& AccessEventType::clearProbabilityOfSuccessfulAccess() noexcept {
  probabilityOfSuccessfulAccess_Accessor.reset();
  return *this;
}

uci::type::KinematicsMultiStandardType& AccessEventType::getSubjectObjectKinematics_() const {
  if (subjectObjectKinematics_Accessor) {
    return *subjectObjectKinematics_Accessor;
  }
  throw uci::base::UCIException("Error in getSubjectObjectKinematics(): An attempt was made to get an optional field that was not enabled, call hasSubjectObjectKinematics() to determine if it is safe to call getSubjectObjectKinematics()");
}

const uci::type::KinematicsMultiStandardType& AccessEventType::getSubjectObjectKinematics() const {
  return getSubjectObjectKinematics_();
}

uci::type::KinematicsMultiStandardType& AccessEventType::getSubjectObjectKinematics() {
  return getSubjectObjectKinematics_();
}

uci::type::AccessEventType& AccessEventType::setSubjectObjectKinematics(const uci::type::KinematicsMultiStandardType& accessor) {
  enableSubjectObjectKinematics();
  if (&accessor != subjectObjectKinematics_Accessor.get()) {
    subjectObjectKinematics_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool AccessEventType::hasSubjectObjectKinematics() const noexcept {
  return static_cast<bool>(subjectObjectKinematics_Accessor);
}

uci::type::KinematicsMultiStandardType& AccessEventType::enableSubjectObjectKinematics(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::kinematicsMultiStandardType : type};
  if ((!subjectObjectKinematics_Accessor) || (subjectObjectKinematics_Accessor->getAccessorType() != requestedType)) {
    subjectObjectKinematics_Accessor = KinematicsMultiStandardType::create(requestedType);
    if (!subjectObjectKinematics_Accessor) {
      throw uci::base::UCIException("Error in enableSubjectObjectKinematics(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *subjectObjectKinematics_Accessor;
}

uci::type::AccessEventType& AccessEventType::clearSubjectObjectKinematics() noexcept {
  subjectObjectKinematics_Accessor.reset();
  return *this;
}

uci::type::KinematicsMultiStandardType& AccessEventType::getAssessedObjectKinematics_() const {
  if (assessedObjectKinematics_Accessor) {
    return *assessedObjectKinematics_Accessor;
  }
  throw uci::base::UCIException("Error in getAssessedObjectKinematics(): An attempt was made to get an optional field that was not enabled, call hasAssessedObjectKinematics() to determine if it is safe to call getAssessedObjectKinematics()");
}

const uci::type::KinematicsMultiStandardType& AccessEventType::getAssessedObjectKinematics() const {
  return getAssessedObjectKinematics_();
}

uci::type::KinematicsMultiStandardType& AccessEventType::getAssessedObjectKinematics() {
  return getAssessedObjectKinematics_();
}

uci::type::AccessEventType& AccessEventType::setAssessedObjectKinematics(const uci::type::KinematicsMultiStandardType& accessor) {
  enableAssessedObjectKinematics();
  if (&accessor != assessedObjectKinematics_Accessor.get()) {
    assessedObjectKinematics_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool AccessEventType::hasAssessedObjectKinematics() const noexcept {
  return static_cast<bool>(assessedObjectKinematics_Accessor);
}

uci::type::KinematicsMultiStandardType& AccessEventType::enableAssessedObjectKinematics(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::kinematicsMultiStandardType : type};
  if ((!assessedObjectKinematics_Accessor) || (assessedObjectKinematics_Accessor->getAccessorType() != requestedType)) {
    assessedObjectKinematics_Accessor = KinematicsMultiStandardType::create(requestedType);
    if (!assessedObjectKinematics_Accessor) {
      throw uci::base::UCIException("Error in enableAssessedObjectKinematics(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *assessedObjectKinematics_Accessor;
}

uci::type::AccessEventType& AccessEventType::clearAssessedObjectKinematics() noexcept {
  assessedObjectKinematics_Accessor.reset();
  return *this;
}

uci::type::DistanceTypeValue AccessEventType::getObjectSeparation() const {
  if (objectSeparation_Accessor) {
    return *objectSeparation_Accessor;
  }
  throw uci::base::UCIException("Error in getObjectSeparation(): An attempt was made to get an optional field that was not enabled, call hasObjectSeparation() to determine if it is safe to call getObjectSeparation()");
}

uci::type::AccessEventType& AccessEventType::setObjectSeparation(uci::type::DistanceTypeValue value) {
  objectSeparation_Accessor = value;
  return *this;
}

bool AccessEventType::hasObjectSeparation() const noexcept {
  return objectSeparation_Accessor.has_value();
}

uci::type::AccessEventType& AccessEventType::clearObjectSeparation() noexcept {
  objectSeparation_Accessor.reset();
  return *this;
}

uci::type::DateTimeTypeValue AccessEventType::getUnambiguousTime() const {
  if (unambiguousTime_Accessor) {
    return *unambiguousTime_Accessor;
  }
  throw uci::base::UCIException("Error in getUnambiguousTime(): An attempt was made to get an optional field that was not enabled, call hasUnambiguousTime() to determine if it is safe to call getUnambiguousTime()");
}

uci::type::AccessEventType& AccessEventType::setUnambiguousTime(uci::type::DateTimeTypeValue value) {
  unambiguousTime_Accessor = value;
  return *this;
}

bool AccessEventType::hasUnambiguousTime() const noexcept {
  return unambiguousTime_Accessor.has_value();
}

uci::type::AccessEventType& AccessEventType::clearUnambiguousTime() noexcept {
  unambiguousTime_Accessor.reset();
  return *this;
}

uci::type::EnduranceMultiStandardType& AccessEventType::getResourceConsumption_() const {
  if (resourceConsumption_Accessor) {
    return *resourceConsumption_Accessor;
  }
  throw uci::base::UCIException("Error in getResourceConsumption(): An attempt was made to get an optional field that was not enabled, call hasResourceConsumption() to determine if it is safe to call getResourceConsumption()");
}

const uci::type::EnduranceMultiStandardType& AccessEventType::getResourceConsumption() const {
  return getResourceConsumption_();
}

uci::type::EnduranceMultiStandardType& AccessEventType::getResourceConsumption() {
  return getResourceConsumption_();
}

uci::type::AccessEventType& AccessEventType::setResourceConsumption(const uci::type::EnduranceMultiStandardType& accessor) {
  enableResourceConsumption();
  if (&accessor != resourceConsumption_Accessor.get()) {
    resourceConsumption_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool AccessEventType::hasResourceConsumption() const noexcept {
  return static_cast<bool>(resourceConsumption_Accessor);
}

uci::type::EnduranceMultiStandardType& AccessEventType::enableResourceConsumption(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::enduranceMultiStandardType : type};
  if ((!resourceConsumption_Accessor) || (resourceConsumption_Accessor->getAccessorType() != requestedType)) {
    resourceConsumption_Accessor = EnduranceMultiStandardType::create(requestedType);
    if (!resourceConsumption_Accessor) {
      throw uci::base::UCIException("Error in enableResourceConsumption(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *resourceConsumption_Accessor;
}

uci::type::AccessEventType& AccessEventType::clearResourceConsumption() noexcept {
  resourceConsumption_Accessor.reset();
  return *this;
}

uci::type::ManeuverMultiStandardType& AccessEventType::getAssessedObjectManeuver_() const {
  if (assessedObjectManeuver_Accessor) {
    return *assessedObjectManeuver_Accessor;
  }
  throw uci::base::UCIException("Error in getAssessedObjectManeuver(): An attempt was made to get an optional field that was not enabled, call hasAssessedObjectManeuver() to determine if it is safe to call getAssessedObjectManeuver()");
}

const uci::type::ManeuverMultiStandardType& AccessEventType::getAssessedObjectManeuver() const {
  return getAssessedObjectManeuver_();
}

uci::type::ManeuverMultiStandardType& AccessEventType::getAssessedObjectManeuver() {
  return getAssessedObjectManeuver_();
}

uci::type::AccessEventType& AccessEventType::setAssessedObjectManeuver(const uci::type::ManeuverMultiStandardType& accessor) {
  enableAssessedObjectManeuver();
  if (&accessor != assessedObjectManeuver_Accessor.get()) {
    assessedObjectManeuver_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool AccessEventType::hasAssessedObjectManeuver() const noexcept {
  return static_cast<bool>(assessedObjectManeuver_Accessor);
}

uci::type::ManeuverMultiStandardType& AccessEventType::enableAssessedObjectManeuver(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::maneuverMultiStandardType : type};
  if ((!assessedObjectManeuver_Accessor) || (assessedObjectManeuver_Accessor->getAccessorType() != requestedType)) {
    assessedObjectManeuver_Accessor = ManeuverMultiStandardType::create(requestedType);
    if (!assessedObjectManeuver_Accessor) {
      throw uci::base::UCIException("Error in enableAssessedObjectManeuver(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *assessedObjectManeuver_Accessor;
}

uci::type::AccessEventType& AccessEventType::clearAssessedObjectManeuver() noexcept {
  assessedObjectManeuver_Accessor.reset();
  return *this;
}

std::unique_ptr<AccessEventType> AccessEventType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::accessEventType : type};
  return (requestedType == uci::type::accessorType::accessEventType) ? boost::make_unique<AccessEventType>() : nullptr;
}

/**  */
namespace AccessEventType_Names {

constexpr const char* Extern_Type_Name{"AccessEventType"};
constexpr const char* Effort_Name{"Effort"};
constexpr const char* Time_Name{"Time"};
constexpr const char* Duration_Name{"Duration"};
constexpr const char* ProbabilityOfAccessAttempt_Name{"ProbabilityOfAccessAttempt"};
constexpr const char* ProbabilityOfSuccessfulAccess_Name{"ProbabilityOfSuccessfulAccess"};
constexpr const char* SubjectObjectKinematics_Name{"SubjectObjectKinematics"};
constexpr const char* AssessedObjectKinematics_Name{"AssessedObjectKinematics"};
constexpr const char* ObjectSeparation_Name{"ObjectSeparation"};
constexpr const char* UnambiguousTime_Name{"UnambiguousTime"};
constexpr const char* ResourceConsumption_Name{"ResourceConsumption"};
constexpr const char* AssessedObjectManeuver_Name{"AssessedObjectManeuver"};

} // namespace AccessEventType_Names

void AccessEventType::deserialize(const boost::property_tree::ptree& propTree, uci::type::AccessEventType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = AccessEventType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + AccessEventType_Names::Effort_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.getEffort().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + AccessEventType_Names::Time_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setTime(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + AccessEventType_Names::Duration_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setDuration(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + AccessEventType_Names::ProbabilityOfAccessAttempt_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setProbabilityOfAccessAttempt(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + AccessEventType_Names::ProbabilityOfSuccessfulAccess_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setProbabilityOfSuccessfulAccess(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + AccessEventType_Names::SubjectObjectKinematics_Name) {
      KinematicsMultiStandardType::deserialize(valueType.second, accessor.enableSubjectObjectKinematics(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + AccessEventType_Names::AssessedObjectKinematics_Name) {
      KinematicsMultiStandardType::deserialize(valueType.second, accessor.enableAssessedObjectKinematics(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + AccessEventType_Names::ObjectSeparation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setObjectSeparation(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + AccessEventType_Names::UnambiguousTime_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setUnambiguousTime(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + AccessEventType_Names::ResourceConsumption_Name) {
      EnduranceMultiStandardType::deserialize(valueType.second, accessor.enableResourceConsumption(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + AccessEventType_Names::AssessedObjectManeuver_Name) {
      ManeuverMultiStandardType::deserialize(valueType.second, accessor.enableAssessedObjectManeuver(), nodeName, nsPrefix);
    }
  }
}

std::string AccessEventType::serialize(const uci::type::AccessEventType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? AccessEventType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, AccessEventType_Names::Extern_Type_Name);
  }
  AccessEffortEnum::serialize(accessor.getEffort(), node, AccessEventType_Names::Effort_Name, false);
  asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getTime(), node, AccessEventType_Names::Time_Name);
  if (accessor.hasDuration()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getDuration(), node, AccessEventType_Names::Duration_Name);
  }
  if (accessor.hasProbabilityOfAccessAttempt()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getProbabilityOfAccessAttempt(), node, AccessEventType_Names::ProbabilityOfAccessAttempt_Name);
  }
  if (accessor.hasProbabilityOfSuccessfulAccess()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getProbabilityOfSuccessfulAccess(), node, AccessEventType_Names::ProbabilityOfSuccessfulAccess_Name);
  }
  if (accessor.hasSubjectObjectKinematics()) {
    KinematicsMultiStandardType::serialize(accessor.getSubjectObjectKinematics(), node, AccessEventType_Names::SubjectObjectKinematics_Name);
  }
  if (accessor.hasAssessedObjectKinematics()) {
    KinematicsMultiStandardType::serialize(accessor.getAssessedObjectKinematics(), node, AccessEventType_Names::AssessedObjectKinematics_Name);
  }
  if (accessor.hasObjectSeparation()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getObjectSeparation(), node, AccessEventType_Names::ObjectSeparation_Name);
  }
  if (accessor.hasUnambiguousTime()) {
    asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getUnambiguousTime(), node, AccessEventType_Names::UnambiguousTime_Name);
  }
  if (accessor.hasResourceConsumption()) {
    EnduranceMultiStandardType::serialize(accessor.getResourceConsumption(), node, AccessEventType_Names::ResourceConsumption_Name);
  }
  if (accessor.hasAssessedObjectManeuver()) {
    ManeuverMultiStandardType::serialize(accessor.getAssessedObjectManeuver(), node, AccessEventType_Names::AssessedObjectManeuver_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::AccessEventType& AccessEventType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::AccessEventType>().release());
}

uci::type::AccessEventType& AccessEventType::create(const uci::type::AccessEventType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::AccessEventType> newAccessor{boost::make_unique<asb_uci::type::AccessEventType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void AccessEventType::destroy(uci::type::AccessEventType& accessor) {
  delete dynamic_cast<asb_uci::type::AccessEventType*>(&accessor);
}

} // namespace type

} // namespace uci

