/** @file PO_ComponentStatusProcessingStageProcessingSettingsType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:14 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/PO_ComponentStatusProcessingStageProcessingSettingsType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/HSB_ColorControlType.h"
#include "../../../include/asb_uci/type/PO_ComponentStatusProcessingStagePixelScalingType.h"
#include "../../../include/asb_uci/type/RGB_ColorControlType.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/HSB_ColorControlType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PO_ComponentStatusProcessingStagePixelScalingType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PO_ComponentStatusProcessingStageProcessingSettingsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PercentType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/RGB_ColorControlType.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

PO_ComponentStatusProcessingStageProcessingSettingsType::PO_ComponentStatusProcessingStageProcessingSettingsType() = default;

PO_ComponentStatusProcessingStageProcessingSettingsType::~PO_ComponentStatusProcessingStageProcessingSettingsType() = default;

void PO_ComponentStatusProcessingStageProcessingSettingsType::copy(const uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& accessor) {
  copyImpl(accessor, false);
}

void PO_ComponentStatusProcessingStageProcessingSettingsType::copyImpl(const uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const PO_ComponentStatusProcessingStageProcessingSettingsType&>(accessor);
    if (accessorImpl.pixelScaling_Accessor) {
      setPixelScaling(*(accessorImpl.pixelScaling_Accessor));
    } else {
      pixelScaling_Accessor.reset();
    }
    if (accessorImpl.hSB_ColorControlStatus_Accessor) {
      setHSB_ColorControlStatus(*(accessorImpl.hSB_ColorControlStatus_Accessor));
    } else {
      hSB_ColorControlStatus_Accessor.reset();
    }
    if (accessorImpl.rGB_ColorControlStatus_Accessor) {
      setRGB_ColorControlStatus(*(accessorImpl.rGB_ColorControlStatus_Accessor));
    } else {
      rGB_ColorControlStatus_Accessor.reset();
    }
    if (accessorImpl.hasGammaValue()) {
      setGammaValue(accessorImpl.getGammaValue());
    } else {
      clearGammaValue();
    }
    if (accessorImpl.hasSharpnessValue()) {
      setSharpnessValue(accessorImpl.getSharpnessValue());
    } else {
      clearSharpnessValue();
    }
    if (accessorImpl.hasEdgeEnhancement()) {
      setEdgeEnhancement(accessorImpl.getEdgeEnhancement());
    } else {
      clearEdgeEnhancement();
    }
    if (accessorImpl.hasZoom()) {
      setZoom(accessorImpl.getZoom());
    } else {
      clearZoom();
    }
  }
}

void PO_ComponentStatusProcessingStageProcessingSettingsType::reset() noexcept {
  pixelScaling_Accessor.reset();
  hSB_ColorControlStatus_Accessor.reset();
  rGB_ColorControlStatus_Accessor.reset();
  clearGammaValue();
  clearSharpnessValue();
  clearEdgeEnhancement();
  clearZoom();
}

uci::type::PO_ComponentStatusProcessingStagePixelScalingType& PO_ComponentStatusProcessingStageProcessingSettingsType::getPixelScaling_() const {
  if (pixelScaling_Accessor) {
    return *pixelScaling_Accessor;
  }
  throw uci::base::UCIException("Error in getPixelScaling(): An attempt was made to get an optional field that was not enabled, call hasPixelScaling() to determine if it is safe to call getPixelScaling()");
}

const uci::type::PO_ComponentStatusProcessingStagePixelScalingType& PO_ComponentStatusProcessingStageProcessingSettingsType::getPixelScaling() const {
  return getPixelScaling_();
}

uci::type::PO_ComponentStatusProcessingStagePixelScalingType& PO_ComponentStatusProcessingStageProcessingSettingsType::getPixelScaling() {
  return getPixelScaling_();
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::setPixelScaling(const uci::type::PO_ComponentStatusProcessingStagePixelScalingType& accessor) {
  enablePixelScaling();
  if (&accessor != pixelScaling_Accessor.get()) {
    pixelScaling_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PO_ComponentStatusProcessingStageProcessingSettingsType::hasPixelScaling() const noexcept {
  return static_cast<bool>(pixelScaling_Accessor);
}

uci::type::PO_ComponentStatusProcessingStagePixelScalingType& PO_ComponentStatusProcessingStageProcessingSettingsType::enablePixelScaling(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::pO_ComponentStatusProcessingStagePixelScalingType : type};
  if ((!pixelScaling_Accessor) || (pixelScaling_Accessor->getAccessorType() != requestedType)) {
    pixelScaling_Accessor = PO_ComponentStatusProcessingStagePixelScalingType::create(requestedType);
    if (!pixelScaling_Accessor) {
      throw uci::base::UCIException("Error in enablePixelScaling(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *pixelScaling_Accessor;
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::clearPixelScaling() noexcept {
  pixelScaling_Accessor.reset();
  return *this;
}

uci::type::HSB_ColorControlType& PO_ComponentStatusProcessingStageProcessingSettingsType::getHSB_ColorControlStatus_() const {
  if (hSB_ColorControlStatus_Accessor) {
    return *hSB_ColorControlStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getHSB_ColorControlStatus(): An attempt was made to get an optional field that was not enabled, call hasHSB_ColorControlStatus() to determine if it is safe to call getHSB_ColorControlStatus()");
}

const uci::type::HSB_ColorControlType& PO_ComponentStatusProcessingStageProcessingSettingsType::getHSB_ColorControlStatus() const {
  return getHSB_ColorControlStatus_();
}

uci::type::HSB_ColorControlType& PO_ComponentStatusProcessingStageProcessingSettingsType::getHSB_ColorControlStatus() {
  return getHSB_ColorControlStatus_();
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::setHSB_ColorControlStatus(const uci::type::HSB_ColorControlType& accessor) {
  enableHSB_ColorControlStatus();
  if (&accessor != hSB_ColorControlStatus_Accessor.get()) {
    hSB_ColorControlStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PO_ComponentStatusProcessingStageProcessingSettingsType::hasHSB_ColorControlStatus() const noexcept {
  return static_cast<bool>(hSB_ColorControlStatus_Accessor);
}

uci::type::HSB_ColorControlType& PO_ComponentStatusProcessingStageProcessingSettingsType::enableHSB_ColorControlStatus(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::hSB_ColorControlType : type};
  if ((!hSB_ColorControlStatus_Accessor) || (hSB_ColorControlStatus_Accessor->getAccessorType() != requestedType)) {
    hSB_ColorControlStatus_Accessor = HSB_ColorControlType::create(requestedType);
    if (!hSB_ColorControlStatus_Accessor) {
      throw uci::base::UCIException("Error in enableHSB_ColorControlStatus(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *hSB_ColorControlStatus_Accessor;
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::clearHSB_ColorControlStatus() noexcept {
  hSB_ColorControlStatus_Accessor.reset();
  return *this;
}

uci::type::RGB_ColorControlType& PO_ComponentStatusProcessingStageProcessingSettingsType::getRGB_ColorControlStatus_() const {
  if (rGB_ColorControlStatus_Accessor) {
    return *rGB_ColorControlStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getRGB_ColorControlStatus(): An attempt was made to get an optional field that was not enabled, call hasRGB_ColorControlStatus() to determine if it is safe to call getRGB_ColorControlStatus()");
}

const uci::type::RGB_ColorControlType& PO_ComponentStatusProcessingStageProcessingSettingsType::getRGB_ColorControlStatus() const {
  return getRGB_ColorControlStatus_();
}

uci::type::RGB_ColorControlType& PO_ComponentStatusProcessingStageProcessingSettingsType::getRGB_ColorControlStatus() {
  return getRGB_ColorControlStatus_();
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::setRGB_ColorControlStatus(const uci::type::RGB_ColorControlType& accessor) {
  enableRGB_ColorControlStatus();
  if (&accessor != rGB_ColorControlStatus_Accessor.get()) {
    rGB_ColorControlStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PO_ComponentStatusProcessingStageProcessingSettingsType::hasRGB_ColorControlStatus() const noexcept {
  return static_cast<bool>(rGB_ColorControlStatus_Accessor);
}

uci::type::RGB_ColorControlType& PO_ComponentStatusProcessingStageProcessingSettingsType::enableRGB_ColorControlStatus(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::rGB_ColorControlType : type};
  if ((!rGB_ColorControlStatus_Accessor) || (rGB_ColorControlStatus_Accessor->getAccessorType() != requestedType)) {
    rGB_ColorControlStatus_Accessor = RGB_ColorControlType::create(requestedType);
    if (!rGB_ColorControlStatus_Accessor) {
      throw uci::base::UCIException("Error in enableRGB_ColorControlStatus(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *rGB_ColorControlStatus_Accessor;
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::clearRGB_ColorControlStatus() noexcept {
  rGB_ColorControlStatus_Accessor.reset();
  return *this;
}

xs::Double PO_ComponentStatusProcessingStageProcessingSettingsType::getGammaValue() const {
  if (gammaValue_Accessor) {
    return *gammaValue_Accessor;
  }
  throw uci::base::UCIException("Error in getGammaValue(): An attempt was made to get an optional field that was not enabled, call hasGammaValue() to determine if it is safe to call getGammaValue()");
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::setGammaValue(xs::Double value) {
  gammaValue_Accessor = value;
  return *this;
}

bool PO_ComponentStatusProcessingStageProcessingSettingsType::hasGammaValue() const noexcept {
  return gammaValue_Accessor.has_value();
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::clearGammaValue() noexcept {
  gammaValue_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue PO_ComponentStatusProcessingStageProcessingSettingsType::getSharpnessValue() const {
  if (sharpnessValue_Accessor) {
    return *sharpnessValue_Accessor;
  }
  throw uci::base::UCIException("Error in getSharpnessValue(): An attempt was made to get an optional field that was not enabled, call hasSharpnessValue() to determine if it is safe to call getSharpnessValue()");
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::setSharpnessValue(uci::type::PercentTypeValue value) {
  sharpnessValue_Accessor = value;
  return *this;
}

bool PO_ComponentStatusProcessingStageProcessingSettingsType::hasSharpnessValue() const noexcept {
  return sharpnessValue_Accessor.has_value();
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::clearSharpnessValue() noexcept {
  sharpnessValue_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue PO_ComponentStatusProcessingStageProcessingSettingsType::getEdgeEnhancement() const {
  if (edgeEnhancement_Accessor) {
    return *edgeEnhancement_Accessor;
  }
  throw uci::base::UCIException("Error in getEdgeEnhancement(): An attempt was made to get an optional field that was not enabled, call hasEdgeEnhancement() to determine if it is safe to call getEdgeEnhancement()");
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::setEdgeEnhancement(uci::type::PercentTypeValue value) {
  edgeEnhancement_Accessor = value;
  return *this;
}

bool PO_ComponentStatusProcessingStageProcessingSettingsType::hasEdgeEnhancement() const noexcept {
  return edgeEnhancement_Accessor.has_value();
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::clearEdgeEnhancement() noexcept {
  edgeEnhancement_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue PO_ComponentStatusProcessingStageProcessingSettingsType::getZoom() const {
  if (zoom_Accessor) {
    return *zoom_Accessor;
  }
  throw uci::base::UCIException("Error in getZoom(): An attempt was made to get an optional field that was not enabled, call hasZoom() to determine if it is safe to call getZoom()");
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::setZoom(uci::type::PercentTypeValue value) {
  zoom_Accessor = value;
  return *this;
}

bool PO_ComponentStatusProcessingStageProcessingSettingsType::hasZoom() const noexcept {
  return zoom_Accessor.has_value();
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::clearZoom() noexcept {
  zoom_Accessor.reset();
  return *this;
}

std::unique_ptr<PO_ComponentStatusProcessingStageProcessingSettingsType> PO_ComponentStatusProcessingStageProcessingSettingsType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::pO_ComponentStatusProcessingStageProcessingSettingsType : type};
  return (requestedType == uci::type::accessorType::pO_ComponentStatusProcessingStageProcessingSettingsType) ? boost::make_unique<PO_ComponentStatusProcessingStageProcessingSettingsType>() : nullptr;
}

/**  */
namespace PO_ComponentStatusProcessingStageProcessingSettingsType_Names {

constexpr const char* Extern_Type_Name{"PO_ComponentStatusProcessingStageProcessingSettingsType"};
constexpr const char* PixelScaling_Name{"PixelScaling"};
constexpr const char* HSB_ColorControlStatus_Name{"HSB_ColorControlStatus"};
constexpr const char* RGB_ColorControlStatus_Name{"RGB_ColorControlStatus"};
constexpr const char* GammaValue_Name{"GammaValue"};
constexpr const char* SharpnessValue_Name{"SharpnessValue"};
constexpr const char* EdgeEnhancement_Name{"EdgeEnhancement"};
constexpr const char* Zoom_Name{"Zoom"};

} // namespace PO_ComponentStatusProcessingStageProcessingSettingsType_Names

void PO_ComponentStatusProcessingStageProcessingSettingsType::deserialize(const boost::property_tree::ptree& propTree, uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = PO_ComponentStatusProcessingStageProcessingSettingsType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + PO_ComponentStatusProcessingStageProcessingSettingsType_Names::PixelScaling_Name) {
      PO_ComponentStatusProcessingStagePixelScalingType::deserialize(valueType.second, accessor.enablePixelScaling(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PO_ComponentStatusProcessingStageProcessingSettingsType_Names::HSB_ColorControlStatus_Name) {
      HSB_ColorControlType::deserialize(valueType.second, accessor.enableHSB_ColorControlStatus(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PO_ComponentStatusProcessingStageProcessingSettingsType_Names::RGB_ColorControlStatus_Name) {
      RGB_ColorControlType::deserialize(valueType.second, accessor.enableRGB_ColorControlStatus(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PO_ComponentStatusProcessingStageProcessingSettingsType_Names::GammaValue_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setGammaValue(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + PO_ComponentStatusProcessingStageProcessingSettingsType_Names::SharpnessValue_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setSharpnessValue(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + PO_ComponentStatusProcessingStageProcessingSettingsType_Names::EdgeEnhancement_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setEdgeEnhancement(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + PO_ComponentStatusProcessingStageProcessingSettingsType_Names::Zoom_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setZoom(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    }
  }
}

std::string PO_ComponentStatusProcessingStageProcessingSettingsType::serialize(const uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? PO_ComponentStatusProcessingStageProcessingSettingsType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, PO_ComponentStatusProcessingStageProcessingSettingsType_Names::Extern_Type_Name);
  }
  if (accessor.hasPixelScaling()) {
    PO_ComponentStatusProcessingStagePixelScalingType::serialize(accessor.getPixelScaling(), node, PO_ComponentStatusProcessingStageProcessingSettingsType_Names::PixelScaling_Name);
  }
  if (accessor.hasHSB_ColorControlStatus()) {
    HSB_ColorControlType::serialize(accessor.getHSB_ColorControlStatus(), node, PO_ComponentStatusProcessingStageProcessingSettingsType_Names::HSB_ColorControlStatus_Name);
  }
  if (accessor.hasRGB_ColorControlStatus()) {
    RGB_ColorControlType::serialize(accessor.getRGB_ColorControlStatus(), node, PO_ComponentStatusProcessingStageProcessingSettingsType_Names::RGB_ColorControlStatus_Name);
  }
  if (accessor.hasGammaValue()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getGammaValue(), node, PO_ComponentStatusProcessingStageProcessingSettingsType_Names::GammaValue_Name);
  }
  if (accessor.hasSharpnessValue()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getSharpnessValue(), node, PO_ComponentStatusProcessingStageProcessingSettingsType_Names::SharpnessValue_Name);
  }
  if (accessor.hasEdgeEnhancement()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getEdgeEnhancement(), node, PO_ComponentStatusProcessingStageProcessingSettingsType_Names::EdgeEnhancement_Name);
  }
  if (accessor.hasZoom()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getZoom(), node, PO_ComponentStatusProcessingStageProcessingSettingsType_Names::Zoom_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType>().release());
}

uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& PO_ComponentStatusProcessingStageProcessingSettingsType::create(const uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType> newAccessor{boost::make_unique<asb_uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void PO_ComponentStatusProcessingStageProcessingSettingsType::destroy(uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType& accessor) {
  delete dynamic_cast<asb_uci::type::PO_ComponentStatusProcessingStageProcessingSettingsType*>(&accessor);
}

} // namespace type

} // namespace uci

