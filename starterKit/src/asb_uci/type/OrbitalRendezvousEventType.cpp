/** @file OrbitalRendezvousEventType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/OrbitalRendezvousEventType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/OrbitalDeltaVelocity_A_Type.h"
#include "../../../include/asb_uci/type/OrbitalObjectComparisonDeltaType.h"
#include "../../../include/asb_uci/type/OrbitalToleranceValuesType.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/AngleHalfPositiveType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DateTimeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DistanceType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OrbitalDeltaVelocity_A_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OrbitalObjectComparisonDeltaType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OrbitalRendezvousEventType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OrbitalToleranceValuesType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PercentType.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

OrbitalRendezvousEventType::OrbitalRendezvousEventType()
  : deltaV_Accessor{boost::make_unique<OrbitalDeltaVelocity_A_Type>()},
    toleranceValues_Accessor{boost::make_unique<OrbitalToleranceValuesType>()} {
}

OrbitalRendezvousEventType::~OrbitalRendezvousEventType() = default;

void OrbitalRendezvousEventType::copy(const uci::type::OrbitalRendezvousEventType& accessor) {
  copyImpl(accessor, false);
}

void OrbitalRendezvousEventType::copyImpl(const uci::type::OrbitalRendezvousEventType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const OrbitalRendezvousEventType&>(accessor);
    setActorStateEpoch(accessorImpl.actorStateEpoch_Accessor);
    setTargetStateEpoch(accessorImpl.targetStateEpoch_Accessor);
    if (accessorImpl.hasAnalysisEpoch()) {
      setAnalysisEpoch(accessorImpl.getAnalysisEpoch());
    } else {
      clearAnalysisEpoch();
    }
    if (accessorImpl.hasAnalysisDuration()) {
      setAnalysisDuration(accessorImpl.getAnalysisDuration());
    } else {
      clearAnalysisDuration();
    }
    setEventIntervalCoverage(accessorImpl.eventIntervalCoverage_Accessor);
    setNumberSubIntervals(accessorImpl.numberSubIntervals_Accessor);
    if (accessorImpl.hasMinimumRange()) {
      setMinimumRange(accessorImpl.getMinimumRange());
    } else {
      clearMinimumRange();
    }
    if (accessorImpl.hasMinimumRangeEpoch()) {
      setMinimumRangeEpoch(accessorImpl.getMinimumRangeEpoch());
    } else {
      clearMinimumRangeEpoch();
    }
    setMinimumRangeAnalysisDuration(accessorImpl.minimumRangeAnalysisDuration_Accessor);
    if (accessorImpl.hasMinimumInPlaneSeparationAngle()) {
      setMinimumInPlaneSeparationAngle(accessorImpl.getMinimumInPlaneSeparationAngle());
    } else {
      clearMinimumInPlaneSeparationAngle();
    }
    if (accessorImpl.hasMinimumInPlaneSeparationEpoch()) {
      setMinimumInPlaneSeparationEpoch(accessorImpl.getMinimumInPlaneSeparationEpoch());
    } else {
      clearMinimumInPlaneSeparationEpoch();
    }
    if (accessorImpl.objectComparisonAtEventStart_Accessor) {
      setObjectComparisonAtEventStart(*(accessorImpl.objectComparisonAtEventStart_Accessor));
    } else {
      objectComparisonAtEventStart_Accessor.reset();
    }
    if (accessorImpl.objectComparisonAtEventEnd_Accessor) {
      setObjectComparisonAtEventEnd(*(accessorImpl.objectComparisonAtEventEnd_Accessor));
    } else {
      objectComparisonAtEventEnd_Accessor.reset();
    }
    if (accessorImpl.objectComparisonMeans_Accessor) {
      setObjectComparisonMeans(*(accessorImpl.objectComparisonMeans_Accessor));
    } else {
      objectComparisonMeans_Accessor.reset();
    }
    setDeltaV(*(accessorImpl.deltaV_Accessor));
    setToleranceValues(*(accessorImpl.toleranceValues_Accessor));
  }
}

void OrbitalRendezvousEventType::reset() noexcept {
  actorStateEpoch_Accessor = 0;
  targetStateEpoch_Accessor = 0;
  clearAnalysisEpoch();
  clearAnalysisDuration();
  eventIntervalCoverage_Accessor = 0.0;
  numberSubIntervals_Accessor = 0;
  clearMinimumRange();
  clearMinimumRangeEpoch();
  minimumRangeAnalysisDuration_Accessor = 0;
  clearMinimumInPlaneSeparationAngle();
  clearMinimumInPlaneSeparationEpoch();
  objectComparisonAtEventStart_Accessor.reset();
  objectComparisonAtEventEnd_Accessor.reset();
  objectComparisonMeans_Accessor.reset();
  deltaV_Accessor->reset();
  toleranceValues_Accessor->reset();
}

uci::type::DateTimeTypeValue OrbitalRendezvousEventType::getActorStateEpoch() const {
  return actorStateEpoch_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setActorStateEpoch(uci::type::DateTimeTypeValue value) {
  actorStateEpoch_Accessor = value;
  return *this;
}


uci::type::DateTimeTypeValue OrbitalRendezvousEventType::getTargetStateEpoch() const {
  return targetStateEpoch_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setTargetStateEpoch(uci::type::DateTimeTypeValue value) {
  targetStateEpoch_Accessor = value;
  return *this;
}


uci::type::DateTimeTypeValue OrbitalRendezvousEventType::getAnalysisEpoch() const {
  if (analysisEpoch_Accessor) {
    return *analysisEpoch_Accessor;
  }
  throw uci::base::UCIException("Error in getAnalysisEpoch(): An attempt was made to get an optional field that was not enabled, call hasAnalysisEpoch() to determine if it is safe to call getAnalysisEpoch()");
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setAnalysisEpoch(uci::type::DateTimeTypeValue value) {
  analysisEpoch_Accessor = value;
  return *this;
}

bool OrbitalRendezvousEventType::hasAnalysisEpoch() const noexcept {
  return analysisEpoch_Accessor.has_value();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearAnalysisEpoch() noexcept {
  analysisEpoch_Accessor.reset();
  return *this;
}

xs::Duration OrbitalRendezvousEventType::getAnalysisDuration() const {
  if (analysisDuration_Accessor) {
    return *analysisDuration_Accessor;
  }
  throw uci::base::UCIException("Error in getAnalysisDuration(): An attempt was made to get an optional field that was not enabled, call hasAnalysisDuration() to determine if it is safe to call getAnalysisDuration()");
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setAnalysisDuration(xs::Duration value) {
  analysisDuration_Accessor = value;
  return *this;
}

bool OrbitalRendezvousEventType::hasAnalysisDuration() const noexcept {
  return analysisDuration_Accessor.has_value();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearAnalysisDuration() noexcept {
  analysisDuration_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue OrbitalRendezvousEventType::getEventIntervalCoverage() const {
  return eventIntervalCoverage_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setEventIntervalCoverage(uci::type::PercentTypeValue value) {
  eventIntervalCoverage_Accessor = value;
  return *this;
}


xs::Int OrbitalRendezvousEventType::getNumberSubIntervals() const {
  return numberSubIntervals_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setNumberSubIntervals(xs::Int value) {
  numberSubIntervals_Accessor = value;
  return *this;
}


uci::type::DistanceTypeValue OrbitalRendezvousEventType::getMinimumRange() const {
  if (minimumRange_Accessor) {
    return *minimumRange_Accessor;
  }
  throw uci::base::UCIException("Error in getMinimumRange(): An attempt was made to get an optional field that was not enabled, call hasMinimumRange() to determine if it is safe to call getMinimumRange()");
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setMinimumRange(uci::type::DistanceTypeValue value) {
  minimumRange_Accessor = value;
  return *this;
}

bool OrbitalRendezvousEventType::hasMinimumRange() const noexcept {
  return minimumRange_Accessor.has_value();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearMinimumRange() noexcept {
  minimumRange_Accessor.reset();
  return *this;
}

uci::type::DateTimeTypeValue OrbitalRendezvousEventType::getMinimumRangeEpoch() const {
  if (minimumRangeEpoch_Accessor) {
    return *minimumRangeEpoch_Accessor;
  }
  throw uci::base::UCIException("Error in getMinimumRangeEpoch(): An attempt was made to get an optional field that was not enabled, call hasMinimumRangeEpoch() to determine if it is safe to call getMinimumRangeEpoch()");
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setMinimumRangeEpoch(uci::type::DateTimeTypeValue value) {
  minimumRangeEpoch_Accessor = value;
  return *this;
}

bool OrbitalRendezvousEventType::hasMinimumRangeEpoch() const noexcept {
  return minimumRangeEpoch_Accessor.has_value();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearMinimumRangeEpoch() noexcept {
  minimumRangeEpoch_Accessor.reset();
  return *this;
}

xs::Duration OrbitalRendezvousEventType::getMinimumRangeAnalysisDuration() const {
  return minimumRangeAnalysisDuration_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setMinimumRangeAnalysisDuration(xs::Duration value) {
  minimumRangeAnalysisDuration_Accessor = value;
  return *this;
}


uci::type::AngleHalfPositiveTypeValue OrbitalRendezvousEventType::getMinimumInPlaneSeparationAngle() const {
  if (minimumInPlaneSeparationAngle_Accessor) {
    return *minimumInPlaneSeparationAngle_Accessor;
  }
  throw uci::base::UCIException("Error in getMinimumInPlaneSeparationAngle(): An attempt was made to get an optional field that was not enabled, call hasMinimumInPlaneSeparationAngle() to determine if it is safe to call getMinimumInPlaneSeparationAngle()");
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setMinimumInPlaneSeparationAngle(uci::type::AngleHalfPositiveTypeValue value) {
  minimumInPlaneSeparationAngle_Accessor = value;
  return *this;
}

bool OrbitalRendezvousEventType::hasMinimumInPlaneSeparationAngle() const noexcept {
  return minimumInPlaneSeparationAngle_Accessor.has_value();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearMinimumInPlaneSeparationAngle() noexcept {
  minimumInPlaneSeparationAngle_Accessor.reset();
  return *this;
}

uci::type::DateTimeTypeValue OrbitalRendezvousEventType::getMinimumInPlaneSeparationEpoch() const {
  if (minimumInPlaneSeparationEpoch_Accessor) {
    return *minimumInPlaneSeparationEpoch_Accessor;
  }
  throw uci::base::UCIException("Error in getMinimumInPlaneSeparationEpoch(): An attempt was made to get an optional field that was not enabled, call hasMinimumInPlaneSeparationEpoch() to determine if it is safe to call getMinimumInPlaneSeparationEpoch()");
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setMinimumInPlaneSeparationEpoch(uci::type::DateTimeTypeValue value) {
  minimumInPlaneSeparationEpoch_Accessor = value;
  return *this;
}

bool OrbitalRendezvousEventType::hasMinimumInPlaneSeparationEpoch() const noexcept {
  return minimumInPlaneSeparationEpoch_Accessor.has_value();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearMinimumInPlaneSeparationEpoch() noexcept {
  minimumInPlaneSeparationEpoch_Accessor.reset();
  return *this;
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonAtEventStart_() const {
  if (objectComparisonAtEventStart_Accessor) {
    return *objectComparisonAtEventStart_Accessor;
  }
  throw uci::base::UCIException("Error in getObjectComparisonAtEventStart(): An attempt was made to get an optional field that was not enabled, call hasObjectComparisonAtEventStart() to determine if it is safe to call getObjectComparisonAtEventStart()");
}

const uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonAtEventStart() const {
  return getObjectComparisonAtEventStart_();
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonAtEventStart() {
  return getObjectComparisonAtEventStart_();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setObjectComparisonAtEventStart(const uci::type::OrbitalObjectComparisonDeltaType& accessor) {
  enableObjectComparisonAtEventStart();
  if (&accessor != objectComparisonAtEventStart_Accessor.get()) {
    objectComparisonAtEventStart_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrbitalRendezvousEventType::hasObjectComparisonAtEventStart() const noexcept {
  return static_cast<bool>(objectComparisonAtEventStart_Accessor);
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::enableObjectComparisonAtEventStart(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orbitalObjectComparisonDeltaType : type};
  if ((!objectComparisonAtEventStart_Accessor) || (objectComparisonAtEventStart_Accessor->getAccessorType() != requestedType)) {
    objectComparisonAtEventStart_Accessor = OrbitalObjectComparisonDeltaType::create(requestedType);
    if (!objectComparisonAtEventStart_Accessor) {
      throw uci::base::UCIException("Error in enableObjectComparisonAtEventStart(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *objectComparisonAtEventStart_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearObjectComparisonAtEventStart() noexcept {
  objectComparisonAtEventStart_Accessor.reset();
  return *this;
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonAtEventEnd_() const {
  if (objectComparisonAtEventEnd_Accessor) {
    return *objectComparisonAtEventEnd_Accessor;
  }
  throw uci::base::UCIException("Error in getObjectComparisonAtEventEnd(): An attempt was made to get an optional field that was not enabled, call hasObjectComparisonAtEventEnd() to determine if it is safe to call getObjectComparisonAtEventEnd()");
}

const uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonAtEventEnd() const {
  return getObjectComparisonAtEventEnd_();
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonAtEventEnd() {
  return getObjectComparisonAtEventEnd_();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setObjectComparisonAtEventEnd(const uci::type::OrbitalObjectComparisonDeltaType& accessor) {
  enableObjectComparisonAtEventEnd();
  if (&accessor != objectComparisonAtEventEnd_Accessor.get()) {
    objectComparisonAtEventEnd_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrbitalRendezvousEventType::hasObjectComparisonAtEventEnd() const noexcept {
  return static_cast<bool>(objectComparisonAtEventEnd_Accessor);
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::enableObjectComparisonAtEventEnd(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orbitalObjectComparisonDeltaType : type};
  if ((!objectComparisonAtEventEnd_Accessor) || (objectComparisonAtEventEnd_Accessor->getAccessorType() != requestedType)) {
    objectComparisonAtEventEnd_Accessor = OrbitalObjectComparisonDeltaType::create(requestedType);
    if (!objectComparisonAtEventEnd_Accessor) {
      throw uci::base::UCIException("Error in enableObjectComparisonAtEventEnd(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *objectComparisonAtEventEnd_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearObjectComparisonAtEventEnd() noexcept {
  objectComparisonAtEventEnd_Accessor.reset();
  return *this;
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonMeans_() const {
  if (objectComparisonMeans_Accessor) {
    return *objectComparisonMeans_Accessor;
  }
  throw uci::base::UCIException("Error in getObjectComparisonMeans(): An attempt was made to get an optional field that was not enabled, call hasObjectComparisonMeans() to determine if it is safe to call getObjectComparisonMeans()");
}

const uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonMeans() const {
  return getObjectComparisonMeans_();
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::getObjectComparisonMeans() {
  return getObjectComparisonMeans_();
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setObjectComparisonMeans(const uci::type::OrbitalObjectComparisonDeltaType& accessor) {
  enableObjectComparisonMeans();
  if (&accessor != objectComparisonMeans_Accessor.get()) {
    objectComparisonMeans_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrbitalRendezvousEventType::hasObjectComparisonMeans() const noexcept {
  return static_cast<bool>(objectComparisonMeans_Accessor);
}

uci::type::OrbitalObjectComparisonDeltaType& OrbitalRendezvousEventType::enableObjectComparisonMeans(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orbitalObjectComparisonDeltaType : type};
  if ((!objectComparisonMeans_Accessor) || (objectComparisonMeans_Accessor->getAccessorType() != requestedType)) {
    objectComparisonMeans_Accessor = OrbitalObjectComparisonDeltaType::create(requestedType);
    if (!objectComparisonMeans_Accessor) {
      throw uci::base::UCIException("Error in enableObjectComparisonMeans(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *objectComparisonMeans_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::clearObjectComparisonMeans() noexcept {
  objectComparisonMeans_Accessor.reset();
  return *this;
}

const uci::type::OrbitalDeltaVelocity_A_Type& OrbitalRendezvousEventType::getDeltaV() const {
  return *deltaV_Accessor;
}

uci::type::OrbitalDeltaVelocity_A_Type& OrbitalRendezvousEventType::getDeltaV() {
  return *deltaV_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setDeltaV(const uci::type::OrbitalDeltaVelocity_A_Type& accessor) {
  if (&accessor != deltaV_Accessor.get()) {
    deltaV_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::OrbitalToleranceValuesType& OrbitalRendezvousEventType::getToleranceValues() const {
  return *toleranceValues_Accessor;
}

uci::type::OrbitalToleranceValuesType& OrbitalRendezvousEventType::getToleranceValues() {
  return *toleranceValues_Accessor;
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::setToleranceValues(const uci::type::OrbitalToleranceValuesType& accessor) {
  if (&accessor != toleranceValues_Accessor.get()) {
    toleranceValues_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

std::unique_ptr<OrbitalRendezvousEventType> OrbitalRendezvousEventType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orbitalRendezvousEventType : type};
  return (requestedType == uci::type::accessorType::orbitalRendezvousEventType) ? boost::make_unique<OrbitalRendezvousEventType>() : nullptr;
}

/**  */
namespace OrbitalRendezvousEventType_Names {

constexpr const char* Extern_Type_Name{"OrbitalRendezvousEventType"};
constexpr const char* ActorStateEpoch_Name{"ActorStateEpoch"};
constexpr const char* TargetStateEpoch_Name{"TargetStateEpoch"};
constexpr const char* AnalysisEpoch_Name{"AnalysisEpoch"};
constexpr const char* AnalysisDuration_Name{"AnalysisDuration"};
constexpr const char* EventIntervalCoverage_Name{"EventIntervalCoverage"};
constexpr const char* NumberSubIntervals_Name{"NumberSubIntervals"};
constexpr const char* MinimumRange_Name{"MinimumRange"};
constexpr const char* MinimumRangeEpoch_Name{"MinimumRangeEpoch"};
constexpr const char* MinimumRangeAnalysisDuration_Name{"MinimumRangeAnalysisDuration"};
constexpr const char* MinimumInPlaneSeparationAngle_Name{"MinimumInPlaneSeparationAngle"};
constexpr const char* MinimumInPlaneSeparationEpoch_Name{"MinimumInPlaneSeparationEpoch"};
constexpr const char* ObjectComparisonAtEventStart_Name{"ObjectComparisonAtEventStart"};
constexpr const char* ObjectComparisonAtEventEnd_Name{"ObjectComparisonAtEventEnd"};
constexpr const char* ObjectComparisonMeans_Name{"ObjectComparisonMeans"};
constexpr const char* DeltaV_Name{"DeltaV"};
constexpr const char* ToleranceValues_Name{"ToleranceValues"};

} // namespace OrbitalRendezvousEventType_Names

void OrbitalRendezvousEventType::deserialize(const boost::property_tree::ptree& propTree, uci::type::OrbitalRendezvousEventType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = OrbitalRendezvousEventType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::ActorStateEpoch_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setActorStateEpoch(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::TargetStateEpoch_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setTargetStateEpoch(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::AnalysisEpoch_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAnalysisEpoch(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::AnalysisDuration_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAnalysisDuration(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::EventIntervalCoverage_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setEventIntervalCoverage(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::NumberSubIntervals_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setNumberSubIntervals(asb_uci::util::SerializationHelpers::deserializeInt(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::MinimumRange_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMinimumRange(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::MinimumRangeEpoch_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMinimumRangeEpoch(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::MinimumRangeAnalysisDuration_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMinimumRangeAnalysisDuration(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::MinimumInPlaneSeparationAngle_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMinimumInPlaneSeparationAngle(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::MinimumInPlaneSeparationEpoch_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMinimumInPlaneSeparationEpoch(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::ObjectComparisonAtEventStart_Name) {
      OrbitalObjectComparisonDeltaType::deserialize(valueType.second, accessor.enableObjectComparisonAtEventStart(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::ObjectComparisonAtEventEnd_Name) {
      OrbitalObjectComparisonDeltaType::deserialize(valueType.second, accessor.enableObjectComparisonAtEventEnd(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::ObjectComparisonMeans_Name) {
      OrbitalObjectComparisonDeltaType::deserialize(valueType.second, accessor.enableObjectComparisonMeans(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::DeltaV_Name) {
      OrbitalDeltaVelocity_A_Type::deserialize(valueType.second, accessor.getDeltaV(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrbitalRendezvousEventType_Names::ToleranceValues_Name) {
      OrbitalToleranceValuesType::deserialize(valueType.second, accessor.getToleranceValues(), nodeName, nsPrefix);
    }
  }
}

std::string OrbitalRendezvousEventType::serialize(const uci::type::OrbitalRendezvousEventType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? OrbitalRendezvousEventType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, OrbitalRendezvousEventType_Names::Extern_Type_Name);
  }
  asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getActorStateEpoch(), node, OrbitalRendezvousEventType_Names::ActorStateEpoch_Name);
  asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getTargetStateEpoch(), node, OrbitalRendezvousEventType_Names::TargetStateEpoch_Name);
  if (accessor.hasAnalysisEpoch()) {
    asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getAnalysisEpoch(), node, OrbitalRendezvousEventType_Names::AnalysisEpoch_Name);
  }
  if (accessor.hasAnalysisDuration()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getAnalysisDuration(), node, OrbitalRendezvousEventType_Names::AnalysisDuration_Name);
  }
  asb_uci::util::SerializationHelpers::serializeDouble(accessor.getEventIntervalCoverage(), node, OrbitalRendezvousEventType_Names::EventIntervalCoverage_Name);
  asb_uci::util::SerializationHelpers::serializeInt(accessor.getNumberSubIntervals(), node, OrbitalRendezvousEventType_Names::NumberSubIntervals_Name);
  if (accessor.hasMinimumRange()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getMinimumRange(), node, OrbitalRendezvousEventType_Names::MinimumRange_Name);
  }
  if (accessor.hasMinimumRangeEpoch()) {
    asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getMinimumRangeEpoch(), node, OrbitalRendezvousEventType_Names::MinimumRangeEpoch_Name);
  }
  asb_uci::util::SerializationHelpers::serializeDuration(accessor.getMinimumRangeAnalysisDuration(), node, OrbitalRendezvousEventType_Names::MinimumRangeAnalysisDuration_Name);
  if (accessor.hasMinimumInPlaneSeparationAngle()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getMinimumInPlaneSeparationAngle(), node, OrbitalRendezvousEventType_Names::MinimumInPlaneSeparationAngle_Name);
  }
  if (accessor.hasMinimumInPlaneSeparationEpoch()) {
    asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getMinimumInPlaneSeparationEpoch(), node, OrbitalRendezvousEventType_Names::MinimumInPlaneSeparationEpoch_Name);
  }
  if (accessor.hasObjectComparisonAtEventStart()) {
    OrbitalObjectComparisonDeltaType::serialize(accessor.getObjectComparisonAtEventStart(), node, OrbitalRendezvousEventType_Names::ObjectComparisonAtEventStart_Name);
  }
  if (accessor.hasObjectComparisonAtEventEnd()) {
    OrbitalObjectComparisonDeltaType::serialize(accessor.getObjectComparisonAtEventEnd(), node, OrbitalRendezvousEventType_Names::ObjectComparisonAtEventEnd_Name);
  }
  if (accessor.hasObjectComparisonMeans()) {
    OrbitalObjectComparisonDeltaType::serialize(accessor.getObjectComparisonMeans(), node, OrbitalRendezvousEventType_Names::ObjectComparisonMeans_Name);
  }
  OrbitalDeltaVelocity_A_Type::serialize(accessor.getDeltaV(), node, OrbitalRendezvousEventType_Names::DeltaV_Name);
  OrbitalToleranceValuesType::serialize(accessor.getToleranceValues(), node, OrbitalRendezvousEventType_Names::ToleranceValues_Name);
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::OrbitalRendezvousEventType>().release());
}

uci::type::OrbitalRendezvousEventType& OrbitalRendezvousEventType::create(const uci::type::OrbitalRendezvousEventType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::OrbitalRendezvousEventType> newAccessor{boost::make_unique<asb_uci::type::OrbitalRendezvousEventType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void OrbitalRendezvousEventType::destroy(uci::type::OrbitalRendezvousEventType& accessor) {
  delete dynamic_cast<asb_uci::type::OrbitalRendezvousEventType*>(&accessor);
}

} // namespace type

} // namespace uci

