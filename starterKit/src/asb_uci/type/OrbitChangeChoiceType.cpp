/** @file OrbitChangeChoiceType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/OrbitChangeChoiceType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/COE_OrbitType.h"
#include "../../../include/asb_uci/type/OrbitalVolumeType.h"
#include "../../../include/asb_uci/type/ProximityOperationsType.h"
#include "../../../include/asb_uci/type/RSO_ApproachType.h"
#include "../../../include/asb_uci/type/RaceTrackOrbitType.h"
#include "../../../include/asb_uci/util/DerivedTypesDeserializer.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/AngleHalfPositiveType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/AngleType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/COE_OrbitType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DistanceType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OrbitChangeChoiceType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OrbitalVolumeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ProximityOperationsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/RSO_ApproachType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/RaceTrackOrbitType.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

OrbitChangeChoiceType::OrbitChangeChoiceType() = default;

OrbitChangeChoiceType::~OrbitChangeChoiceType() = default;

void OrbitChangeChoiceType::copy(const uci::type::OrbitChangeChoiceType& accessor) {
  copyImpl(accessor, false);
}

void OrbitChangeChoiceType::copyImpl(const uci::type::OrbitChangeChoiceType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const OrbitChangeChoiceType&>(accessor);
    if (accessorImpl.specificOrbit_Accessor) {
      setSpecificOrbit(*(accessorImpl.specificOrbit_Accessor));
    } else {
      specificOrbit_Accessor.reset();
    }
    if (accessorImpl.specificPosition_Accessor) {
      setSpecificPosition(*(accessorImpl.specificPosition_Accessor));
    } else {
      specificPosition_Accessor.reset();
    }
    if (accessorImpl.rendezvous_Accessor) {
      setRendezvous(*(accessorImpl.rendezvous_Accessor));
    } else {
      rendezvous_Accessor.reset();
    }
    if (accessorImpl.proximityOperations_Accessor) {
      setProximityOperations(*(accessorImpl.proximityOperations_Accessor));
    } else {
      proximityOperations_Accessor.reset();
    }
    longitude_Accessor = (accessorImpl.longitude_Accessor ? accessorImpl.longitude_Accessor : boost::none);
    semimajorAxis_Accessor = (accessorImpl.semimajorAxis_Accessor ? accessorImpl.semimajorAxis_Accessor : boost::none);
    inclination_Accessor = (accessorImpl.inclination_Accessor ? accessorImpl.inclination_Accessor : boost::none);
    eccentricity_Accessor = (accessorImpl.eccentricity_Accessor ? accessorImpl.eccentricity_Accessor : boost::none);
    if (accessorImpl.raceTrack_Accessor) {
      setRaceTrack(*(accessorImpl.raceTrack_Accessor));
    } else {
      raceTrack_Accessor.reset();
    }
  }
}

void OrbitChangeChoiceType::reset() noexcept {
  specificOrbit_Accessor.reset();
  specificPosition_Accessor.reset();
  rendezvous_Accessor.reset();
  proximityOperations_Accessor.reset();
  longitude_Accessor.reset();
  semimajorAxis_Accessor.reset();
  inclination_Accessor.reset();
  eccentricity_Accessor.reset();
  raceTrack_Accessor.reset();
}

uci::type::OrbitChangeChoiceType::OrbitChangeChoiceTypeChoice OrbitChangeChoiceType::getOrbitChangeChoiceTypeChoiceOrdinal() const noexcept {
  if (specificOrbit_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_SPECIFICORBIT;
  }
  if (specificPosition_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_SPECIFICPOSITION;
  }
  if (rendezvous_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_RENDEZVOUS;
  }
  if (proximityOperations_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_PROXIMITYOPERATIONS;
  }
  if (longitude_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_LONGITUDE;
  }
  if (semimajorAxis_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_SEMIMAJORAXIS;
  }
  if (inclination_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_INCLINATION;
  }
  if (eccentricity_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_ECCENTRICITY;
  }
  if (raceTrack_Accessor) {
    return ORBITCHANGECHOICETYPE_CHOICE_RACETRACK;
  }
  return ORBITCHANGECHOICETYPE_CHOICE_NONE;
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setOrbitChangeChoiceTypeChoiceOrdinal(uci::type::OrbitChangeChoiceType::OrbitChangeChoiceTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case ORBITCHANGECHOICETYPE_CHOICE_SPECIFICORBIT:
      chooseSpecificOrbit("setOrbitChangeChoiceTypeChoiceOrdinal", type);
      break;
    case ORBITCHANGECHOICETYPE_CHOICE_SPECIFICPOSITION:
      chooseSpecificPosition("setOrbitChangeChoiceTypeChoiceOrdinal", type);
      break;
    case ORBITCHANGECHOICETYPE_CHOICE_RENDEZVOUS:
      chooseRendezvous("setOrbitChangeChoiceTypeChoiceOrdinal", type);
      break;
    case ORBITCHANGECHOICETYPE_CHOICE_PROXIMITYOPERATIONS:
      chooseProximityOperations("setOrbitChangeChoiceTypeChoiceOrdinal", type);
      break;
    case ORBITCHANGECHOICETYPE_CHOICE_LONGITUDE:
      chooseLongitude();
      break;
    case ORBITCHANGECHOICETYPE_CHOICE_SEMIMAJORAXIS:
      chooseSemimajorAxis();
      break;
    case ORBITCHANGECHOICETYPE_CHOICE_INCLINATION:
      chooseInclination();
      break;
    case ORBITCHANGECHOICETYPE_CHOICE_ECCENTRICITY:
      chooseEccentricity();
      break;
    case ORBITCHANGECHOICETYPE_CHOICE_RACETRACK:
      chooseRaceTrack("setOrbitChangeChoiceTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setOrbitChangeChoiceTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::COE_OrbitType& OrbitChangeChoiceType::getSpecificOrbit_() const {
  if (specificOrbit_Accessor) {
    return *specificOrbit_Accessor;
  }
  throw uci::base::UCIException("Error in getSpecificOrbit(): Unable to get SpecificOrbit, field not selected");
}

const uci::type::COE_OrbitType& OrbitChangeChoiceType::getSpecificOrbit() const {
  return getSpecificOrbit_();
}

uci::type::COE_OrbitType& OrbitChangeChoiceType::getSpecificOrbit() {
  return getSpecificOrbit_();
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setSpecificOrbit(const uci::type::COE_OrbitType& accessor) {
  chooseSpecificOrbit();
  if (&accessor != specificOrbit_Accessor.get()) {
    specificOrbit_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrbitChangeChoiceType::isSpecificOrbit() const noexcept {
  return static_cast<bool>(specificOrbit_Accessor);
}

uci::type::COE_OrbitType& OrbitChangeChoiceType::chooseSpecificOrbit(const std::string& method, uci::base::accessorType::AccessorType type) {
  specificPosition_Accessor.reset();
  rendezvous_Accessor.reset();
  proximityOperations_Accessor.reset();
  longitude_Accessor.reset();
  semimajorAxis_Accessor.reset();
  inclination_Accessor.reset();
  eccentricity_Accessor.reset();
  raceTrack_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::cOE_OrbitType : type};
  if ((!specificOrbit_Accessor) || (specificOrbit_Accessor->getAccessorType() != requestedType)) {
    specificOrbit_Accessor = COE_OrbitType::create(type);
    if (!specificOrbit_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *specificOrbit_Accessor;
}

uci::type::COE_OrbitType& OrbitChangeChoiceType::chooseSpecificOrbit(uci::base::accessorType::AccessorType type) {
  return chooseSpecificOrbit("chooseSpecificOrbit", type);
}

uci::type::OrbitalVolumeType& OrbitChangeChoiceType::getSpecificPosition_() const {
  if (specificPosition_Accessor) {
    return *specificPosition_Accessor;
  }
  throw uci::base::UCIException("Error in getSpecificPosition(): Unable to get SpecificPosition, field not selected");
}

const uci::type::OrbitalVolumeType& OrbitChangeChoiceType::getSpecificPosition() const {
  return getSpecificPosition_();
}

uci::type::OrbitalVolumeType& OrbitChangeChoiceType::getSpecificPosition() {
  return getSpecificPosition_();
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setSpecificPosition(const uci::type::OrbitalVolumeType& accessor) {
  chooseSpecificPosition();
  if (&accessor != specificPosition_Accessor.get()) {
    specificPosition_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrbitChangeChoiceType::isSpecificPosition() const noexcept {
  return static_cast<bool>(specificPosition_Accessor);
}

uci::type::OrbitalVolumeType& OrbitChangeChoiceType::chooseSpecificPosition(const std::string& method, uci::base::accessorType::AccessorType type) {
  specificOrbit_Accessor.reset();
  rendezvous_Accessor.reset();
  proximityOperations_Accessor.reset();
  longitude_Accessor.reset();
  semimajorAxis_Accessor.reset();
  inclination_Accessor.reset();
  eccentricity_Accessor.reset();
  raceTrack_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orbitalVolumeType : type};
  if ((!specificPosition_Accessor) || (specificPosition_Accessor->getAccessorType() != requestedType)) {
    specificPosition_Accessor = OrbitalVolumeType::create(type);
    if (!specificPosition_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *specificPosition_Accessor;
}

uci::type::OrbitalVolumeType& OrbitChangeChoiceType::chooseSpecificPosition(uci::base::accessorType::AccessorType type) {
  return chooseSpecificPosition("chooseSpecificPosition", type);
}

uci::type::RSO_ApproachType& OrbitChangeChoiceType::getRendezvous_() const {
  if (rendezvous_Accessor) {
    return *rendezvous_Accessor;
  }
  throw uci::base::UCIException("Error in getRendezvous(): Unable to get Rendezvous, field not selected");
}

const uci::type::RSO_ApproachType& OrbitChangeChoiceType::getRendezvous() const {
  return getRendezvous_();
}

uci::type::RSO_ApproachType& OrbitChangeChoiceType::getRendezvous() {
  return getRendezvous_();
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setRendezvous(const uci::type::RSO_ApproachType& accessor) {
  chooseRendezvous("setRendezvous", accessor.getAccessorType());
  if (&accessor != rendezvous_Accessor.get()) {
    rendezvous_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool OrbitChangeChoiceType::isRendezvous() const noexcept {
  return static_cast<bool>(rendezvous_Accessor);
}

uci::type::RSO_ApproachType& OrbitChangeChoiceType::chooseRendezvous(const std::string& method, uci::base::accessorType::AccessorType type) {
  specificOrbit_Accessor.reset();
  specificPosition_Accessor.reset();
  proximityOperations_Accessor.reset();
  longitude_Accessor.reset();
  semimajorAxis_Accessor.reset();
  inclination_Accessor.reset();
  eccentricity_Accessor.reset();
  raceTrack_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::rSO_ApproachType : type};
  if ((!rendezvous_Accessor) || (rendezvous_Accessor->getAccessorType() != requestedType)) {
    rendezvous_Accessor = RSO_ApproachType::create(type);
    if (!rendezvous_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *rendezvous_Accessor;
}

uci::type::RSO_ApproachType& OrbitChangeChoiceType::chooseRendezvous(uci::base::accessorType::AccessorType type) {
  return chooseRendezvous("chooseRendezvous", type);
}

uci::type::ProximityOperationsType& OrbitChangeChoiceType::getProximityOperations_() const {
  if (proximityOperations_Accessor) {
    return *proximityOperations_Accessor;
  }
  throw uci::base::UCIException("Error in getProximityOperations(): Unable to get ProximityOperations, field not selected");
}

const uci::type::ProximityOperationsType& OrbitChangeChoiceType::getProximityOperations() const {
  return getProximityOperations_();
}

uci::type::ProximityOperationsType& OrbitChangeChoiceType::getProximityOperations() {
  return getProximityOperations_();
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setProximityOperations(const uci::type::ProximityOperationsType& accessor) {
  chooseProximityOperations();
  if (&accessor != proximityOperations_Accessor.get()) {
    proximityOperations_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrbitChangeChoiceType::isProximityOperations() const noexcept {
  return static_cast<bool>(proximityOperations_Accessor);
}

uci::type::ProximityOperationsType& OrbitChangeChoiceType::chooseProximityOperations(const std::string& method, uci::base::accessorType::AccessorType type) {
  specificOrbit_Accessor.reset();
  specificPosition_Accessor.reset();
  rendezvous_Accessor.reset();
  longitude_Accessor.reset();
  semimajorAxis_Accessor.reset();
  inclination_Accessor.reset();
  eccentricity_Accessor.reset();
  raceTrack_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::proximityOperationsType : type};
  if ((!proximityOperations_Accessor) || (proximityOperations_Accessor->getAccessorType() != requestedType)) {
    proximityOperations_Accessor = ProximityOperationsType::create(type);
    if (!proximityOperations_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *proximityOperations_Accessor;
}

uci::type::ProximityOperationsType& OrbitChangeChoiceType::chooseProximityOperations(uci::base::accessorType::AccessorType type) {
  return chooseProximityOperations("chooseProximityOperations", type);
}

uci::type::AngleTypeValue OrbitChangeChoiceType::getLongitude() const {
  if (longitude_Accessor) {
    return *longitude_Accessor;
  }
  throw uci::base::UCIException("Error in getLongitude(): Unable to get Longitude, field not selected");
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setLongitude(uci::type::AngleTypeValue value) {
  chooseLongitude();
  longitude_Accessor = value;
  return *this;
}

bool OrbitChangeChoiceType::isLongitude() const noexcept {
  return static_cast<bool>(longitude_Accessor);
}

void OrbitChangeChoiceType::chooseLongitude() {
  specificOrbit_Accessor.reset();
  specificPosition_Accessor.reset();
  rendezvous_Accessor.reset();
  proximityOperations_Accessor.reset();
  semimajorAxis_Accessor.reset();
  inclination_Accessor.reset();
  eccentricity_Accessor.reset();
  raceTrack_Accessor.reset();
  if (!longitude_Accessor) {
    longitude_Accessor = boost::optional<asb_xs::Double>();
  }
}

uci::type::DistanceTypeValue OrbitChangeChoiceType::getSemimajorAxis() const {
  if (semimajorAxis_Accessor) {
    return *semimajorAxis_Accessor;
  }
  throw uci::base::UCIException("Error in getSemimajorAxis(): Unable to get SemimajorAxis, field not selected");
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setSemimajorAxis(uci::type::DistanceTypeValue value) {
  chooseSemimajorAxis();
  semimajorAxis_Accessor = value;
  return *this;
}

bool OrbitChangeChoiceType::isSemimajorAxis() const noexcept {
  return static_cast<bool>(semimajorAxis_Accessor);
}

void OrbitChangeChoiceType::chooseSemimajorAxis() {
  specificOrbit_Accessor.reset();
  specificPosition_Accessor.reset();
  rendezvous_Accessor.reset();
  proximityOperations_Accessor.reset();
  longitude_Accessor.reset();
  inclination_Accessor.reset();
  eccentricity_Accessor.reset();
  raceTrack_Accessor.reset();
  if (!semimajorAxis_Accessor) {
    semimajorAxis_Accessor = boost::optional<asb_xs::Double>();
  }
}

uci::type::AngleHalfPositiveTypeValue OrbitChangeChoiceType::getInclination() const {
  if (inclination_Accessor) {
    return *inclination_Accessor;
  }
  throw uci::base::UCIException("Error in getInclination(): Unable to get Inclination, field not selected");
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setInclination(uci::type::AngleHalfPositiveTypeValue value) {
  chooseInclination();
  inclination_Accessor = value;
  return *this;
}

bool OrbitChangeChoiceType::isInclination() const noexcept {
  return static_cast<bool>(inclination_Accessor);
}

void OrbitChangeChoiceType::chooseInclination() {
  specificOrbit_Accessor.reset();
  specificPosition_Accessor.reset();
  rendezvous_Accessor.reset();
  proximityOperations_Accessor.reset();
  longitude_Accessor.reset();
  semimajorAxis_Accessor.reset();
  eccentricity_Accessor.reset();
  raceTrack_Accessor.reset();
  if (!inclination_Accessor) {
    inclination_Accessor = boost::optional<asb_xs::Double>();
  }
}

xs::Double OrbitChangeChoiceType::getEccentricity() const {
  if (eccentricity_Accessor) {
    return *eccentricity_Accessor;
  }
  throw uci::base::UCIException("Error in getEccentricity(): Unable to get Eccentricity, field not selected");
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setEccentricity(xs::Double value) {
  chooseEccentricity();
  eccentricity_Accessor = value;
  return *this;
}

bool OrbitChangeChoiceType::isEccentricity() const noexcept {
  return static_cast<bool>(eccentricity_Accessor);
}

void OrbitChangeChoiceType::chooseEccentricity() {
  specificOrbit_Accessor.reset();
  specificPosition_Accessor.reset();
  rendezvous_Accessor.reset();
  proximityOperations_Accessor.reset();
  longitude_Accessor.reset();
  semimajorAxis_Accessor.reset();
  inclination_Accessor.reset();
  raceTrack_Accessor.reset();
  if (!eccentricity_Accessor) {
    eccentricity_Accessor = boost::optional<asb_xs::Double>();
  }
}

uci::type::RaceTrackOrbitType& OrbitChangeChoiceType::getRaceTrack_() const {
  if (raceTrack_Accessor) {
    return *raceTrack_Accessor;
  }
  throw uci::base::UCIException("Error in getRaceTrack(): Unable to get RaceTrack, field not selected");
}

const uci::type::RaceTrackOrbitType& OrbitChangeChoiceType::getRaceTrack() const {
  return getRaceTrack_();
}

uci::type::RaceTrackOrbitType& OrbitChangeChoiceType::getRaceTrack() {
  return getRaceTrack_();
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::setRaceTrack(const uci::type::RaceTrackOrbitType& accessor) {
  chooseRaceTrack();
  if (&accessor != raceTrack_Accessor.get()) {
    raceTrack_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool OrbitChangeChoiceType::isRaceTrack() const noexcept {
  return static_cast<bool>(raceTrack_Accessor);
}

uci::type::RaceTrackOrbitType& OrbitChangeChoiceType::chooseRaceTrack(const std::string& method, uci::base::accessorType::AccessorType type) {
  specificOrbit_Accessor.reset();
  specificPosition_Accessor.reset();
  rendezvous_Accessor.reset();
  proximityOperations_Accessor.reset();
  longitude_Accessor.reset();
  semimajorAxis_Accessor.reset();
  inclination_Accessor.reset();
  eccentricity_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::raceTrackOrbitType : type};
  if ((!raceTrack_Accessor) || (raceTrack_Accessor->getAccessorType() != requestedType)) {
    raceTrack_Accessor = RaceTrackOrbitType::create(type);
    if (!raceTrack_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *raceTrack_Accessor;
}

uci::type::RaceTrackOrbitType& OrbitChangeChoiceType::chooseRaceTrack(uci::base::accessorType::AccessorType type) {
  return chooseRaceTrack("chooseRaceTrack", type);
}

std::unique_ptr<OrbitChangeChoiceType> OrbitChangeChoiceType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::orbitChangeChoiceType : type};
  return (requestedType == uci::type::accessorType::orbitChangeChoiceType) ? boost::make_unique<OrbitChangeChoiceType>() : nullptr;
}

/**  */
namespace OrbitChangeChoiceType_Names {

constexpr const char* Extern_Type_Name{"OrbitChangeChoiceType"};
constexpr const char* SpecificOrbit_Name{"SpecificOrbit"};
constexpr const char* SpecificPosition_Name{"SpecificPosition"};
constexpr const char* Rendezvous_Name{"Rendezvous"};
constexpr const char* ProximityOperations_Name{"ProximityOperations"};
constexpr const char* Longitude_Name{"Longitude"};
constexpr const char* SemimajorAxis_Name{"SemimajorAxis"};
constexpr const char* Inclination_Name{"Inclination"};
constexpr const char* Eccentricity_Name{"Eccentricity"};
constexpr const char* RaceTrack_Name{"RaceTrack"};

} // namespace OrbitChangeChoiceType_Names

void OrbitChangeChoiceType::deserialize(const boost::property_tree::ptree& propTree, uci::type::OrbitChangeChoiceType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = OrbitChangeChoiceType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::SpecificOrbit_Name) {
      COE_OrbitType::deserialize(valueType.second, accessor.chooseSpecificOrbit(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::SpecificPosition_Name) {
      OrbitalVolumeType::deserialize(valueType.second, accessor.chooseSpecificPosition(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::Rendezvous_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseRendezvous(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::ProximityOperations_Name) {
      ProximityOperationsType::deserialize(valueType.second, accessor.chooseProximityOperations(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::Longitude_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setLongitude(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::SemimajorAxis_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setSemimajorAxis(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::Inclination_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setInclination(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::Eccentricity_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setEccentricity(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + OrbitChangeChoiceType_Names::RaceTrack_Name) {
      RaceTrackOrbitType::deserialize(valueType.second, accessor.chooseRaceTrack(), nodeName, nsPrefix);
    }
  }
}

std::string OrbitChangeChoiceType::serialize(const uci::type::OrbitChangeChoiceType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? OrbitChangeChoiceType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, OrbitChangeChoiceType_Names::Extern_Type_Name);
  }
  if (accessor.isSpecificOrbit()) {
    COE_OrbitType::serialize(accessor.getSpecificOrbit(), node, OrbitChangeChoiceType_Names::SpecificOrbit_Name);
  } else if (accessor.isSpecificPosition()) {
    OrbitalVolumeType::serialize(accessor.getSpecificPosition(), node, OrbitChangeChoiceType_Names::SpecificPosition_Name);
  } else if (accessor.isRendezvous()) {
    RSO_ApproachType::serialize(accessor.getRendezvous(), node, OrbitChangeChoiceType_Names::Rendezvous_Name);
  } else if (accessor.isProximityOperations()) {
    ProximityOperationsType::serialize(accessor.getProximityOperations(), node, OrbitChangeChoiceType_Names::ProximityOperations_Name);
  } else if (accessor.isLongitude()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getLongitude(), node, OrbitChangeChoiceType_Names::Longitude_Name);
  } else if (accessor.isSemimajorAxis()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getSemimajorAxis(), node, OrbitChangeChoiceType_Names::SemimajorAxis_Name);
  } else if (accessor.isInclination()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getInclination(), node, OrbitChangeChoiceType_Names::Inclination_Name);
  } else if (accessor.isEccentricity()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getEccentricity(), node, OrbitChangeChoiceType_Names::Eccentricity_Name);
  } else if (accessor.isRaceTrack()) {
    RaceTrackOrbitType::serialize(accessor.getRaceTrack(), node, OrbitChangeChoiceType_Names::RaceTrack_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::OrbitChangeChoiceType>().release());
}

uci::type::OrbitChangeChoiceType& OrbitChangeChoiceType::create(const uci::type::OrbitChangeChoiceType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::OrbitChangeChoiceType> newAccessor{boost::make_unique<asb_uci::type::OrbitChangeChoiceType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void OrbitChangeChoiceType::destroy(uci::type::OrbitChangeChoiceType& accessor) {
  delete dynamic_cast<asb_uci::type::OrbitChangeChoiceType*>(&accessor);
}

} // namespace type

} // namespace uci

