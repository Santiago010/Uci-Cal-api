/** @file EOB_SignalType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/EOB_SignalType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/EmitterFunctionType.h"
#include "asb_uci/type/FrequencyDataBaseType.h"
#include "asb_uci/type/ModulationOnPulseDataBaseType.h"
#include "asb_uci/type/PRI_DataBaseType.h"
#include "asb_uci/type/ScanDataBaseType.h"
#include "asb_uci/type/SignalAmplitudeType.h"
#include "asb_uci/type/SignalPulseWidthBaseType.h"
#include "asb_uci/util/DerivedTypesCopier.h"
#include "asb_uci/util/DerivedTypesCreator.h"
#include "asb_uci/util/DerivedTypesDeserializer.h"
#include "asb_uci/util/DerivedTypesSerializer.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/DateTimeType.h"
#include "uci/type/EOB_SignalType.h"
#include "uci/type/EmitterFunctionType.h"
#include "uci/type/FrequencyDataBaseType.h"
#include "uci/type/ModulationOnPulseDataBaseType.h"
#include "uci/type/PRI_DataBaseType.h"
#include "uci/type/ScanDataBaseType.h"
#include "uci/type/SignalAmplitudeType.h"
#include "uci/type/SignalPulseWidthBaseType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

EOB_SignalType::EOB_SignalType() = default;

EOB_SignalType::~EOB_SignalType() = default;

void EOB_SignalType::copy(const uci::type::EOB_SignalType& accessor) {
  copyImpl(accessor, false);
}

void EOB_SignalType::copyImpl(const uci::type::EOB_SignalType& accessor, const bool checkIfDerivation) {
  if (&accessor != this) {
    if (!checkIfDerivation || (accessor.getAccessorType() == uci::type::accessorType::eOB_SignalType)) {
      const auto& accessorImpl = dynamic_cast<const EOB_SignalType&>(accessor);
      if (accessorImpl.hasLastHeardTimestamp()) {
        setLastHeardTimestamp(accessorImpl.getLastHeardTimestamp());
      } else {
        clearLastHeardTimestamp();
      }
      if (accessorImpl.frequency_Accessor) {
        setFrequency(*(accessorImpl.frequency_Accessor));
      } else {
        frequency_Accessor.reset();
      }
      if (accessorImpl.pilotFrequency_Accessor) {
        setPilotFrequency(*(accessorImpl.pilotFrequency_Accessor));
      } else {
        pilotFrequency_Accessor.reset();
      }
      if (accessorImpl.pRI_Accessor) {
        setPRI(*(accessorImpl.pRI_Accessor));
      } else {
        pRI_Accessor.reset();
      }
      if (accessorImpl.pulseWidth_Accessor) {
        setPulseWidth(*(accessorImpl.pulseWidth_Accessor));
      } else {
        pulseWidth_Accessor.reset();
      }
      if (accessorImpl.scan_Accessor) {
        setScan(*(accessorImpl.scan_Accessor));
      } else {
        scan_Accessor.reset();
      }
      if (accessorImpl.modulationOnPulse_Accessor) {
        setModulationOnPulse(*(accessorImpl.modulationOnPulse_Accessor));
      } else {
        modulationOnPulse_Accessor.reset();
      }
      if (accessorImpl.amplitude_Accessor) {
        setAmplitude(*(accessorImpl.amplitude_Accessor));
      } else {
        amplitude_Accessor.reset();
      }
      if (accessorImpl.emitterFunction_Accessor) {
        setEmitterFunction(*(accessorImpl.emitterFunction_Accessor));
      } else {
        emitterFunction_Accessor.reset();
      }
    } else {
      asb_uci::util::DerivedTypesCopier::copy(accessor, *this);
    }
  }
}

void EOB_SignalType::reset() noexcept {
  clearLastHeardTimestamp();
  frequency_Accessor.reset();
  pilotFrequency_Accessor.reset();
  pRI_Accessor.reset();
  pulseWidth_Accessor.reset();
  scan_Accessor.reset();
  modulationOnPulse_Accessor.reset();
  amplitude_Accessor.reset();
  emitterFunction_Accessor.reset();
}

uci::type::DateTimeTypeValue EOB_SignalType::getLastHeardTimestamp() const {
  if (lastHeardTimestamp_Accessor) {
    return *lastHeardTimestamp_Accessor;
  }
  throw uci::base::UCIException("Error in getLastHeardTimestamp(): An attempt was made to get an optional field that was not enabled, call hasLastHeardTimestamp() to determine if it is safe to call getLastHeardTimestamp()");
}

uci::type::EOB_SignalType& EOB_SignalType::setLastHeardTimestamp(uci::type::DateTimeTypeValue value) {
  lastHeardTimestamp_Accessor = value;
  return *this;
}

bool EOB_SignalType::hasLastHeardTimestamp() const noexcept {
  return lastHeardTimestamp_Accessor.has_value();
}

uci::type::EOB_SignalType& EOB_SignalType::clearLastHeardTimestamp() noexcept {
  lastHeardTimestamp_Accessor.reset();
  return *this;
}

uci::type::FrequencyDataBaseType& EOB_SignalType::getFrequency_() const {
  if (frequency_Accessor) {
    return *frequency_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequency(): An attempt was made to get an optional field that was not enabled, call hasFrequency() to determine if it is safe to call getFrequency()");
}

const uci::type::FrequencyDataBaseType& EOB_SignalType::getFrequency() const {
  return getFrequency_();
}

uci::type::FrequencyDataBaseType& EOB_SignalType::getFrequency() {
  return getFrequency_();
}

uci::type::EOB_SignalType& EOB_SignalType::setFrequency(const uci::type::FrequencyDataBaseType& accessor) {
  enableFrequency(accessor.getAccessorType());
  if (&accessor != frequency_Accessor.get()) {
    frequency_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EOB_SignalType::hasFrequency() const noexcept {
  return static_cast<bool>(frequency_Accessor);
}

uci::type::FrequencyDataBaseType& EOB_SignalType::enableFrequency(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::frequencyDataBaseType : type};
  if ((!frequency_Accessor) || (frequency_Accessor->getAccessorType() != requestedType)) {
    frequency_Accessor = FrequencyDataBaseType::create(requestedType);
    if (!frequency_Accessor) {
      throw uci::base::UCIException("Error in enableFrequency(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *frequency_Accessor;
}

uci::type::EOB_SignalType& EOB_SignalType::clearFrequency() noexcept {
  frequency_Accessor.reset();
  return *this;
}

uci::type::FrequencyDataBaseType& EOB_SignalType::getPilotFrequency_() const {
  if (pilotFrequency_Accessor) {
    return *pilotFrequency_Accessor;
  }
  throw uci::base::UCIException("Error in getPilotFrequency(): An attempt was made to get an optional field that was not enabled, call hasPilotFrequency() to determine if it is safe to call getPilotFrequency()");
}

const uci::type::FrequencyDataBaseType& EOB_SignalType::getPilotFrequency() const {
  return getPilotFrequency_();
}

uci::type::FrequencyDataBaseType& EOB_SignalType::getPilotFrequency() {
  return getPilotFrequency_();
}

uci::type::EOB_SignalType& EOB_SignalType::setPilotFrequency(const uci::type::FrequencyDataBaseType& accessor) {
  enablePilotFrequency(accessor.getAccessorType());
  if (&accessor != pilotFrequency_Accessor.get()) {
    pilotFrequency_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EOB_SignalType::hasPilotFrequency() const noexcept {
  return static_cast<bool>(pilotFrequency_Accessor);
}

uci::type::FrequencyDataBaseType& EOB_SignalType::enablePilotFrequency(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::frequencyDataBaseType : type};
  if ((!pilotFrequency_Accessor) || (pilotFrequency_Accessor->getAccessorType() != requestedType)) {
    pilotFrequency_Accessor = FrequencyDataBaseType::create(requestedType);
    if (!pilotFrequency_Accessor) {
      throw uci::base::UCIException("Error in enablePilotFrequency(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *pilotFrequency_Accessor;
}

uci::type::EOB_SignalType& EOB_SignalType::clearPilotFrequency() noexcept {
  pilotFrequency_Accessor.reset();
  return *this;
}

uci::type::PRI_DataBaseType& EOB_SignalType::getPRI_() const {
  if (pRI_Accessor) {
    return *pRI_Accessor;
  }
  throw uci::base::UCIException("Error in getPRI(): An attempt was made to get an optional field that was not enabled, call hasPRI() to determine if it is safe to call getPRI()");
}

const uci::type::PRI_DataBaseType& EOB_SignalType::getPRI() const {
  return getPRI_();
}

uci::type::PRI_DataBaseType& EOB_SignalType::getPRI() {
  return getPRI_();
}

uci::type::EOB_SignalType& EOB_SignalType::setPRI(const uci::type::PRI_DataBaseType& accessor) {
  enablePRI(accessor.getAccessorType());
  if (&accessor != pRI_Accessor.get()) {
    pRI_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EOB_SignalType::hasPRI() const noexcept {
  return static_cast<bool>(pRI_Accessor);
}

uci::type::PRI_DataBaseType& EOB_SignalType::enablePRI(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::pRI_DataBaseType : type};
  if ((!pRI_Accessor) || (pRI_Accessor->getAccessorType() != requestedType)) {
    pRI_Accessor = PRI_DataBaseType::create(requestedType);
    if (!pRI_Accessor) {
      throw uci::base::UCIException("Error in enablePRI(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *pRI_Accessor;
}

uci::type::EOB_SignalType& EOB_SignalType::clearPRI() noexcept {
  pRI_Accessor.reset();
  return *this;
}

uci::type::SignalPulseWidthBaseType& EOB_SignalType::getPulseWidth_() const {
  if (pulseWidth_Accessor) {
    return *pulseWidth_Accessor;
  }
  throw uci::base::UCIException("Error in getPulseWidth(): An attempt was made to get an optional field that was not enabled, call hasPulseWidth() to determine if it is safe to call getPulseWidth()");
}

const uci::type::SignalPulseWidthBaseType& EOB_SignalType::getPulseWidth() const {
  return getPulseWidth_();
}

uci::type::SignalPulseWidthBaseType& EOB_SignalType::getPulseWidth() {
  return getPulseWidth_();
}

uci::type::EOB_SignalType& EOB_SignalType::setPulseWidth(const uci::type::SignalPulseWidthBaseType& accessor) {
  enablePulseWidth(accessor.getAccessorType());
  if (&accessor != pulseWidth_Accessor.get()) {
    pulseWidth_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EOB_SignalType::hasPulseWidth() const noexcept {
  return static_cast<bool>(pulseWidth_Accessor);
}

uci::type::SignalPulseWidthBaseType& EOB_SignalType::enablePulseWidth(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalPulseWidthBaseType : type};
  if ((!pulseWidth_Accessor) || (pulseWidth_Accessor->getAccessorType() != requestedType)) {
    pulseWidth_Accessor = SignalPulseWidthBaseType::create(requestedType);
    if (!pulseWidth_Accessor) {
      throw uci::base::UCIException("Error in enablePulseWidth(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *pulseWidth_Accessor;
}

uci::type::EOB_SignalType& EOB_SignalType::clearPulseWidth() noexcept {
  pulseWidth_Accessor.reset();
  return *this;
}

uci::type::ScanDataBaseType& EOB_SignalType::getScan_() const {
  if (scan_Accessor) {
    return *scan_Accessor;
  }
  throw uci::base::UCIException("Error in getScan(): An attempt was made to get an optional field that was not enabled, call hasScan() to determine if it is safe to call getScan()");
}

const uci::type::ScanDataBaseType& EOB_SignalType::getScan() const {
  return getScan_();
}

uci::type::ScanDataBaseType& EOB_SignalType::getScan() {
  return getScan_();
}

uci::type::EOB_SignalType& EOB_SignalType::setScan(const uci::type::ScanDataBaseType& accessor) {
  enableScan(accessor.getAccessorType());
  if (&accessor != scan_Accessor.get()) {
    scan_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EOB_SignalType::hasScan() const noexcept {
  return static_cast<bool>(scan_Accessor);
}

uci::type::ScanDataBaseType& EOB_SignalType::enableScan(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::scanDataBaseType : type};
  if ((!scan_Accessor) || (scan_Accessor->getAccessorType() != requestedType)) {
    scan_Accessor = ScanDataBaseType::create(requestedType);
    if (!scan_Accessor) {
      throw uci::base::UCIException("Error in enableScan(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *scan_Accessor;
}

uci::type::EOB_SignalType& EOB_SignalType::clearScan() noexcept {
  scan_Accessor.reset();
  return *this;
}

uci::type::ModulationOnPulseDataBaseType& EOB_SignalType::getModulationOnPulse_() const {
  if (modulationOnPulse_Accessor) {
    return *modulationOnPulse_Accessor;
  }
  throw uci::base::UCIException("Error in getModulationOnPulse(): An attempt was made to get an optional field that was not enabled, call hasModulationOnPulse() to determine if it is safe to call getModulationOnPulse()");
}

const uci::type::ModulationOnPulseDataBaseType& EOB_SignalType::getModulationOnPulse() const {
  return getModulationOnPulse_();
}

uci::type::ModulationOnPulseDataBaseType& EOB_SignalType::getModulationOnPulse() {
  return getModulationOnPulse_();
}

uci::type::EOB_SignalType& EOB_SignalType::setModulationOnPulse(const uci::type::ModulationOnPulseDataBaseType& accessor) {
  enableModulationOnPulse(accessor.getAccessorType());
  if (&accessor != modulationOnPulse_Accessor.get()) {
    modulationOnPulse_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EOB_SignalType::hasModulationOnPulse() const noexcept {
  return static_cast<bool>(modulationOnPulse_Accessor);
}

uci::type::ModulationOnPulseDataBaseType& EOB_SignalType::enableModulationOnPulse(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::modulationOnPulseDataBaseType : type};
  if ((!modulationOnPulse_Accessor) || (modulationOnPulse_Accessor->getAccessorType() != requestedType)) {
    modulationOnPulse_Accessor = ModulationOnPulseDataBaseType::create(requestedType);
    if (!modulationOnPulse_Accessor) {
      throw uci::base::UCIException("Error in enableModulationOnPulse(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *modulationOnPulse_Accessor;
}

uci::type::EOB_SignalType& EOB_SignalType::clearModulationOnPulse() noexcept {
  modulationOnPulse_Accessor.reset();
  return *this;
}

uci::type::SignalAmplitudeType& EOB_SignalType::getAmplitude_() const {
  if (amplitude_Accessor) {
    return *amplitude_Accessor;
  }
  throw uci::base::UCIException("Error in getAmplitude(): An attempt was made to get an optional field that was not enabled, call hasAmplitude() to determine if it is safe to call getAmplitude()");
}

const uci::type::SignalAmplitudeType& EOB_SignalType::getAmplitude() const {
  return getAmplitude_();
}

uci::type::SignalAmplitudeType& EOB_SignalType::getAmplitude() {
  return getAmplitude_();
}

uci::type::EOB_SignalType& EOB_SignalType::setAmplitude(const uci::type::SignalAmplitudeType& accessor) {
  enableAmplitude();
  if (&accessor != amplitude_Accessor.get()) {
    amplitude_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EOB_SignalType::hasAmplitude() const noexcept {
  return static_cast<bool>(amplitude_Accessor);
}

uci::type::SignalAmplitudeType& EOB_SignalType::enableAmplitude(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalAmplitudeType : type};
  if ((!amplitude_Accessor) || (amplitude_Accessor->getAccessorType() != requestedType)) {
    amplitude_Accessor = SignalAmplitudeType::create(requestedType);
    if (!amplitude_Accessor) {
      throw uci::base::UCIException("Error in enableAmplitude(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *amplitude_Accessor;
}

uci::type::EOB_SignalType& EOB_SignalType::clearAmplitude() noexcept {
  amplitude_Accessor.reset();
  return *this;
}

uci::type::EmitterFunctionType& EOB_SignalType::getEmitterFunction_() const {
  if (emitterFunction_Accessor) {
    return *emitterFunction_Accessor;
  }
  throw uci::base::UCIException("Error in getEmitterFunction(): An attempt was made to get an optional field that was not enabled, call hasEmitterFunction() to determine if it is safe to call getEmitterFunction()");
}

const uci::type::EmitterFunctionType& EOB_SignalType::getEmitterFunction() const {
  return getEmitterFunction_();
}

uci::type::EmitterFunctionType& EOB_SignalType::getEmitterFunction() {
  return getEmitterFunction_();
}

uci::type::EOB_SignalType& EOB_SignalType::setEmitterFunction(const uci::type::EmitterFunctionType& accessor) {
  enableEmitterFunction();
  if (&accessor != emitterFunction_Accessor.get()) {
    emitterFunction_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EOB_SignalType::hasEmitterFunction() const noexcept {
  return static_cast<bool>(emitterFunction_Accessor);
}

uci::type::EmitterFunctionType& EOB_SignalType::enableEmitterFunction(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::emitterFunctionType : type};
  if ((!emitterFunction_Accessor) || (emitterFunction_Accessor->getAccessorType() != requestedType)) {
    emitterFunction_Accessor = EmitterFunctionType::create(requestedType);
    if (!emitterFunction_Accessor) {
      throw uci::base::UCIException("Error in enableEmitterFunction(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *emitterFunction_Accessor;
}

uci::type::EOB_SignalType& EOB_SignalType::clearEmitterFunction() noexcept {
  emitterFunction_Accessor.reset();
  return *this;
}

std::unique_ptr<EOB_SignalType> EOB_SignalType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::eOB_SignalType : type};
  return std::unique_ptr<EOB_SignalType>(dynamic_cast<EOB_SignalType*>(asb_uci::util::DerivedTypesCreator::create(requestedType)));
}

/**  */
namespace EOB_SignalType_Names {

constexpr const char* Extern_Type_Name{"EOB_SignalType"};
constexpr const char* LastHeardTimestamp_Name{"LastHeardTimestamp"};
constexpr const char* Frequency_Name{"Frequency"};
constexpr const char* PilotFrequency_Name{"PilotFrequency"};
constexpr const char* PRI_Name{"PRI"};
constexpr const char* PulseWidth_Name{"PulseWidth"};
constexpr const char* Scan_Name{"Scan"};
constexpr const char* ModulationOnPulse_Name{"ModulationOnPulse"};
constexpr const char* Amplitude_Name{"Amplitude"};
constexpr const char* EmitterFunction_Name{"EmitterFunction"};

} // namespace EOB_SignalType_Names

void EOB_SignalType::deserialize(const boost::property_tree::ptree& propTree, uci::type::EOB_SignalType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = EOB_SignalType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::LastHeardTimestamp_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setLastHeardTimestamp(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::Frequency_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableFrequency(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::PilotFrequency_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enablePilotFrequency(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::PRI_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enablePRI(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::PulseWidth_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enablePulseWidth(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::Scan_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableScan(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::ModulationOnPulse_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableModulationOnPulse(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::Amplitude_Name) {
      SignalAmplitudeType::deserialize(valueType.second, accessor.enableAmplitude(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EOB_SignalType_Names::EmitterFunction_Name) {
      EmitterFunctionType::deserialize(valueType.second, accessor.enableEmitterFunction(), nodeName, nsPrefix);
    }
  }
}

std::string EOB_SignalType::serialize(const uci::type::EOB_SignalType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool checkIfDerivation, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? EOB_SignalType_Names::Extern_Type_Name : nodeName)};
  if (!checkIfDerivation || (accessor.getAccessorType() == uci::type::accessorType::eOB_SignalType)) {
    boost::property_tree::ptree newNode;
    boost::property_tree::ptree& node = (createNode ? newNode : propTree);
    if (addTypeAttribute) {
      asb_uci::util::SerializationHelpers::addTypeAttribute(node, EOB_SignalType_Names::Extern_Type_Name);
    }
    if (accessor.hasLastHeardTimestamp()) {
      asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getLastHeardTimestamp(), node, EOB_SignalType_Names::LastHeardTimestamp_Name);
    }
    if (accessor.hasFrequency()) {
      FrequencyDataBaseType::serialize(accessor.getFrequency(), node, EOB_SignalType_Names::Frequency_Name);
    }
    if (accessor.hasPilotFrequency()) {
      FrequencyDataBaseType::serialize(accessor.getPilotFrequency(), node, EOB_SignalType_Names::PilotFrequency_Name);
    }
    if (accessor.hasPRI()) {
      PRI_DataBaseType::serialize(accessor.getPRI(), node, EOB_SignalType_Names::PRI_Name);
    }
    if (accessor.hasPulseWidth()) {
      SignalPulseWidthBaseType::serialize(accessor.getPulseWidth(), node, EOB_SignalType_Names::PulseWidth_Name);
    }
    if (accessor.hasScan()) {
      ScanDataBaseType::serialize(accessor.getScan(), node, EOB_SignalType_Names::Scan_Name);
    }
    if (accessor.hasModulationOnPulse()) {
      ModulationOnPulseDataBaseType::serialize(accessor.getModulationOnPulse(), node, EOB_SignalType_Names::ModulationOnPulse_Name);
    }
    if (accessor.hasAmplitude()) {
      SignalAmplitudeType::serialize(accessor.getAmplitude(), node, EOB_SignalType_Names::Amplitude_Name);
    }
    if (accessor.hasEmitterFunction()) {
      EmitterFunctionType::serialize(accessor.getEmitterFunction(), node, EOB_SignalType_Names::EmitterFunction_Name);
    }
    if (createNode) {
      propTree.add_child(generatedNodeName, node);
    }
  } else {
    asb_uci::util::DerivedTypesSerializer::serialize(accessor, propTree, nodeName, createNode);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::EOB_SignalType& EOB_SignalType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::EOB_SignalType>().release());
}

uci::type::EOB_SignalType& EOB_SignalType::create(const uci::type::EOB_SignalType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::EOB_SignalType> newAccessor{boost::make_unique<asb_uci::type::EOB_SignalType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void EOB_SignalType::destroy(uci::type::EOB_SignalType& accessor) {
  delete dynamic_cast<asb_uci::type::EOB_SignalType*>(&accessor);
}

} // namespace type

} // namespace uci

