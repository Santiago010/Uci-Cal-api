/** @file Shape3D_ChoiceType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/Shape3D_ChoiceType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/ArcVolumeType.h"
#include "asb_uci/type/ConeType.h"
#include "asb_uci/type/CylinderType.h"
#include "asb_uci/type/DomeType.h"
#include "asb_uci/type/EllipsoidType.h"
#include "asb_uci/type/IncRaPeriodVolumeType.h"
#include "asb_uci/type/RectangularConeType.h"
#include "asb_uci/type/SphereType.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/ArcVolumeType.h"
#include "uci/type/ConeType.h"
#include "uci/type/CylinderType.h"
#include "uci/type/DomeType.h"
#include "uci/type/EllipsoidType.h"
#include "uci/type/IncRaPeriodVolumeType.h"
#include "uci/type/RectangularConeType.h"
#include "uci/type/Shape3D_ChoiceType.h"
#include "uci/type/SphereType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

Shape3D_ChoiceType::Shape3D_ChoiceType() = default;

Shape3D_ChoiceType::~Shape3D_ChoiceType() = default;

void Shape3D_ChoiceType::copy(const uci::type::Shape3D_ChoiceType& accessor) {
  copyImpl(accessor, false);
}

void Shape3D_ChoiceType::copyImpl(const uci::type::Shape3D_ChoiceType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const Shape3D_ChoiceType&>(accessor);
    if (accessorImpl.sphere_Accessor) {
      setSphere(*(accessorImpl.sphere_Accessor));
    } else {
      sphere_Accessor.reset();
    }
    if (accessorImpl.dome_Accessor) {
      setDome(*(accessorImpl.dome_Accessor));
    } else {
      dome_Accessor.reset();
    }
    if (accessorImpl.ellipsoid_Accessor) {
      setEllipsoid(*(accessorImpl.ellipsoid_Accessor));
    } else {
      ellipsoid_Accessor.reset();
    }
    if (accessorImpl.cylinder_Accessor) {
      setCylinder(*(accessorImpl.cylinder_Accessor));
    } else {
      cylinder_Accessor.reset();
    }
    if (accessorImpl.cone_Accessor) {
      setCone(*(accessorImpl.cone_Accessor));
    } else {
      cone_Accessor.reset();
    }
    if (accessorImpl.rectangularCone_Accessor) {
      setRectangularCone(*(accessorImpl.rectangularCone_Accessor));
    } else {
      rectangularCone_Accessor.reset();
    }
    if (accessorImpl.arcVolume_Accessor) {
      setArcVolume(*(accessorImpl.arcVolume_Accessor));
    } else {
      arcVolume_Accessor.reset();
    }
    if (accessorImpl.incRaPeriodVolume_Accessor) {
      setIncRaPeriodVolume(*(accessorImpl.incRaPeriodVolume_Accessor));
    } else {
      incRaPeriodVolume_Accessor.reset();
    }
  }
}

void Shape3D_ChoiceType::reset() noexcept {
  sphere_Accessor.reset();
  dome_Accessor.reset();
  ellipsoid_Accessor.reset();
  cylinder_Accessor.reset();
  cone_Accessor.reset();
  rectangularCone_Accessor.reset();
  arcVolume_Accessor.reset();
  incRaPeriodVolume_Accessor.reset();
}

uci::type::Shape3D_ChoiceType::Shape3D_ChoiceTypeChoice Shape3D_ChoiceType::getShape3D_ChoiceTypeChoiceOrdinal() const noexcept {
  if (sphere_Accessor) {
    return SHAPE3D_CHOICETYPE_CHOICE_SPHERE;
  }
  if (dome_Accessor) {
    return SHAPE3D_CHOICETYPE_CHOICE_DOME;
  }
  if (ellipsoid_Accessor) {
    return SHAPE3D_CHOICETYPE_CHOICE_ELLIPSOID;
  }
  if (cylinder_Accessor) {
    return SHAPE3D_CHOICETYPE_CHOICE_CYLINDER;
  }
  if (cone_Accessor) {
    return SHAPE3D_CHOICETYPE_CHOICE_CONE;
  }
  if (rectangularCone_Accessor) {
    return SHAPE3D_CHOICETYPE_CHOICE_RECTANGULARCONE;
  }
  if (arcVolume_Accessor) {
    return SHAPE3D_CHOICETYPE_CHOICE_ARCVOLUME;
  }
  if (incRaPeriodVolume_Accessor) {
    return SHAPE3D_CHOICETYPE_CHOICE_INCRAPERIODVOLUME;
  }
  return SHAPE3D_CHOICETYPE_CHOICE_NONE;
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setShape3D_ChoiceTypeChoiceOrdinal(uci::type::Shape3D_ChoiceType::Shape3D_ChoiceTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case SHAPE3D_CHOICETYPE_CHOICE_SPHERE:
      chooseSphere("setShape3D_ChoiceTypeChoiceOrdinal", type);
      break;
    case SHAPE3D_CHOICETYPE_CHOICE_DOME:
      chooseDome("setShape3D_ChoiceTypeChoiceOrdinal", type);
      break;
    case SHAPE3D_CHOICETYPE_CHOICE_ELLIPSOID:
      chooseEllipsoid("setShape3D_ChoiceTypeChoiceOrdinal", type);
      break;
    case SHAPE3D_CHOICETYPE_CHOICE_CYLINDER:
      chooseCylinder("setShape3D_ChoiceTypeChoiceOrdinal", type);
      break;
    case SHAPE3D_CHOICETYPE_CHOICE_CONE:
      chooseCone("setShape3D_ChoiceTypeChoiceOrdinal", type);
      break;
    case SHAPE3D_CHOICETYPE_CHOICE_RECTANGULARCONE:
      chooseRectangularCone("setShape3D_ChoiceTypeChoiceOrdinal", type);
      break;
    case SHAPE3D_CHOICETYPE_CHOICE_ARCVOLUME:
      chooseArcVolume("setShape3D_ChoiceTypeChoiceOrdinal", type);
      break;
    case SHAPE3D_CHOICETYPE_CHOICE_INCRAPERIODVOLUME:
      chooseIncRaPeriodVolume("setShape3D_ChoiceTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setShape3D_ChoiceTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::SphereType& Shape3D_ChoiceType::getSphere_() const {
  if (sphere_Accessor) {
    return *sphere_Accessor;
  }
  throw uci::base::UCIException("Error in getSphere(): Unable to get Sphere, field not selected");
}

const uci::type::SphereType& Shape3D_ChoiceType::getSphere() const {
  return getSphere_();
}

uci::type::SphereType& Shape3D_ChoiceType::getSphere() {
  return getSphere_();
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setSphere(const uci::type::SphereType& accessor) {
  chooseSphere();
  if (&accessor != sphere_Accessor.get()) {
    sphere_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Shape3D_ChoiceType::isSphere() const noexcept {
  return static_cast<bool>(sphere_Accessor);
}

uci::type::SphereType& Shape3D_ChoiceType::chooseSphere(const std::string& method, uci::base::accessorType::AccessorType type) {
  dome_Accessor.reset();
  ellipsoid_Accessor.reset();
  cylinder_Accessor.reset();
  cone_Accessor.reset();
  rectangularCone_Accessor.reset();
  arcVolume_Accessor.reset();
  incRaPeriodVolume_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::sphereType : type};
  if ((!sphere_Accessor) || (sphere_Accessor->getAccessorType() != requestedType)) {
    sphere_Accessor = SphereType::create(type);
    if (!sphere_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *sphere_Accessor;
}

uci::type::SphereType& Shape3D_ChoiceType::chooseSphere(uci::base::accessorType::AccessorType type) {
  return chooseSphere("chooseSphere", type);
}

uci::type::DomeType& Shape3D_ChoiceType::getDome_() const {
  if (dome_Accessor) {
    return *dome_Accessor;
  }
  throw uci::base::UCIException("Error in getDome(): Unable to get Dome, field not selected");
}

const uci::type::DomeType& Shape3D_ChoiceType::getDome() const {
  return getDome_();
}

uci::type::DomeType& Shape3D_ChoiceType::getDome() {
  return getDome_();
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setDome(const uci::type::DomeType& accessor) {
  chooseDome();
  if (&accessor != dome_Accessor.get()) {
    dome_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Shape3D_ChoiceType::isDome() const noexcept {
  return static_cast<bool>(dome_Accessor);
}

uci::type::DomeType& Shape3D_ChoiceType::chooseDome(const std::string& method, uci::base::accessorType::AccessorType type) {
  sphere_Accessor.reset();
  ellipsoid_Accessor.reset();
  cylinder_Accessor.reset();
  cone_Accessor.reset();
  rectangularCone_Accessor.reset();
  arcVolume_Accessor.reset();
  incRaPeriodVolume_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::domeType : type};
  if ((!dome_Accessor) || (dome_Accessor->getAccessorType() != requestedType)) {
    dome_Accessor = DomeType::create(type);
    if (!dome_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *dome_Accessor;
}

uci::type::DomeType& Shape3D_ChoiceType::chooseDome(uci::base::accessorType::AccessorType type) {
  return chooseDome("chooseDome", type);
}

uci::type::EllipsoidType& Shape3D_ChoiceType::getEllipsoid_() const {
  if (ellipsoid_Accessor) {
    return *ellipsoid_Accessor;
  }
  throw uci::base::UCIException("Error in getEllipsoid(): Unable to get Ellipsoid, field not selected");
}

const uci::type::EllipsoidType& Shape3D_ChoiceType::getEllipsoid() const {
  return getEllipsoid_();
}

uci::type::EllipsoidType& Shape3D_ChoiceType::getEllipsoid() {
  return getEllipsoid_();
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setEllipsoid(const uci::type::EllipsoidType& accessor) {
  chooseEllipsoid();
  if (&accessor != ellipsoid_Accessor.get()) {
    ellipsoid_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Shape3D_ChoiceType::isEllipsoid() const noexcept {
  return static_cast<bool>(ellipsoid_Accessor);
}

uci::type::EllipsoidType& Shape3D_ChoiceType::chooseEllipsoid(const std::string& method, uci::base::accessorType::AccessorType type) {
  sphere_Accessor.reset();
  dome_Accessor.reset();
  cylinder_Accessor.reset();
  cone_Accessor.reset();
  rectangularCone_Accessor.reset();
  arcVolume_Accessor.reset();
  incRaPeriodVolume_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::ellipsoidType : type};
  if ((!ellipsoid_Accessor) || (ellipsoid_Accessor->getAccessorType() != requestedType)) {
    ellipsoid_Accessor = EllipsoidType::create(type);
    if (!ellipsoid_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *ellipsoid_Accessor;
}

uci::type::EllipsoidType& Shape3D_ChoiceType::chooseEllipsoid(uci::base::accessorType::AccessorType type) {
  return chooseEllipsoid("chooseEllipsoid", type);
}

uci::type::CylinderType& Shape3D_ChoiceType::getCylinder_() const {
  if (cylinder_Accessor) {
    return *cylinder_Accessor;
  }
  throw uci::base::UCIException("Error in getCylinder(): Unable to get Cylinder, field not selected");
}

const uci::type::CylinderType& Shape3D_ChoiceType::getCylinder() const {
  return getCylinder_();
}

uci::type::CylinderType& Shape3D_ChoiceType::getCylinder() {
  return getCylinder_();
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setCylinder(const uci::type::CylinderType& accessor) {
  chooseCylinder();
  if (&accessor != cylinder_Accessor.get()) {
    cylinder_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Shape3D_ChoiceType::isCylinder() const noexcept {
  return static_cast<bool>(cylinder_Accessor);
}

uci::type::CylinderType& Shape3D_ChoiceType::chooseCylinder(const std::string& method, uci::base::accessorType::AccessorType type) {
  sphere_Accessor.reset();
  dome_Accessor.reset();
  ellipsoid_Accessor.reset();
  cone_Accessor.reset();
  rectangularCone_Accessor.reset();
  arcVolume_Accessor.reset();
  incRaPeriodVolume_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::cylinderType : type};
  if ((!cylinder_Accessor) || (cylinder_Accessor->getAccessorType() != requestedType)) {
    cylinder_Accessor = CylinderType::create(type);
    if (!cylinder_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *cylinder_Accessor;
}

uci::type::CylinderType& Shape3D_ChoiceType::chooseCylinder(uci::base::accessorType::AccessorType type) {
  return chooseCylinder("chooseCylinder", type);
}

uci::type::ConeType& Shape3D_ChoiceType::getCone_() const {
  if (cone_Accessor) {
    return *cone_Accessor;
  }
  throw uci::base::UCIException("Error in getCone(): Unable to get Cone, field not selected");
}

const uci::type::ConeType& Shape3D_ChoiceType::getCone() const {
  return getCone_();
}

uci::type::ConeType& Shape3D_ChoiceType::getCone() {
  return getCone_();
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setCone(const uci::type::ConeType& accessor) {
  chooseCone();
  if (&accessor != cone_Accessor.get()) {
    cone_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Shape3D_ChoiceType::isCone() const noexcept {
  return static_cast<bool>(cone_Accessor);
}

uci::type::ConeType& Shape3D_ChoiceType::chooseCone(const std::string& method, uci::base::accessorType::AccessorType type) {
  sphere_Accessor.reset();
  dome_Accessor.reset();
  ellipsoid_Accessor.reset();
  cylinder_Accessor.reset();
  rectangularCone_Accessor.reset();
  arcVolume_Accessor.reset();
  incRaPeriodVolume_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::coneType : type};
  if ((!cone_Accessor) || (cone_Accessor->getAccessorType() != requestedType)) {
    cone_Accessor = ConeType::create(type);
    if (!cone_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *cone_Accessor;
}

uci::type::ConeType& Shape3D_ChoiceType::chooseCone(uci::base::accessorType::AccessorType type) {
  return chooseCone("chooseCone", type);
}

uci::type::RectangularConeType& Shape3D_ChoiceType::getRectangularCone_() const {
  if (rectangularCone_Accessor) {
    return *rectangularCone_Accessor;
  }
  throw uci::base::UCIException("Error in getRectangularCone(): Unable to get RectangularCone, field not selected");
}

const uci::type::RectangularConeType& Shape3D_ChoiceType::getRectangularCone() const {
  return getRectangularCone_();
}

uci::type::RectangularConeType& Shape3D_ChoiceType::getRectangularCone() {
  return getRectangularCone_();
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setRectangularCone(const uci::type::RectangularConeType& accessor) {
  chooseRectangularCone();
  if (&accessor != rectangularCone_Accessor.get()) {
    rectangularCone_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Shape3D_ChoiceType::isRectangularCone() const noexcept {
  return static_cast<bool>(rectangularCone_Accessor);
}

uci::type::RectangularConeType& Shape3D_ChoiceType::chooseRectangularCone(const std::string& method, uci::base::accessorType::AccessorType type) {
  sphere_Accessor.reset();
  dome_Accessor.reset();
  ellipsoid_Accessor.reset();
  cylinder_Accessor.reset();
  cone_Accessor.reset();
  arcVolume_Accessor.reset();
  incRaPeriodVolume_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::rectangularConeType : type};
  if ((!rectangularCone_Accessor) || (rectangularCone_Accessor->getAccessorType() != requestedType)) {
    rectangularCone_Accessor = RectangularConeType::create(type);
    if (!rectangularCone_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *rectangularCone_Accessor;
}

uci::type::RectangularConeType& Shape3D_ChoiceType::chooseRectangularCone(uci::base::accessorType::AccessorType type) {
  return chooseRectangularCone("chooseRectangularCone", type);
}

uci::type::ArcVolumeType& Shape3D_ChoiceType::getArcVolume_() const {
  if (arcVolume_Accessor) {
    return *arcVolume_Accessor;
  }
  throw uci::base::UCIException("Error in getArcVolume(): Unable to get ArcVolume, field not selected");
}

const uci::type::ArcVolumeType& Shape3D_ChoiceType::getArcVolume() const {
  return getArcVolume_();
}

uci::type::ArcVolumeType& Shape3D_ChoiceType::getArcVolume() {
  return getArcVolume_();
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setArcVolume(const uci::type::ArcVolumeType& accessor) {
  chooseArcVolume();
  if (&accessor != arcVolume_Accessor.get()) {
    arcVolume_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Shape3D_ChoiceType::isArcVolume() const noexcept {
  return static_cast<bool>(arcVolume_Accessor);
}

uci::type::ArcVolumeType& Shape3D_ChoiceType::chooseArcVolume(const std::string& method, uci::base::accessorType::AccessorType type) {
  sphere_Accessor.reset();
  dome_Accessor.reset();
  ellipsoid_Accessor.reset();
  cylinder_Accessor.reset();
  cone_Accessor.reset();
  rectangularCone_Accessor.reset();
  incRaPeriodVolume_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::arcVolumeType : type};
  if ((!arcVolume_Accessor) || (arcVolume_Accessor->getAccessorType() != requestedType)) {
    arcVolume_Accessor = ArcVolumeType::create(type);
    if (!arcVolume_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *arcVolume_Accessor;
}

uci::type::ArcVolumeType& Shape3D_ChoiceType::chooseArcVolume(uci::base::accessorType::AccessorType type) {
  return chooseArcVolume("chooseArcVolume", type);
}

uci::type::IncRaPeriodVolumeType& Shape3D_ChoiceType::getIncRaPeriodVolume_() const {
  if (incRaPeriodVolume_Accessor) {
    return *incRaPeriodVolume_Accessor;
  }
  throw uci::base::UCIException("Error in getIncRaPeriodVolume(): Unable to get IncRaPeriodVolume, field not selected");
}

const uci::type::IncRaPeriodVolumeType& Shape3D_ChoiceType::getIncRaPeriodVolume() const {
  return getIncRaPeriodVolume_();
}

uci::type::IncRaPeriodVolumeType& Shape3D_ChoiceType::getIncRaPeriodVolume() {
  return getIncRaPeriodVolume_();
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::setIncRaPeriodVolume(const uci::type::IncRaPeriodVolumeType& accessor) {
  chooseIncRaPeriodVolume();
  if (&accessor != incRaPeriodVolume_Accessor.get()) {
    incRaPeriodVolume_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Shape3D_ChoiceType::isIncRaPeriodVolume() const noexcept {
  return static_cast<bool>(incRaPeriodVolume_Accessor);
}

uci::type::IncRaPeriodVolumeType& Shape3D_ChoiceType::chooseIncRaPeriodVolume(const std::string& method, uci::base::accessorType::AccessorType type) {
  sphere_Accessor.reset();
  dome_Accessor.reset();
  ellipsoid_Accessor.reset();
  cylinder_Accessor.reset();
  cone_Accessor.reset();
  rectangularCone_Accessor.reset();
  arcVolume_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::incRaPeriodVolumeType : type};
  if ((!incRaPeriodVolume_Accessor) || (incRaPeriodVolume_Accessor->getAccessorType() != requestedType)) {
    incRaPeriodVolume_Accessor = IncRaPeriodVolumeType::create(type);
    if (!incRaPeriodVolume_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *incRaPeriodVolume_Accessor;
}

uci::type::IncRaPeriodVolumeType& Shape3D_ChoiceType::chooseIncRaPeriodVolume(uci::base::accessorType::AccessorType type) {
  return chooseIncRaPeriodVolume("chooseIncRaPeriodVolume", type);
}

std::unique_ptr<Shape3D_ChoiceType> Shape3D_ChoiceType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::shape3D_ChoiceType : type};
  return (requestedType == uci::type::accessorType::shape3D_ChoiceType) ? boost::make_unique<Shape3D_ChoiceType>() : nullptr;
}

/**  */
namespace Shape3D_ChoiceType_Names {

constexpr const char* Extern_Type_Name{"Shape3D_ChoiceType"};
constexpr const char* Sphere_Name{"Sphere"};
constexpr const char* Dome_Name{"Dome"};
constexpr const char* Ellipsoid_Name{"Ellipsoid"};
constexpr const char* Cylinder_Name{"Cylinder"};
constexpr const char* Cone_Name{"Cone"};
constexpr const char* RectangularCone_Name{"RectangularCone"};
constexpr const char* ArcVolume_Name{"ArcVolume"};
constexpr const char* IncRaPeriodVolume_Name{"IncRaPeriodVolume"};

} // namespace Shape3D_ChoiceType_Names

void Shape3D_ChoiceType::deserialize(const boost::property_tree::ptree& propTree, uci::type::Shape3D_ChoiceType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = Shape3D_ChoiceType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + Shape3D_ChoiceType_Names::Sphere_Name) {
      SphereType::deserialize(valueType.second, accessor.chooseSphere(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Shape3D_ChoiceType_Names::Dome_Name) {
      DomeType::deserialize(valueType.second, accessor.chooseDome(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Shape3D_ChoiceType_Names::Ellipsoid_Name) {
      EllipsoidType::deserialize(valueType.second, accessor.chooseEllipsoid(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Shape3D_ChoiceType_Names::Cylinder_Name) {
      CylinderType::deserialize(valueType.second, accessor.chooseCylinder(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Shape3D_ChoiceType_Names::Cone_Name) {
      ConeType::deserialize(valueType.second, accessor.chooseCone(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Shape3D_ChoiceType_Names::RectangularCone_Name) {
      RectangularConeType::deserialize(valueType.second, accessor.chooseRectangularCone(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Shape3D_ChoiceType_Names::ArcVolume_Name) {
      ArcVolumeType::deserialize(valueType.second, accessor.chooseArcVolume(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Shape3D_ChoiceType_Names::IncRaPeriodVolume_Name) {
      IncRaPeriodVolumeType::deserialize(valueType.second, accessor.chooseIncRaPeriodVolume(), nodeName, nsPrefix);
    }
  }
}

std::string Shape3D_ChoiceType::serialize(const uci::type::Shape3D_ChoiceType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? Shape3D_ChoiceType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, Shape3D_ChoiceType_Names::Extern_Type_Name);
  }
  if (accessor.isSphere()) {
    SphereType::serialize(accessor.getSphere(), node, Shape3D_ChoiceType_Names::Sphere_Name);
  } else if (accessor.isDome()) {
    DomeType::serialize(accessor.getDome(), node, Shape3D_ChoiceType_Names::Dome_Name);
  } else if (accessor.isEllipsoid()) {
    EllipsoidType::serialize(accessor.getEllipsoid(), node, Shape3D_ChoiceType_Names::Ellipsoid_Name);
  } else if (accessor.isCylinder()) {
    CylinderType::serialize(accessor.getCylinder(), node, Shape3D_ChoiceType_Names::Cylinder_Name);
  } else if (accessor.isCone()) {
    ConeType::serialize(accessor.getCone(), node, Shape3D_ChoiceType_Names::Cone_Name);
  } else if (accessor.isRectangularCone()) {
    RectangularConeType::serialize(accessor.getRectangularCone(), node, Shape3D_ChoiceType_Names::RectangularCone_Name);
  } else if (accessor.isArcVolume()) {
    ArcVolumeType::serialize(accessor.getArcVolume(), node, Shape3D_ChoiceType_Names::ArcVolume_Name);
  } else if (accessor.isIncRaPeriodVolume()) {
    IncRaPeriodVolumeType::serialize(accessor.getIncRaPeriodVolume(), node, Shape3D_ChoiceType_Names::IncRaPeriodVolume_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::Shape3D_ChoiceType>().release());
}

uci::type::Shape3D_ChoiceType& Shape3D_ChoiceType::create(const uci::type::Shape3D_ChoiceType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::Shape3D_ChoiceType> newAccessor{boost::make_unique<asb_uci::type::Shape3D_ChoiceType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void Shape3D_ChoiceType::destroy(uci::type::Shape3D_ChoiceType& accessor) {
  delete dynamic_cast<asb_uci::type::Shape3D_ChoiceType*>(&accessor);
}

} // namespace type

} // namespace uci

