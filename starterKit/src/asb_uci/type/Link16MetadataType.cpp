/** @file Link16MetadataType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/Link16MetadataType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/CommCountermeasureSetEnum.h"
#include "../../../include/asb_uci/type/ConnectionStatusEnum.h"
#include "../../../include/asb_uci/type/DefensiveJammerSystemInfoType.h"
#include "../../../include/asb_uci/type/GenericUnitTypeEnum.h"
#include "../../../include/asb_uci/type/JammerStationType.h"
#include "../../../include/asb_uci/type/Link16ActiveRelayIndicatorsType.h"
#include "../../../include/asb_uci/type/Link16TrackNumberType.h"
#include "../../../include/asb_uci/type/NPSI_Enum.h"
#include "../../../include/asb_uci/type/NetworkLinkID_Type.h"
#include "../../../include/asb_uci/type/OperationalCapabilityEnum.h"
#include "../../../include/asb_uci/type/PositionTimeQualityEnum.h"
#include "../../../include/asb_uci/type/RadarChannelIndicatorEnum.h"
#include "../../../include/asb_uci/type/ReconnaissanceStatusType.h"
#include "../../../include/asb_uci/type/SiteEnum.h"
#include "../../../include/asb_uci/type/SystemID_Type.h"
#include "../../../include/asb_uci/type/TrackNumberOrEntityType.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommCountermeasureSetEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ConnectionStatusEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DateTimeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DefensiveJammerSystemInfoType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/GenericUnitTypeEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/JammerStationType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/Link16ActiveRelayIndicatorsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/Link16MetadataType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/Link16TrackNumberType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/Link16_ControlChannelType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/Link16_MissileChannelType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/Link16_RadarChannelType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/NPSI_Enum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/NetworkLinkID_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OperationalCapabilityEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PositionTimeQualityEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/RadarChannelIndicatorEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ReconnaissanceStatusType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SiteEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SystemID_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/TrackNumberOrEntityType.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

Link16MetadataType::Link16MetadataType()
  : defensiveJammerSystemInfo_Accessor{boost::make_unique<DefensiveJammerSystemInfo>(0, 2)},
    jammerStation_Accessor{boost::make_unique<JammerStation>(0, 10)} {
}

Link16MetadataType::~Link16MetadataType() = default;

void Link16MetadataType::copy(const uci::type::Link16MetadataType& accessor) {
  copyImpl(accessor, false);
}

void Link16MetadataType::copyImpl(const uci::type::Link16MetadataType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const Link16MetadataType&>(accessor);
    if (accessorImpl.networkLinkID_Accessor) {
      setNetworkLinkID(*(accessorImpl.networkLinkID_Accessor));
    } else {
      networkLinkID_Accessor.reset();
    }
    if (accessorImpl.sourceTrack_Accessor) {
      setSourceTrack(*(accessorImpl.sourceTrack_Accessor));
    } else {
      sourceTrack_Accessor.reset();
    }
    if (accessorImpl.reportingSystemID_Accessor) {
      setReportingSystemID(*(accessorImpl.reportingSystemID_Accessor));
    } else {
      reportingSystemID_Accessor.reset();
    }
    if (accessorImpl.hasAirborne()) {
      setAirborne(accessorImpl.getAirborne());
    } else {
      clearAirborne();
    }
    if (accessorImpl.hasControlChannel()) {
      setControlChannel(accessorImpl.getControlChannel());
    } else {
      clearControlChannel();
    }
    if (accessorImpl.hasFlightLeadIndicator()) {
      setFlightLeadIndicator(accessorImpl.getFlightLeadIndicator());
    } else {
      clearFlightLeadIndicator();
    }
    if (accessorImpl.flightLead_Accessor) {
      setFlightLead(*(accessorImpl.flightLead_Accessor));
    } else {
      flightLead_Accessor.reset();
    }
    if (accessorImpl.genericUnitType_Accessor) {
      setGenericUnitType(*(accessorImpl.genericUnitType_Accessor));
    } else {
      genericUnitType_Accessor.reset();
    }
    if (accessorImpl.hasMissionCommanderIndicator()) {
      setMissionCommanderIndicator(accessorImpl.getMissionCommanderIndicator());
    } else {
      clearMissionCommanderIndicator();
    }
    if (accessorImpl.hasPrecisionTime()) {
      setPrecisionTime(accessorImpl.getPrecisionTime());
    } else {
      clearPrecisionTime();
    }
    if (accessorImpl.positionTimeQuality_Accessor) {
      setPositionTimeQuality(*(accessorImpl.positionTimeQuality_Accessor));
    } else {
      positionTimeQuality_Accessor.reset();
    }
    if (accessorImpl.site_Accessor) {
      setSite(*(accessorImpl.site_Accessor));
    } else {
      site_Accessor.reset();
    }
    if (accessorImpl.operationalCapability_Accessor) {
      setOperationalCapability(*(accessorImpl.operationalCapability_Accessor));
    } else {
      operationalCapability_Accessor.reset();
    }
    if (accessorImpl.link16_Status_Accessor) {
      setLink16_Status(*(accessorImpl.link16_Status_Accessor));
    } else {
      link16_Status_Accessor.reset();
    }
    if (accessorImpl.reconnaissanceStatus_Accessor) {
      setReconnaissanceStatus(*(accessorImpl.reconnaissanceStatus_Accessor));
    } else {
      reconnaissanceStatus_Accessor.reset();
    }
    if (accessorImpl.networkParticipationStatusIndicator_Accessor) {
      setNetworkParticipationStatusIndicator(*(accessorImpl.networkParticipationStatusIndicator_Accessor));
    } else {
      networkParticipationStatusIndicator_Accessor.reset();
    }
    if (accessorImpl.radarChannelIndicator_Accessor) {
      setRadarChannelIndicator(*(accessorImpl.radarChannelIndicator_Accessor));
    } else {
      radarChannelIndicator_Accessor.reset();
    }
    if (accessorImpl.hasRadarChannel()) {
      setRadarChannel(accessorImpl.getRadarChannel());
    } else {
      clearRadarChannel();
    }
    if (accessorImpl.hasMissileChannel()) {
      setMissileChannel(accessorImpl.getMissileChannel());
    } else {
      clearMissileChannel();
    }
    setDefensiveJammerSystemInfo(*(accessorImpl.defensiveJammerSystemInfo_Accessor));
    setJammerStation(*(accessorImpl.jammerStation_Accessor));
    if (accessorImpl.commCountermeasureSet_Accessor) {
      setCommCountermeasureSet(*(accessorImpl.commCountermeasureSet_Accessor));
    } else {
      commCountermeasureSet_Accessor.reset();
    }
    if (accessorImpl.activeRelayIndicators_Accessor) {
      setActiveRelayIndicators(*(accessorImpl.activeRelayIndicators_Accessor));
    } else {
      activeRelayIndicators_Accessor.reset();
    }
    if (accessorImpl.missionCommander_Accessor) {
      setMissionCommander(*(accessorImpl.missionCommander_Accessor));
    } else {
      missionCommander_Accessor.reset();
    }
  }
}

void Link16MetadataType::reset() noexcept {
  networkLinkID_Accessor.reset();
  sourceTrack_Accessor.reset();
  reportingSystemID_Accessor.reset();
  clearAirborne();
  clearControlChannel();
  clearFlightLeadIndicator();
  flightLead_Accessor.reset();
  genericUnitType_Accessor.reset();
  clearMissionCommanderIndicator();
  clearPrecisionTime();
  positionTimeQuality_Accessor.reset();
  site_Accessor.reset();
  operationalCapability_Accessor.reset();
  link16_Status_Accessor.reset();
  reconnaissanceStatus_Accessor.reset();
  networkParticipationStatusIndicator_Accessor.reset();
  radarChannelIndicator_Accessor.reset();
  clearRadarChannel();
  clearMissileChannel();
  defensiveJammerSystemInfo_Accessor->reset();
  jammerStation_Accessor->reset();
  commCountermeasureSet_Accessor.reset();
  activeRelayIndicators_Accessor.reset();
  missionCommander_Accessor.reset();
}

uci::type::NetworkLinkID_Type& Link16MetadataType::getNetworkLinkID_() const {
  if (networkLinkID_Accessor) {
    return *networkLinkID_Accessor;
  }
  throw uci::base::UCIException("Error in getNetworkLinkID(): An attempt was made to get an optional field that was not enabled, call hasNetworkLinkID() to determine if it is safe to call getNetworkLinkID()");
}

const uci::type::NetworkLinkID_Type& Link16MetadataType::getNetworkLinkID() const {
  return getNetworkLinkID_();
}

uci::type::NetworkLinkID_Type& Link16MetadataType::getNetworkLinkID() {
  return getNetworkLinkID_();
}

uci::type::Link16MetadataType& Link16MetadataType::setNetworkLinkID(const uci::type::NetworkLinkID_Type& accessor) {
  enableNetworkLinkID();
  if (&accessor != networkLinkID_Accessor.get()) {
    networkLinkID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Link16MetadataType::hasNetworkLinkID() const noexcept {
  return static_cast<bool>(networkLinkID_Accessor);
}

uci::type::NetworkLinkID_Type& Link16MetadataType::enableNetworkLinkID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::networkLinkID_Type : type};
  if ((!networkLinkID_Accessor) || (networkLinkID_Accessor->getAccessorType() != requestedType)) {
    networkLinkID_Accessor = NetworkLinkID_Type::create(requestedType);
    if (!networkLinkID_Accessor) {
      throw uci::base::UCIException("Error in enableNetworkLinkID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *networkLinkID_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearNetworkLinkID() noexcept {
  networkLinkID_Accessor.reset();
  return *this;
}

uci::type::Link16TrackNumberType& Link16MetadataType::getSourceTrack_() const {
  if (sourceTrack_Accessor) {
    return *sourceTrack_Accessor;
  }
  throw uci::base::UCIException("Error in getSourceTrack(): An attempt was made to get an optional field that was not enabled, call hasSourceTrack() to determine if it is safe to call getSourceTrack()");
}

const uci::type::Link16TrackNumberType& Link16MetadataType::getSourceTrack() const {
  return getSourceTrack_();
}

uci::type::Link16TrackNumberType& Link16MetadataType::getSourceTrack() {
  return getSourceTrack_();
}

uci::type::Link16MetadataType& Link16MetadataType::setSourceTrack(const uci::type::Link16TrackNumberType& value) {
  return setSourceTrack(value.c_str());
}

uci::type::Link16MetadataType& Link16MetadataType::setSourceTrack(const std::string& value) {
  return setSourceTrack(value.c_str());
}

uci::type::Link16MetadataType& Link16MetadataType::setSourceTrack(const char* value) {
  enableSourceTrack().setStringValue(value);
  return *this;
}

bool Link16MetadataType::hasSourceTrack() const noexcept {
  return static_cast<bool>(sourceTrack_Accessor);
}

uci::type::Link16TrackNumberType& Link16MetadataType::enableSourceTrack(uci::base::accessorType::AccessorType type) {
  if (!sourceTrack_Accessor) {
    sourceTrack_Accessor = Link16TrackNumberType::create(type);
  }
  return *sourceTrack_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearSourceTrack() noexcept {
  sourceTrack_Accessor.reset();
  return *this;
}

uci::type::SystemID_Type& Link16MetadataType::getReportingSystemID_() const {
  if (reportingSystemID_Accessor) {
    return *reportingSystemID_Accessor;
  }
  throw uci::base::UCIException("Error in getReportingSystemID(): An attempt was made to get an optional field that was not enabled, call hasReportingSystemID() to determine if it is safe to call getReportingSystemID()");
}

const uci::type::SystemID_Type& Link16MetadataType::getReportingSystemID() const {
  return getReportingSystemID_();
}

uci::type::SystemID_Type& Link16MetadataType::getReportingSystemID() {
  return getReportingSystemID_();
}

uci::type::Link16MetadataType& Link16MetadataType::setReportingSystemID(const uci::type::SystemID_Type& accessor) {
  enableReportingSystemID();
  if (&accessor != reportingSystemID_Accessor.get()) {
    reportingSystemID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Link16MetadataType::hasReportingSystemID() const noexcept {
  return static_cast<bool>(reportingSystemID_Accessor);
}

uci::type::SystemID_Type& Link16MetadataType::enableReportingSystemID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::systemID_Type : type};
  if ((!reportingSystemID_Accessor) || (reportingSystemID_Accessor->getAccessorType() != requestedType)) {
    reportingSystemID_Accessor = SystemID_Type::create(requestedType);
    if (!reportingSystemID_Accessor) {
      throw uci::base::UCIException("Error in enableReportingSystemID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *reportingSystemID_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearReportingSystemID() noexcept {
  reportingSystemID_Accessor.reset();
  return *this;
}

xs::Boolean Link16MetadataType::getAirborne() const {
  if (airborne_Accessor) {
    return *airborne_Accessor;
  }
  throw uci::base::UCIException("Error in getAirborne(): An attempt was made to get an optional field that was not enabled, call hasAirborne() to determine if it is safe to call getAirborne()");
}

uci::type::Link16MetadataType& Link16MetadataType::setAirborne(xs::Boolean value) {
  airborne_Accessor = value;
  return *this;
}

bool Link16MetadataType::hasAirborne() const noexcept {
  return airborne_Accessor.has_value();
}

uci::type::Link16MetadataType& Link16MetadataType::clearAirborne() noexcept {
  airborne_Accessor.reset();
  return *this;
}

uci::type::Link16_ControlChannelTypeValue Link16MetadataType::getControlChannel() const {
  if (controlChannel_Accessor) {
    return *controlChannel_Accessor;
  }
  throw uci::base::UCIException("Error in getControlChannel(): An attempt was made to get an optional field that was not enabled, call hasControlChannel() to determine if it is safe to call getControlChannel()");
}

uci::type::Link16MetadataType& Link16MetadataType::setControlChannel(uci::type::Link16_ControlChannelTypeValue value) {
  controlChannel_Accessor = value;
  return *this;
}

bool Link16MetadataType::hasControlChannel() const noexcept {
  return controlChannel_Accessor.has_value();
}

uci::type::Link16MetadataType& Link16MetadataType::clearControlChannel() noexcept {
  controlChannel_Accessor.reset();
  return *this;
}

xs::Boolean Link16MetadataType::getFlightLeadIndicator() const {
  if (flightLeadIndicator_Accessor) {
    return *flightLeadIndicator_Accessor;
  }
  throw uci::base::UCIException("Error in getFlightLeadIndicator(): An attempt was made to get an optional field that was not enabled, call hasFlightLeadIndicator() to determine if it is safe to call getFlightLeadIndicator()");
}

uci::type::Link16MetadataType& Link16MetadataType::setFlightLeadIndicator(xs::Boolean value) {
  flightLeadIndicator_Accessor = value;
  return *this;
}

bool Link16MetadataType::hasFlightLeadIndicator() const noexcept {
  return flightLeadIndicator_Accessor.has_value();
}

uci::type::Link16MetadataType& Link16MetadataType::clearFlightLeadIndicator() noexcept {
  flightLeadIndicator_Accessor.reset();
  return *this;
}

uci::type::TrackNumberOrEntityType& Link16MetadataType::getFlightLead_() const {
  if (flightLead_Accessor) {
    return *flightLead_Accessor;
  }
  throw uci::base::UCIException("Error in getFlightLead(): An attempt was made to get an optional field that was not enabled, call hasFlightLead() to determine if it is safe to call getFlightLead()");
}

const uci::type::TrackNumberOrEntityType& Link16MetadataType::getFlightLead() const {
  return getFlightLead_();
}

uci::type::TrackNumberOrEntityType& Link16MetadataType::getFlightLead() {
  return getFlightLead_();
}

uci::type::Link16MetadataType& Link16MetadataType::setFlightLead(const uci::type::TrackNumberOrEntityType& accessor) {
  enableFlightLead();
  if (&accessor != flightLead_Accessor.get()) {
    flightLead_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Link16MetadataType::hasFlightLead() const noexcept {
  return static_cast<bool>(flightLead_Accessor);
}

uci::type::TrackNumberOrEntityType& Link16MetadataType::enableFlightLead(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::trackNumberOrEntityType : type};
  if ((!flightLead_Accessor) || (flightLead_Accessor->getAccessorType() != requestedType)) {
    flightLead_Accessor = TrackNumberOrEntityType::create(requestedType);
    if (!flightLead_Accessor) {
      throw uci::base::UCIException("Error in enableFlightLead(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *flightLead_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearFlightLead() noexcept {
  flightLead_Accessor.reset();
  return *this;
}

uci::type::GenericUnitTypeEnum& Link16MetadataType::getGenericUnitType_() const {
  if (genericUnitType_Accessor) {
    return *genericUnitType_Accessor;
  }
  throw uci::base::UCIException("Error in getGenericUnitType(): An attempt was made to get an optional field that was not enabled, call hasGenericUnitType() to determine if it is safe to call getGenericUnitType()");
}

const uci::type::GenericUnitTypeEnum& Link16MetadataType::getGenericUnitType() const {
  return getGenericUnitType_();
}

uci::type::GenericUnitTypeEnum& Link16MetadataType::getGenericUnitType() {
  return getGenericUnitType_();
}

uci::type::Link16MetadataType& Link16MetadataType::setGenericUnitType(const uci::type::GenericUnitTypeEnum& accessor) {
  enableGenericUnitType();
  if (&accessor != genericUnitType_Accessor.get()) {
    genericUnitType_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::Link16MetadataType& Link16MetadataType::setGenericUnitType(const uci::type::GenericUnitTypeEnum::EnumerationItem value) {
  enableGenericUnitType().setValue(value);
  return *this;
}

bool Link16MetadataType::hasGenericUnitType() const noexcept {
  return static_cast<bool>(genericUnitType_Accessor);
}

uci::type::GenericUnitTypeEnum& Link16MetadataType::enableGenericUnitType(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::genericUnitTypeEnum : type};
  if ((!genericUnitType_Accessor) || (genericUnitType_Accessor->getAccessorType() != requestedType)) {
    genericUnitType_Accessor = GenericUnitTypeEnum::create(requestedType);
    if (!genericUnitType_Accessor) {
      throw uci::base::UCIException("Error in enableGenericUnitType(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *genericUnitType_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearGenericUnitType() noexcept {
  genericUnitType_Accessor.reset();
  return *this;
}

xs::Boolean Link16MetadataType::getMissionCommanderIndicator() const {
  if (missionCommanderIndicator_Accessor) {
    return *missionCommanderIndicator_Accessor;
  }
  throw uci::base::UCIException("Error in getMissionCommanderIndicator(): An attempt was made to get an optional field that was not enabled, call hasMissionCommanderIndicator() to determine if it is safe to call getMissionCommanderIndicator()");
}

uci::type::Link16MetadataType& Link16MetadataType::setMissionCommanderIndicator(xs::Boolean value) {
  missionCommanderIndicator_Accessor = value;
  return *this;
}

bool Link16MetadataType::hasMissionCommanderIndicator() const noexcept {
  return missionCommanderIndicator_Accessor.has_value();
}

uci::type::Link16MetadataType& Link16MetadataType::clearMissionCommanderIndicator() noexcept {
  missionCommanderIndicator_Accessor.reset();
  return *this;
}

uci::type::DateTimeTypeValue Link16MetadataType::getPrecisionTime() const {
  if (precisionTime_Accessor) {
    return *precisionTime_Accessor;
  }
  throw uci::base::UCIException("Error in getPrecisionTime(): An attempt was made to get an optional field that was not enabled, call hasPrecisionTime() to determine if it is safe to call getPrecisionTime()");
}

uci::type::Link16MetadataType& Link16MetadataType::setPrecisionTime(uci::type::DateTimeTypeValue value) {
  precisionTime_Accessor = value;
  return *this;
}

bool Link16MetadataType::hasPrecisionTime() const noexcept {
  return precisionTime_Accessor.has_value();
}

uci::type::Link16MetadataType& Link16MetadataType::clearPrecisionTime() noexcept {
  precisionTime_Accessor.reset();
  return *this;
}

uci::type::PositionTimeQualityEnum& Link16MetadataType::getPositionTimeQuality_() const {
  if (positionTimeQuality_Accessor) {
    return *positionTimeQuality_Accessor;
  }
  throw uci::base::UCIException("Error in getPositionTimeQuality(): An attempt was made to get an optional field that was not enabled, call hasPositionTimeQuality() to determine if it is safe to call getPositionTimeQuality()");
}

const uci::type::PositionTimeQualityEnum& Link16MetadataType::getPositionTimeQuality() const {
  return getPositionTimeQuality_();
}

uci::type::PositionTimeQualityEnum& Link16MetadataType::getPositionTimeQuality() {
  return getPositionTimeQuality_();
}

uci::type::Link16MetadataType& Link16MetadataType::setPositionTimeQuality(const uci::type::PositionTimeQualityEnum& accessor) {
  enablePositionTimeQuality();
  if (&accessor != positionTimeQuality_Accessor.get()) {
    positionTimeQuality_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::Link16MetadataType& Link16MetadataType::setPositionTimeQuality(const uci::type::PositionTimeQualityEnum::EnumerationItem value) {
  enablePositionTimeQuality().setValue(value);
  return *this;
}

bool Link16MetadataType::hasPositionTimeQuality() const noexcept {
  return static_cast<bool>(positionTimeQuality_Accessor);
}

uci::type::PositionTimeQualityEnum& Link16MetadataType::enablePositionTimeQuality(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::positionTimeQualityEnum : type};
  if ((!positionTimeQuality_Accessor) || (positionTimeQuality_Accessor->getAccessorType() != requestedType)) {
    positionTimeQuality_Accessor = PositionTimeQualityEnum::create(requestedType);
    if (!positionTimeQuality_Accessor) {
      throw uci::base::UCIException("Error in enablePositionTimeQuality(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *positionTimeQuality_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearPositionTimeQuality() noexcept {
  positionTimeQuality_Accessor.reset();
  return *this;
}

uci::type::SiteEnum& Link16MetadataType::getSite_() const {
  if (site_Accessor) {
    return *site_Accessor;
  }
  throw uci::base::UCIException("Error in getSite(): An attempt was made to get an optional field that was not enabled, call hasSite() to determine if it is safe to call getSite()");
}

const uci::type::SiteEnum& Link16MetadataType::getSite() const {
  return getSite_();
}

uci::type::SiteEnum& Link16MetadataType::getSite() {
  return getSite_();
}

uci::type::Link16MetadataType& Link16MetadataType::setSite(const uci::type::SiteEnum& accessor) {
  enableSite();
  if (&accessor != site_Accessor.get()) {
    site_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::Link16MetadataType& Link16MetadataType::setSite(const uci::type::SiteEnum::EnumerationItem value) {
  enableSite().setValue(value);
  return *this;
}

bool Link16MetadataType::hasSite() const noexcept {
  return static_cast<bool>(site_Accessor);
}

uci::type::SiteEnum& Link16MetadataType::enableSite(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::siteEnum : type};
  if ((!site_Accessor) || (site_Accessor->getAccessorType() != requestedType)) {
    site_Accessor = SiteEnum::create(requestedType);
    if (!site_Accessor) {
      throw uci::base::UCIException("Error in enableSite(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *site_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearSite() noexcept {
  site_Accessor.reset();
  return *this;
}

uci::type::OperationalCapabilityEnum& Link16MetadataType::getOperationalCapability_() const {
  if (operationalCapability_Accessor) {
    return *operationalCapability_Accessor;
  }
  throw uci::base::UCIException("Error in getOperationalCapability(): An attempt was made to get an optional field that was not enabled, call hasOperationalCapability() to determine if it is safe to call getOperationalCapability()");
}

const uci::type::OperationalCapabilityEnum& Link16MetadataType::getOperationalCapability() const {
  return getOperationalCapability_();
}

uci::type::OperationalCapabilityEnum& Link16MetadataType::getOperationalCapability() {
  return getOperationalCapability_();
}

uci::type::Link16MetadataType& Link16MetadataType::setOperationalCapability(const uci::type::OperationalCapabilityEnum& accessor) {
  enableOperationalCapability();
  if (&accessor != operationalCapability_Accessor.get()) {
    operationalCapability_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::Link16MetadataType& Link16MetadataType::setOperationalCapability(const uci::type::OperationalCapabilityEnum::EnumerationItem value) {
  enableOperationalCapability().setValue(value);
  return *this;
}

bool Link16MetadataType::hasOperationalCapability() const noexcept {
  return static_cast<bool>(operationalCapability_Accessor);
}

uci::type::OperationalCapabilityEnum& Link16MetadataType::enableOperationalCapability(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::operationalCapabilityEnum : type};
  if ((!operationalCapability_Accessor) || (operationalCapability_Accessor->getAccessorType() != requestedType)) {
    operationalCapability_Accessor = OperationalCapabilityEnum::create(requestedType);
    if (!operationalCapability_Accessor) {
      throw uci::base::UCIException("Error in enableOperationalCapability(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *operationalCapability_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearOperationalCapability() noexcept {
  operationalCapability_Accessor.reset();
  return *this;
}

uci::type::ConnectionStatusEnum& Link16MetadataType::getLink16_Status_() const {
  if (link16_Status_Accessor) {
    return *link16_Status_Accessor;
  }
  throw uci::base::UCIException("Error in getLink16_Status(): An attempt was made to get an optional field that was not enabled, call hasLink16_Status() to determine if it is safe to call getLink16_Status()");
}

const uci::type::ConnectionStatusEnum& Link16MetadataType::getLink16_Status() const {
  return getLink16_Status_();
}

uci::type::ConnectionStatusEnum& Link16MetadataType::getLink16_Status() {
  return getLink16_Status_();
}

uci::type::Link16MetadataType& Link16MetadataType::setLink16_Status(const uci::type::ConnectionStatusEnum& accessor) {
  enableLink16_Status();
  if (&accessor != link16_Status_Accessor.get()) {
    link16_Status_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::Link16MetadataType& Link16MetadataType::setLink16_Status(const uci::type::ConnectionStatusEnum::EnumerationItem value) {
  enableLink16_Status().setValue(value);
  return *this;
}

bool Link16MetadataType::hasLink16_Status() const noexcept {
  return static_cast<bool>(link16_Status_Accessor);
}

uci::type::ConnectionStatusEnum& Link16MetadataType::enableLink16_Status(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::connectionStatusEnum : type};
  if ((!link16_Status_Accessor) || (link16_Status_Accessor->getAccessorType() != requestedType)) {
    link16_Status_Accessor = ConnectionStatusEnum::create(requestedType);
    if (!link16_Status_Accessor) {
      throw uci::base::UCIException("Error in enableLink16_Status(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *link16_Status_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearLink16_Status() noexcept {
  link16_Status_Accessor.reset();
  return *this;
}

uci::type::ReconnaissanceStatusType& Link16MetadataType::getReconnaissanceStatus_() const {
  if (reconnaissanceStatus_Accessor) {
    return *reconnaissanceStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getReconnaissanceStatus(): An attempt was made to get an optional field that was not enabled, call hasReconnaissanceStatus() to determine if it is safe to call getReconnaissanceStatus()");
}

const uci::type::ReconnaissanceStatusType& Link16MetadataType::getReconnaissanceStatus() const {
  return getReconnaissanceStatus_();
}

uci::type::ReconnaissanceStatusType& Link16MetadataType::getReconnaissanceStatus() {
  return getReconnaissanceStatus_();
}

uci::type::Link16MetadataType& Link16MetadataType::setReconnaissanceStatus(const uci::type::ReconnaissanceStatusType& accessor) {
  enableReconnaissanceStatus();
  if (&accessor != reconnaissanceStatus_Accessor.get()) {
    reconnaissanceStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Link16MetadataType::hasReconnaissanceStatus() const noexcept {
  return static_cast<bool>(reconnaissanceStatus_Accessor);
}

uci::type::ReconnaissanceStatusType& Link16MetadataType::enableReconnaissanceStatus(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::reconnaissanceStatusType : type};
  if ((!reconnaissanceStatus_Accessor) || (reconnaissanceStatus_Accessor->getAccessorType() != requestedType)) {
    reconnaissanceStatus_Accessor = ReconnaissanceStatusType::create(requestedType);
    if (!reconnaissanceStatus_Accessor) {
      throw uci::base::UCIException("Error in enableReconnaissanceStatus(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *reconnaissanceStatus_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearReconnaissanceStatus() noexcept {
  reconnaissanceStatus_Accessor.reset();
  return *this;
}

uci::type::NPSI_Enum& Link16MetadataType::getNetworkParticipationStatusIndicator_() const {
  if (networkParticipationStatusIndicator_Accessor) {
    return *networkParticipationStatusIndicator_Accessor;
  }
  throw uci::base::UCIException("Error in getNetworkParticipationStatusIndicator(): An attempt was made to get an optional field that was not enabled, call hasNetworkParticipationStatusIndicator() to determine if it is safe to call getNetworkParticipationStatusIndicator()");
}

const uci::type::NPSI_Enum& Link16MetadataType::getNetworkParticipationStatusIndicator() const {
  return getNetworkParticipationStatusIndicator_();
}

uci::type::NPSI_Enum& Link16MetadataType::getNetworkParticipationStatusIndicator() {
  return getNetworkParticipationStatusIndicator_();
}

uci::type::Link16MetadataType& Link16MetadataType::setNetworkParticipationStatusIndicator(const uci::type::NPSI_Enum& accessor) {
  enableNetworkParticipationStatusIndicator();
  if (&accessor != networkParticipationStatusIndicator_Accessor.get()) {
    networkParticipationStatusIndicator_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::Link16MetadataType& Link16MetadataType::setNetworkParticipationStatusIndicator(const uci::type::NPSI_Enum::EnumerationItem value) {
  enableNetworkParticipationStatusIndicator().setValue(value);
  return *this;
}

bool Link16MetadataType::hasNetworkParticipationStatusIndicator() const noexcept {
  return static_cast<bool>(networkParticipationStatusIndicator_Accessor);
}

uci::type::NPSI_Enum& Link16MetadataType::enableNetworkParticipationStatusIndicator(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::nPSI_Enum : type};
  if ((!networkParticipationStatusIndicator_Accessor) || (networkParticipationStatusIndicator_Accessor->getAccessorType() != requestedType)) {
    networkParticipationStatusIndicator_Accessor = NPSI_Enum::create(requestedType);
    if (!networkParticipationStatusIndicator_Accessor) {
      throw uci::base::UCIException("Error in enableNetworkParticipationStatusIndicator(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *networkParticipationStatusIndicator_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearNetworkParticipationStatusIndicator() noexcept {
  networkParticipationStatusIndicator_Accessor.reset();
  return *this;
}

uci::type::RadarChannelIndicatorEnum& Link16MetadataType::getRadarChannelIndicator_() const {
  if (radarChannelIndicator_Accessor) {
    return *radarChannelIndicator_Accessor;
  }
  throw uci::base::UCIException("Error in getRadarChannelIndicator(): An attempt was made to get an optional field that was not enabled, call hasRadarChannelIndicator() to determine if it is safe to call getRadarChannelIndicator()");
}

const uci::type::RadarChannelIndicatorEnum& Link16MetadataType::getRadarChannelIndicator() const {
  return getRadarChannelIndicator_();
}

uci::type::RadarChannelIndicatorEnum& Link16MetadataType::getRadarChannelIndicator() {
  return getRadarChannelIndicator_();
}

uci::type::Link16MetadataType& Link16MetadataType::setRadarChannelIndicator(const uci::type::RadarChannelIndicatorEnum& accessor) {
  enableRadarChannelIndicator();
  if (&accessor != radarChannelIndicator_Accessor.get()) {
    radarChannelIndicator_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::Link16MetadataType& Link16MetadataType::setRadarChannelIndicator(const uci::type::RadarChannelIndicatorEnum::EnumerationItem value) {
  enableRadarChannelIndicator().setValue(value);
  return *this;
}

bool Link16MetadataType::hasRadarChannelIndicator() const noexcept {
  return static_cast<bool>(radarChannelIndicator_Accessor);
}

uci::type::RadarChannelIndicatorEnum& Link16MetadataType::enableRadarChannelIndicator(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::radarChannelIndicatorEnum : type};
  if ((!radarChannelIndicator_Accessor) || (radarChannelIndicator_Accessor->getAccessorType() != requestedType)) {
    radarChannelIndicator_Accessor = RadarChannelIndicatorEnum::create(requestedType);
    if (!radarChannelIndicator_Accessor) {
      throw uci::base::UCIException("Error in enableRadarChannelIndicator(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *radarChannelIndicator_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearRadarChannelIndicator() noexcept {
  radarChannelIndicator_Accessor.reset();
  return *this;
}

uci::type::Link16_RadarChannelTypeValue Link16MetadataType::getRadarChannel() const {
  if (radarChannel_Accessor) {
    return *radarChannel_Accessor;
  }
  throw uci::base::UCIException("Error in getRadarChannel(): An attempt was made to get an optional field that was not enabled, call hasRadarChannel() to determine if it is safe to call getRadarChannel()");
}

uci::type::Link16MetadataType& Link16MetadataType::setRadarChannel(uci::type::Link16_RadarChannelTypeValue value) {
  radarChannel_Accessor = value;
  return *this;
}

bool Link16MetadataType::hasRadarChannel() const noexcept {
  return radarChannel_Accessor.has_value();
}

uci::type::Link16MetadataType& Link16MetadataType::clearRadarChannel() noexcept {
  radarChannel_Accessor.reset();
  return *this;
}

uci::type::Link16_MissileChannelTypeValue Link16MetadataType::getMissileChannel() const {
  if (missileChannel_Accessor) {
    return *missileChannel_Accessor;
  }
  throw uci::base::UCIException("Error in getMissileChannel(): An attempt was made to get an optional field that was not enabled, call hasMissileChannel() to determine if it is safe to call getMissileChannel()");
}

uci::type::Link16MetadataType& Link16MetadataType::setMissileChannel(uci::type::Link16_MissileChannelTypeValue value) {
  missileChannel_Accessor = value;
  return *this;
}

bool Link16MetadataType::hasMissileChannel() const noexcept {
  return missileChannel_Accessor.has_value();
}

uci::type::Link16MetadataType& Link16MetadataType::clearMissileChannel() noexcept {
  missileChannel_Accessor.reset();
  return *this;
}

const uci::type::Link16MetadataType::DefensiveJammerSystemInfo& Link16MetadataType::getDefensiveJammerSystemInfo() const {
  return *defensiveJammerSystemInfo_Accessor;
}

uci::type::Link16MetadataType::DefensiveJammerSystemInfo& Link16MetadataType::getDefensiveJammerSystemInfo() {
  return *defensiveJammerSystemInfo_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::setDefensiveJammerSystemInfo(const uci::type::Link16MetadataType::DefensiveJammerSystemInfo& accessor) {
  if (&accessor != defensiveJammerSystemInfo_Accessor.get()) {
    defensiveJammerSystemInfo_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::Link16MetadataType::JammerStation& Link16MetadataType::getJammerStation() const {
  return *jammerStation_Accessor;
}

uci::type::Link16MetadataType::JammerStation& Link16MetadataType::getJammerStation() {
  return *jammerStation_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::setJammerStation(const uci::type::Link16MetadataType::JammerStation& accessor) {
  if (&accessor != jammerStation_Accessor.get()) {
    jammerStation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommCountermeasureSetEnum& Link16MetadataType::getCommCountermeasureSet_() const {
  if (commCountermeasureSet_Accessor) {
    return *commCountermeasureSet_Accessor;
  }
  throw uci::base::UCIException("Error in getCommCountermeasureSet(): An attempt was made to get an optional field that was not enabled, call hasCommCountermeasureSet() to determine if it is safe to call getCommCountermeasureSet()");
}

const uci::type::CommCountermeasureSetEnum& Link16MetadataType::getCommCountermeasureSet() const {
  return getCommCountermeasureSet_();
}

uci::type::CommCountermeasureSetEnum& Link16MetadataType::getCommCountermeasureSet() {
  return getCommCountermeasureSet_();
}

uci::type::Link16MetadataType& Link16MetadataType::setCommCountermeasureSet(const uci::type::CommCountermeasureSetEnum& accessor) {
  enableCommCountermeasureSet();
  if (&accessor != commCountermeasureSet_Accessor.get()) {
    commCountermeasureSet_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::Link16MetadataType& Link16MetadataType::setCommCountermeasureSet(const uci::type::CommCountermeasureSetEnum::EnumerationItem value) {
  enableCommCountermeasureSet().setValue(value);
  return *this;
}

bool Link16MetadataType::hasCommCountermeasureSet() const noexcept {
  return static_cast<bool>(commCountermeasureSet_Accessor);
}

uci::type::CommCountermeasureSetEnum& Link16MetadataType::enableCommCountermeasureSet(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commCountermeasureSetEnum : type};
  if ((!commCountermeasureSet_Accessor) || (commCountermeasureSet_Accessor->getAccessorType() != requestedType)) {
    commCountermeasureSet_Accessor = CommCountermeasureSetEnum::create(requestedType);
    if (!commCountermeasureSet_Accessor) {
      throw uci::base::UCIException("Error in enableCommCountermeasureSet(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *commCountermeasureSet_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearCommCountermeasureSet() noexcept {
  commCountermeasureSet_Accessor.reset();
  return *this;
}

uci::type::Link16ActiveRelayIndicatorsType& Link16MetadataType::getActiveRelayIndicators_() const {
  if (activeRelayIndicators_Accessor) {
    return *activeRelayIndicators_Accessor;
  }
  throw uci::base::UCIException("Error in getActiveRelayIndicators(): An attempt was made to get an optional field that was not enabled, call hasActiveRelayIndicators() to determine if it is safe to call getActiveRelayIndicators()");
}

const uci::type::Link16ActiveRelayIndicatorsType& Link16MetadataType::getActiveRelayIndicators() const {
  return getActiveRelayIndicators_();
}

uci::type::Link16ActiveRelayIndicatorsType& Link16MetadataType::getActiveRelayIndicators() {
  return getActiveRelayIndicators_();
}

uci::type::Link16MetadataType& Link16MetadataType::setActiveRelayIndicators(const uci::type::Link16ActiveRelayIndicatorsType& accessor) {
  enableActiveRelayIndicators();
  if (&accessor != activeRelayIndicators_Accessor.get()) {
    activeRelayIndicators_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Link16MetadataType::hasActiveRelayIndicators() const noexcept {
  return static_cast<bool>(activeRelayIndicators_Accessor);
}

uci::type::Link16ActiveRelayIndicatorsType& Link16MetadataType::enableActiveRelayIndicators(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::link16ActiveRelayIndicatorsType : type};
  if ((!activeRelayIndicators_Accessor) || (activeRelayIndicators_Accessor->getAccessorType() != requestedType)) {
    activeRelayIndicators_Accessor = Link16ActiveRelayIndicatorsType::create(requestedType);
    if (!activeRelayIndicators_Accessor) {
      throw uci::base::UCIException("Error in enableActiveRelayIndicators(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *activeRelayIndicators_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearActiveRelayIndicators() noexcept {
  activeRelayIndicators_Accessor.reset();
  return *this;
}

uci::type::TrackNumberOrEntityType& Link16MetadataType::getMissionCommander_() const {
  if (missionCommander_Accessor) {
    return *missionCommander_Accessor;
  }
  throw uci::base::UCIException("Error in getMissionCommander(): An attempt was made to get an optional field that was not enabled, call hasMissionCommander() to determine if it is safe to call getMissionCommander()");
}

const uci::type::TrackNumberOrEntityType& Link16MetadataType::getMissionCommander() const {
  return getMissionCommander_();
}

uci::type::TrackNumberOrEntityType& Link16MetadataType::getMissionCommander() {
  return getMissionCommander_();
}

uci::type::Link16MetadataType& Link16MetadataType::setMissionCommander(const uci::type::TrackNumberOrEntityType& accessor) {
  enableMissionCommander();
  if (&accessor != missionCommander_Accessor.get()) {
    missionCommander_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool Link16MetadataType::hasMissionCommander() const noexcept {
  return static_cast<bool>(missionCommander_Accessor);
}

uci::type::TrackNumberOrEntityType& Link16MetadataType::enableMissionCommander(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::trackNumberOrEntityType : type};
  if ((!missionCommander_Accessor) || (missionCommander_Accessor->getAccessorType() != requestedType)) {
    missionCommander_Accessor = TrackNumberOrEntityType::create(requestedType);
    if (!missionCommander_Accessor) {
      throw uci::base::UCIException("Error in enableMissionCommander(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *missionCommander_Accessor;
}

uci::type::Link16MetadataType& Link16MetadataType::clearMissionCommander() noexcept {
  missionCommander_Accessor.reset();
  return *this;
}

std::unique_ptr<Link16MetadataType> Link16MetadataType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::link16MetadataType : type};
  return (requestedType == uci::type::accessorType::link16MetadataType) ? boost::make_unique<Link16MetadataType>() : nullptr;
}

/**  */
namespace Link16MetadataType_Names {

constexpr const char* Extern_Type_Name{"Link16MetadataType"};
constexpr const char* NetworkLinkID_Name{"NetworkLinkID"};
constexpr const char* SourceTrack_Name{"SourceTrack"};
constexpr const char* ReportingSystemID_Name{"ReportingSystemID"};
constexpr const char* Airborne_Name{"Airborne"};
constexpr const char* ControlChannel_Name{"ControlChannel"};
constexpr const char* FlightLeadIndicator_Name{"FlightLeadIndicator"};
constexpr const char* FlightLead_Name{"FlightLead"};
constexpr const char* GenericUnitType_Name{"GenericUnitType"};
constexpr const char* MissionCommanderIndicator_Name{"MissionCommanderIndicator"};
constexpr const char* PrecisionTime_Name{"PrecisionTime"};
constexpr const char* PositionTimeQuality_Name{"PositionTimeQuality"};
constexpr const char* Site_Name{"Site"};
constexpr const char* OperationalCapability_Name{"OperationalCapability"};
constexpr const char* Link16_Status_Name{"Link16_Status"};
constexpr const char* ReconnaissanceStatus_Name{"ReconnaissanceStatus"};
constexpr const char* NetworkParticipationStatusIndicator_Name{"NetworkParticipationStatusIndicator"};
constexpr const char* RadarChannelIndicator_Name{"RadarChannelIndicator"};
constexpr const char* RadarChannel_Name{"RadarChannel"};
constexpr const char* MissileChannel_Name{"MissileChannel"};
constexpr const char* DefensiveJammerSystemInfo_Name{"DefensiveJammerSystemInfo"};
constexpr const char* JammerStation_Name{"JammerStation"};
constexpr const char* CommCountermeasureSet_Name{"CommCountermeasureSet"};
constexpr const char* ActiveRelayIndicators_Name{"ActiveRelayIndicators"};
constexpr const char* MissionCommander_Name{"MissionCommander"};

} // namespace Link16MetadataType_Names

void Link16MetadataType::deserialize(const boost::property_tree::ptree& propTree, uci::type::Link16MetadataType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = Link16MetadataType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::NetworkLinkID_Name) {
      NetworkLinkID_Type::deserialize(valueType.second, accessor.enableNetworkLinkID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::SourceTrack_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setSourceTrack(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::ReportingSystemID_Name) {
      SystemID_Type::deserialize(valueType.second, accessor.enableReportingSystemID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::Airborne_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAirborne(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::ControlChannel_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setControlChannel(asb_uci::util::SerializationHelpers::deserializeUnsignedByte(*value));
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::FlightLeadIndicator_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFlightLeadIndicator(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::FlightLead_Name) {
      TrackNumberOrEntityType::deserialize(valueType.second, accessor.enableFlightLead(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::GenericUnitType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableGenericUnitType().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::MissionCommanderIndicator_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMissionCommanderIndicator(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::PrecisionTime_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPrecisionTime(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::PositionTimeQuality_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enablePositionTimeQuality().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::Site_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableSite().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::OperationalCapability_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableOperationalCapability().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::Link16_Status_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableLink16_Status().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::ReconnaissanceStatus_Name) {
      ReconnaissanceStatusType::deserialize(valueType.second, accessor.enableReconnaissanceStatus(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::NetworkParticipationStatusIndicator_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableNetworkParticipationStatusIndicator().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::RadarChannelIndicator_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableRadarChannelIndicator().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::RadarChannel_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setRadarChannel(asb_uci::util::SerializationHelpers::deserializeUnsignedByte(*value));
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::MissileChannel_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMissileChannel(asb_uci::util::SerializationHelpers::deserializeUnsignedByte(*value));
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::DefensiveJammerSystemInfo_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::Link16MetadataType::DefensiveJammerSystemInfo& boundedList = accessor.getDefensiveJammerSystemInfo();
        const uci::type::Link16MetadataType::DefensiveJammerSystemInfo::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::DefensiveJammerSystemInfoType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::JammerStation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::Link16MetadataType::JammerStation& boundedList = accessor.getJammerStation();
        const uci::type::Link16MetadataType::JammerStation::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::JammerStationType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::CommCountermeasureSet_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableCommCountermeasureSet().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::ActiveRelayIndicators_Name) {
      Link16ActiveRelayIndicatorsType::deserialize(valueType.second, accessor.enableActiveRelayIndicators(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + Link16MetadataType_Names::MissionCommander_Name) {
      TrackNumberOrEntityType::deserialize(valueType.second, accessor.enableMissionCommander(), nodeName, nsPrefix);
    }
  }
}

std::string Link16MetadataType::serialize(const uci::type::Link16MetadataType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? Link16MetadataType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, Link16MetadataType_Names::Extern_Type_Name);
  }
  if (accessor.hasNetworkLinkID()) {
    NetworkLinkID_Type::serialize(accessor.getNetworkLinkID(), node, Link16MetadataType_Names::NetworkLinkID_Name);
  }
  if (accessor.hasSourceTrack()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getSourceTrack(), node, Link16MetadataType_Names::SourceTrack_Name);
  }
  if (accessor.hasReportingSystemID()) {
    SystemID_Type::serialize(accessor.getReportingSystemID(), node, Link16MetadataType_Names::ReportingSystemID_Name);
  }
  if (accessor.hasAirborne()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getAirborne(), node, Link16MetadataType_Names::Airborne_Name);
  }
  if (accessor.hasControlChannel()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedByte(accessor.getControlChannel(), node, Link16MetadataType_Names::ControlChannel_Name);
  }
  if (accessor.hasFlightLeadIndicator()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getFlightLeadIndicator(), node, Link16MetadataType_Names::FlightLeadIndicator_Name);
  }
  if (accessor.hasFlightLead()) {
    TrackNumberOrEntityType::serialize(accessor.getFlightLead(), node, Link16MetadataType_Names::FlightLead_Name);
  }
  if (accessor.hasGenericUnitType()) {
    GenericUnitTypeEnum::serialize(accessor.getGenericUnitType(), node, Link16MetadataType_Names::GenericUnitType_Name, false);
  }
  if (accessor.hasMissionCommanderIndicator()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getMissionCommanderIndicator(), node, Link16MetadataType_Names::MissionCommanderIndicator_Name);
  }
  if (accessor.hasPrecisionTime()) {
    asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getPrecisionTime(), node, Link16MetadataType_Names::PrecisionTime_Name);
  }
  if (accessor.hasPositionTimeQuality()) {
    PositionTimeQualityEnum::serialize(accessor.getPositionTimeQuality(), node, Link16MetadataType_Names::PositionTimeQuality_Name, false);
  }
  if (accessor.hasSite()) {
    SiteEnum::serialize(accessor.getSite(), node, Link16MetadataType_Names::Site_Name, false);
  }
  if (accessor.hasOperationalCapability()) {
    OperationalCapabilityEnum::serialize(accessor.getOperationalCapability(), node, Link16MetadataType_Names::OperationalCapability_Name, false);
  }
  if (accessor.hasLink16_Status()) {
    ConnectionStatusEnum::serialize(accessor.getLink16_Status(), node, Link16MetadataType_Names::Link16_Status_Name, false);
  }
  if (accessor.hasReconnaissanceStatus()) {
    ReconnaissanceStatusType::serialize(accessor.getReconnaissanceStatus(), node, Link16MetadataType_Names::ReconnaissanceStatus_Name);
  }
  if (accessor.hasNetworkParticipationStatusIndicator()) {
    NPSI_Enum::serialize(accessor.getNetworkParticipationStatusIndicator(), node, Link16MetadataType_Names::NetworkParticipationStatusIndicator_Name, false);
  }
  if (accessor.hasRadarChannelIndicator()) {
    RadarChannelIndicatorEnum::serialize(accessor.getRadarChannelIndicator(), node, Link16MetadataType_Names::RadarChannelIndicator_Name, false);
  }
  if (accessor.hasRadarChannel()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedByte(accessor.getRadarChannel(), node, Link16MetadataType_Names::RadarChannel_Name);
  }
  if (accessor.hasMissileChannel()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedByte(accessor.getMissileChannel(), node, Link16MetadataType_Names::MissileChannel_Name);
  }
  {
    const uci::type::Link16MetadataType::DefensiveJammerSystemInfo& boundedList = accessor.getDefensiveJammerSystemInfo();
    for (uci::type::Link16MetadataType::DefensiveJammerSystemInfo::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::DefensiveJammerSystemInfoType::serialize(boundedList.at(i), node, Link16MetadataType_Names::DefensiveJammerSystemInfo_Name);
    }
  }
  {
    const uci::type::Link16MetadataType::JammerStation& boundedList = accessor.getJammerStation();
    for (uci::type::Link16MetadataType::JammerStation::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::JammerStationType::serialize(boundedList.at(i), node, Link16MetadataType_Names::JammerStation_Name);
    }
  }
  if (accessor.hasCommCountermeasureSet()) {
    CommCountermeasureSetEnum::serialize(accessor.getCommCountermeasureSet(), node, Link16MetadataType_Names::CommCountermeasureSet_Name, false);
  }
  if (accessor.hasActiveRelayIndicators()) {
    Link16ActiveRelayIndicatorsType::serialize(accessor.getActiveRelayIndicators(), node, Link16MetadataType_Names::ActiveRelayIndicators_Name);
  }
  if (accessor.hasMissionCommander()) {
    TrackNumberOrEntityType::serialize(accessor.getMissionCommander(), node, Link16MetadataType_Names::MissionCommander_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::Link16MetadataType& Link16MetadataType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::Link16MetadataType>().release());
}

uci::type::Link16MetadataType& Link16MetadataType::create(const uci::type::Link16MetadataType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::Link16MetadataType> newAccessor{boost::make_unique<asb_uci::type::Link16MetadataType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void Link16MetadataType::destroy(uci::type::Link16MetadataType& accessor) {
  delete dynamic_cast<asb_uci::type::Link16MetadataType*>(&accessor);
}

} // namespace type

} // namespace uci

