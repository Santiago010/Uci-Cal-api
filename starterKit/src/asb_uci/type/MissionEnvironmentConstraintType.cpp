/** @file MissionEnvironmentConstraintType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/MissionEnvironmentConstraintType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/ConstrainedEntityType.h"
#include "../../../include/asb_uci/type/ConstrainedOpLineType.h"
#include "../../../include/asb_uci/type/ConstrainedOpPointType.h"
#include "../../../include/asb_uci/type/ConstrainedOpVolumeType.h"
#include "../../../include/asb_uci/type/ConstrainedOpZoneType.h"
#include "../../../include/asb_uci/type/ParameterAssertType.h"
#include "../../../include/asb_uci/type/RequirementRiskAdjustmentType.h"
#include "../../../include/asb_uci/type/SystemStatusMDT.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ConstrainedEntityType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ConstrainedOpLineType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ConstrainedOpPointType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ConstrainedOpVolumeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ConstrainedOpZoneType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MissionEnvironmentConstraintType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ParameterAssertType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/RequirementRiskAdjustmentType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SystemStatusMDT.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

MissionEnvironmentConstraintType::MissionEnvironmentConstraintType() = default;

MissionEnvironmentConstraintType::~MissionEnvironmentConstraintType() = default;

void MissionEnvironmentConstraintType::copy(const uci::type::MissionEnvironmentConstraintType& accessor) {
  copyImpl(accessor, false);
}

void MissionEnvironmentConstraintType::copyImpl(const uci::type::MissionEnvironmentConstraintType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const MissionEnvironmentConstraintType&>(accessor);
    if (accessorImpl.constrainedEntity_Accessor) {
      setConstrainedEntity(*(accessorImpl.constrainedEntity_Accessor));
    } else {
      constrainedEntity_Accessor.reset();
    }
    if (accessorImpl.constrainedOpPoint_Accessor) {
      setConstrainedOpPoint(*(accessorImpl.constrainedOpPoint_Accessor));
    } else {
      constrainedOpPoint_Accessor.reset();
    }
    if (accessorImpl.constrainedOpLine_Accessor) {
      setConstrainedOpLine(*(accessorImpl.constrainedOpLine_Accessor));
    } else {
      constrainedOpLine_Accessor.reset();
    }
    if (accessorImpl.constrainedOpZone_Accessor) {
      setConstrainedOpZone(*(accessorImpl.constrainedOpZone_Accessor));
    } else {
      constrainedOpZone_Accessor.reset();
    }
    if (accessorImpl.constrainedOpVolume_Accessor) {
      setConstrainedOpVolume(*(accessorImpl.constrainedOpVolume_Accessor));
    } else {
      constrainedOpVolume_Accessor.reset();
    }
    if (accessorImpl.system_Accessor) {
      setSystem(*(accessorImpl.system_Accessor));
    } else {
      system_Accessor.reset();
    }
    if (accessorImpl.riskAdjustment_Accessor) {
      setRiskAdjustment(*(accessorImpl.riskAdjustment_Accessor));
    } else {
      riskAdjustment_Accessor.reset();
    }
    if (accessorImpl.parameter_Accessor) {
      setParameter(*(accessorImpl.parameter_Accessor));
    } else {
      parameter_Accessor.reset();
    }
  }
}

void MissionEnvironmentConstraintType::reset() noexcept {
  constrainedEntity_Accessor.reset();
  constrainedOpPoint_Accessor.reset();
  constrainedOpLine_Accessor.reset();
  constrainedOpZone_Accessor.reset();
  constrainedOpVolume_Accessor.reset();
  system_Accessor.reset();
  riskAdjustment_Accessor.reset();
  parameter_Accessor.reset();
}

uci::type::MissionEnvironmentConstraintType::MissionEnvironmentConstraintTypeChoice MissionEnvironmentConstraintType::getMissionEnvironmentConstraintTypeChoiceOrdinal() const noexcept {
  if (constrainedEntity_Accessor) {
    return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDENTITY;
  }
  if (constrainedOpPoint_Accessor) {
    return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDOPPOINT;
  }
  if (constrainedOpLine_Accessor) {
    return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDOPLINE;
  }
  if (constrainedOpZone_Accessor) {
    return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDOPZONE;
  }
  if (constrainedOpVolume_Accessor) {
    return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDOPVOLUME;
  }
  if (system_Accessor) {
    return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_SYSTEM;
  }
  if (riskAdjustment_Accessor) {
    return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_RISKADJUSTMENT;
  }
  if (parameter_Accessor) {
    return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_PARAMETER;
  }
  return MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_NONE;
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setMissionEnvironmentConstraintTypeChoiceOrdinal(uci::type::MissionEnvironmentConstraintType::MissionEnvironmentConstraintTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDENTITY:
      chooseConstrainedEntity("setMissionEnvironmentConstraintTypeChoiceOrdinal", type);
      break;
    case MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDOPPOINT:
      chooseConstrainedOpPoint("setMissionEnvironmentConstraintTypeChoiceOrdinal", type);
      break;
    case MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDOPLINE:
      chooseConstrainedOpLine("setMissionEnvironmentConstraintTypeChoiceOrdinal", type);
      break;
    case MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDOPZONE:
      chooseConstrainedOpZone("setMissionEnvironmentConstraintTypeChoiceOrdinal", type);
      break;
    case MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_CONSTRAINEDOPVOLUME:
      chooseConstrainedOpVolume("setMissionEnvironmentConstraintTypeChoiceOrdinal", type);
      break;
    case MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_SYSTEM:
      chooseSystem("setMissionEnvironmentConstraintTypeChoiceOrdinal", type);
      break;
    case MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_RISKADJUSTMENT:
      chooseRiskAdjustment("setMissionEnvironmentConstraintTypeChoiceOrdinal", type);
      break;
    case MISSIONENVIRONMENTCONSTRAINTTYPE_CHOICE_PARAMETER:
      chooseParameter("setMissionEnvironmentConstraintTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setMissionEnvironmentConstraintTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::ConstrainedEntityType& MissionEnvironmentConstraintType::getConstrainedEntity_() const {
  if (constrainedEntity_Accessor) {
    return *constrainedEntity_Accessor;
  }
  throw uci::base::UCIException("Error in getConstrainedEntity(): Unable to get ConstrainedEntity, field not selected");
}

const uci::type::ConstrainedEntityType& MissionEnvironmentConstraintType::getConstrainedEntity() const {
  return getConstrainedEntity_();
}

uci::type::ConstrainedEntityType& MissionEnvironmentConstraintType::getConstrainedEntity() {
  return getConstrainedEntity_();
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setConstrainedEntity(const uci::type::ConstrainedEntityType& accessor) {
  chooseConstrainedEntity();
  if (&accessor != constrainedEntity_Accessor.get()) {
    constrainedEntity_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionEnvironmentConstraintType::isConstrainedEntity() const noexcept {
  return static_cast<bool>(constrainedEntity_Accessor);
}

uci::type::ConstrainedEntityType& MissionEnvironmentConstraintType::chooseConstrainedEntity(const std::string& method, uci::base::accessorType::AccessorType type) {
  constrainedOpPoint_Accessor.reset();
  constrainedOpLine_Accessor.reset();
  constrainedOpZone_Accessor.reset();
  constrainedOpVolume_Accessor.reset();
  system_Accessor.reset();
  riskAdjustment_Accessor.reset();
  parameter_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::constrainedEntityType : type};
  if ((!constrainedEntity_Accessor) || (constrainedEntity_Accessor->getAccessorType() != requestedType)) {
    constrainedEntity_Accessor = ConstrainedEntityType::create(type);
    if (!constrainedEntity_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *constrainedEntity_Accessor;
}

uci::type::ConstrainedEntityType& MissionEnvironmentConstraintType::chooseConstrainedEntity(uci::base::accessorType::AccessorType type) {
  return chooseConstrainedEntity("chooseConstrainedEntity", type);
}

uci::type::ConstrainedOpPointType& MissionEnvironmentConstraintType::getConstrainedOpPoint_() const {
  if (constrainedOpPoint_Accessor) {
    return *constrainedOpPoint_Accessor;
  }
  throw uci::base::UCIException("Error in getConstrainedOpPoint(): Unable to get ConstrainedOpPoint, field not selected");
}

const uci::type::ConstrainedOpPointType& MissionEnvironmentConstraintType::getConstrainedOpPoint() const {
  return getConstrainedOpPoint_();
}

uci::type::ConstrainedOpPointType& MissionEnvironmentConstraintType::getConstrainedOpPoint() {
  return getConstrainedOpPoint_();
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setConstrainedOpPoint(const uci::type::ConstrainedOpPointType& accessor) {
  chooseConstrainedOpPoint();
  if (&accessor != constrainedOpPoint_Accessor.get()) {
    constrainedOpPoint_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionEnvironmentConstraintType::isConstrainedOpPoint() const noexcept {
  return static_cast<bool>(constrainedOpPoint_Accessor);
}

uci::type::ConstrainedOpPointType& MissionEnvironmentConstraintType::chooseConstrainedOpPoint(const std::string& method, uci::base::accessorType::AccessorType type) {
  constrainedEntity_Accessor.reset();
  constrainedOpLine_Accessor.reset();
  constrainedOpZone_Accessor.reset();
  constrainedOpVolume_Accessor.reset();
  system_Accessor.reset();
  riskAdjustment_Accessor.reset();
  parameter_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::constrainedOpPointType : type};
  if ((!constrainedOpPoint_Accessor) || (constrainedOpPoint_Accessor->getAccessorType() != requestedType)) {
    constrainedOpPoint_Accessor = ConstrainedOpPointType::create(type);
    if (!constrainedOpPoint_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *constrainedOpPoint_Accessor;
}

uci::type::ConstrainedOpPointType& MissionEnvironmentConstraintType::chooseConstrainedOpPoint(uci::base::accessorType::AccessorType type) {
  return chooseConstrainedOpPoint("chooseConstrainedOpPoint", type);
}

uci::type::ConstrainedOpLineType& MissionEnvironmentConstraintType::getConstrainedOpLine_() const {
  if (constrainedOpLine_Accessor) {
    return *constrainedOpLine_Accessor;
  }
  throw uci::base::UCIException("Error in getConstrainedOpLine(): Unable to get ConstrainedOpLine, field not selected");
}

const uci::type::ConstrainedOpLineType& MissionEnvironmentConstraintType::getConstrainedOpLine() const {
  return getConstrainedOpLine_();
}

uci::type::ConstrainedOpLineType& MissionEnvironmentConstraintType::getConstrainedOpLine() {
  return getConstrainedOpLine_();
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setConstrainedOpLine(const uci::type::ConstrainedOpLineType& accessor) {
  chooseConstrainedOpLine();
  if (&accessor != constrainedOpLine_Accessor.get()) {
    constrainedOpLine_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionEnvironmentConstraintType::isConstrainedOpLine() const noexcept {
  return static_cast<bool>(constrainedOpLine_Accessor);
}

uci::type::ConstrainedOpLineType& MissionEnvironmentConstraintType::chooseConstrainedOpLine(const std::string& method, uci::base::accessorType::AccessorType type) {
  constrainedEntity_Accessor.reset();
  constrainedOpPoint_Accessor.reset();
  constrainedOpZone_Accessor.reset();
  constrainedOpVolume_Accessor.reset();
  system_Accessor.reset();
  riskAdjustment_Accessor.reset();
  parameter_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::constrainedOpLineType : type};
  if ((!constrainedOpLine_Accessor) || (constrainedOpLine_Accessor->getAccessorType() != requestedType)) {
    constrainedOpLine_Accessor = ConstrainedOpLineType::create(type);
    if (!constrainedOpLine_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *constrainedOpLine_Accessor;
}

uci::type::ConstrainedOpLineType& MissionEnvironmentConstraintType::chooseConstrainedOpLine(uci::base::accessorType::AccessorType type) {
  return chooseConstrainedOpLine("chooseConstrainedOpLine", type);
}

uci::type::ConstrainedOpZoneType& MissionEnvironmentConstraintType::getConstrainedOpZone_() const {
  if (constrainedOpZone_Accessor) {
    return *constrainedOpZone_Accessor;
  }
  throw uci::base::UCIException("Error in getConstrainedOpZone(): Unable to get ConstrainedOpZone, field not selected");
}

const uci::type::ConstrainedOpZoneType& MissionEnvironmentConstraintType::getConstrainedOpZone() const {
  return getConstrainedOpZone_();
}

uci::type::ConstrainedOpZoneType& MissionEnvironmentConstraintType::getConstrainedOpZone() {
  return getConstrainedOpZone_();
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setConstrainedOpZone(const uci::type::ConstrainedOpZoneType& accessor) {
  chooseConstrainedOpZone();
  if (&accessor != constrainedOpZone_Accessor.get()) {
    constrainedOpZone_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionEnvironmentConstraintType::isConstrainedOpZone() const noexcept {
  return static_cast<bool>(constrainedOpZone_Accessor);
}

uci::type::ConstrainedOpZoneType& MissionEnvironmentConstraintType::chooseConstrainedOpZone(const std::string& method, uci::base::accessorType::AccessorType type) {
  constrainedEntity_Accessor.reset();
  constrainedOpPoint_Accessor.reset();
  constrainedOpLine_Accessor.reset();
  constrainedOpVolume_Accessor.reset();
  system_Accessor.reset();
  riskAdjustment_Accessor.reset();
  parameter_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::constrainedOpZoneType : type};
  if ((!constrainedOpZone_Accessor) || (constrainedOpZone_Accessor->getAccessorType() != requestedType)) {
    constrainedOpZone_Accessor = ConstrainedOpZoneType::create(type);
    if (!constrainedOpZone_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *constrainedOpZone_Accessor;
}

uci::type::ConstrainedOpZoneType& MissionEnvironmentConstraintType::chooseConstrainedOpZone(uci::base::accessorType::AccessorType type) {
  return chooseConstrainedOpZone("chooseConstrainedOpZone", type);
}

uci::type::ConstrainedOpVolumeType& MissionEnvironmentConstraintType::getConstrainedOpVolume_() const {
  if (constrainedOpVolume_Accessor) {
    return *constrainedOpVolume_Accessor;
  }
  throw uci::base::UCIException("Error in getConstrainedOpVolume(): Unable to get ConstrainedOpVolume, field not selected");
}

const uci::type::ConstrainedOpVolumeType& MissionEnvironmentConstraintType::getConstrainedOpVolume() const {
  return getConstrainedOpVolume_();
}

uci::type::ConstrainedOpVolumeType& MissionEnvironmentConstraintType::getConstrainedOpVolume() {
  return getConstrainedOpVolume_();
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setConstrainedOpVolume(const uci::type::ConstrainedOpVolumeType& accessor) {
  chooseConstrainedOpVolume();
  if (&accessor != constrainedOpVolume_Accessor.get()) {
    constrainedOpVolume_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionEnvironmentConstraintType::isConstrainedOpVolume() const noexcept {
  return static_cast<bool>(constrainedOpVolume_Accessor);
}

uci::type::ConstrainedOpVolumeType& MissionEnvironmentConstraintType::chooseConstrainedOpVolume(const std::string& method, uci::base::accessorType::AccessorType type) {
  constrainedEntity_Accessor.reset();
  constrainedOpPoint_Accessor.reset();
  constrainedOpLine_Accessor.reset();
  constrainedOpZone_Accessor.reset();
  system_Accessor.reset();
  riskAdjustment_Accessor.reset();
  parameter_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::constrainedOpVolumeType : type};
  if ((!constrainedOpVolume_Accessor) || (constrainedOpVolume_Accessor->getAccessorType() != requestedType)) {
    constrainedOpVolume_Accessor = ConstrainedOpVolumeType::create(type);
    if (!constrainedOpVolume_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *constrainedOpVolume_Accessor;
}

uci::type::ConstrainedOpVolumeType& MissionEnvironmentConstraintType::chooseConstrainedOpVolume(uci::base::accessorType::AccessorType type) {
  return chooseConstrainedOpVolume("chooseConstrainedOpVolume", type);
}

uci::type::SystemStatusMDT& MissionEnvironmentConstraintType::getSystem_() const {
  if (system_Accessor) {
    return *system_Accessor;
  }
  throw uci::base::UCIException("Error in getSystem(): Unable to get System, field not selected");
}

const uci::type::SystemStatusMDT& MissionEnvironmentConstraintType::getSystem() const {
  return getSystem_();
}

uci::type::SystemStatusMDT& MissionEnvironmentConstraintType::getSystem() {
  return getSystem_();
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setSystem(const uci::type::SystemStatusMDT& accessor) {
  chooseSystem();
  if (&accessor != system_Accessor.get()) {
    system_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionEnvironmentConstraintType::isSystem() const noexcept {
  return static_cast<bool>(system_Accessor);
}

uci::type::SystemStatusMDT& MissionEnvironmentConstraintType::chooseSystem(const std::string& method, uci::base::accessorType::AccessorType type) {
  constrainedEntity_Accessor.reset();
  constrainedOpPoint_Accessor.reset();
  constrainedOpLine_Accessor.reset();
  constrainedOpZone_Accessor.reset();
  constrainedOpVolume_Accessor.reset();
  riskAdjustment_Accessor.reset();
  parameter_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::systemStatusMDT : type};
  if ((!system_Accessor) || (system_Accessor->getAccessorType() != requestedType)) {
    system_Accessor = SystemStatusMDT::create(type);
    if (!system_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *system_Accessor;
}

uci::type::SystemStatusMDT& MissionEnvironmentConstraintType::chooseSystem(uci::base::accessorType::AccessorType type) {
  return chooseSystem("chooseSystem", type);
}

uci::type::RequirementRiskAdjustmentType& MissionEnvironmentConstraintType::getRiskAdjustment_() const {
  if (riskAdjustment_Accessor) {
    return *riskAdjustment_Accessor;
  }
  throw uci::base::UCIException("Error in getRiskAdjustment(): Unable to get RiskAdjustment, field not selected");
}

const uci::type::RequirementRiskAdjustmentType& MissionEnvironmentConstraintType::getRiskAdjustment() const {
  return getRiskAdjustment_();
}

uci::type::RequirementRiskAdjustmentType& MissionEnvironmentConstraintType::getRiskAdjustment() {
  return getRiskAdjustment_();
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setRiskAdjustment(const uci::type::RequirementRiskAdjustmentType& accessor) {
  chooseRiskAdjustment();
  if (&accessor != riskAdjustment_Accessor.get()) {
    riskAdjustment_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionEnvironmentConstraintType::isRiskAdjustment() const noexcept {
  return static_cast<bool>(riskAdjustment_Accessor);
}

uci::type::RequirementRiskAdjustmentType& MissionEnvironmentConstraintType::chooseRiskAdjustment(const std::string& method, uci::base::accessorType::AccessorType type) {
  constrainedEntity_Accessor.reset();
  constrainedOpPoint_Accessor.reset();
  constrainedOpLine_Accessor.reset();
  constrainedOpZone_Accessor.reset();
  constrainedOpVolume_Accessor.reset();
  system_Accessor.reset();
  parameter_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::requirementRiskAdjustmentType : type};
  if ((!riskAdjustment_Accessor) || (riskAdjustment_Accessor->getAccessorType() != requestedType)) {
    riskAdjustment_Accessor = RequirementRiskAdjustmentType::create(type);
    if (!riskAdjustment_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *riskAdjustment_Accessor;
}

uci::type::RequirementRiskAdjustmentType& MissionEnvironmentConstraintType::chooseRiskAdjustment(uci::base::accessorType::AccessorType type) {
  return chooseRiskAdjustment("chooseRiskAdjustment", type);
}

uci::type::ParameterAssertType& MissionEnvironmentConstraintType::getParameter_() const {
  if (parameter_Accessor) {
    return *parameter_Accessor;
  }
  throw uci::base::UCIException("Error in getParameter(): Unable to get Parameter, field not selected");
}

const uci::type::ParameterAssertType& MissionEnvironmentConstraintType::getParameter() const {
  return getParameter_();
}

uci::type::ParameterAssertType& MissionEnvironmentConstraintType::getParameter() {
  return getParameter_();
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::setParameter(const uci::type::ParameterAssertType& accessor) {
  chooseParameter();
  if (&accessor != parameter_Accessor.get()) {
    parameter_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MissionEnvironmentConstraintType::isParameter() const noexcept {
  return static_cast<bool>(parameter_Accessor);
}

uci::type::ParameterAssertType& MissionEnvironmentConstraintType::chooseParameter(const std::string& method, uci::base::accessorType::AccessorType type) {
  constrainedEntity_Accessor.reset();
  constrainedOpPoint_Accessor.reset();
  constrainedOpLine_Accessor.reset();
  constrainedOpZone_Accessor.reset();
  constrainedOpVolume_Accessor.reset();
  system_Accessor.reset();
  riskAdjustment_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::parameterAssertType : type};
  if ((!parameter_Accessor) || (parameter_Accessor->getAccessorType() != requestedType)) {
    parameter_Accessor = ParameterAssertType::create(type);
    if (!parameter_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *parameter_Accessor;
}

uci::type::ParameterAssertType& MissionEnvironmentConstraintType::chooseParameter(uci::base::accessorType::AccessorType type) {
  return chooseParameter("chooseParameter", type);
}

std::unique_ptr<MissionEnvironmentConstraintType> MissionEnvironmentConstraintType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::missionEnvironmentConstraintType : type};
  return (requestedType == uci::type::accessorType::missionEnvironmentConstraintType) ? boost::make_unique<MissionEnvironmentConstraintType>() : nullptr;
}

/**  */
namespace MissionEnvironmentConstraintType_Names {

constexpr const char* Extern_Type_Name{"MissionEnvironmentConstraintType"};
constexpr const char* ConstrainedEntity_Name{"ConstrainedEntity"};
constexpr const char* ConstrainedOpPoint_Name{"ConstrainedOpPoint"};
constexpr const char* ConstrainedOpLine_Name{"ConstrainedOpLine"};
constexpr const char* ConstrainedOpZone_Name{"ConstrainedOpZone"};
constexpr const char* ConstrainedOpVolume_Name{"ConstrainedOpVolume"};
constexpr const char* System_Name{"System"};
constexpr const char* RiskAdjustment_Name{"RiskAdjustment"};
constexpr const char* Parameter_Name{"Parameter"};

} // namespace MissionEnvironmentConstraintType_Names

void MissionEnvironmentConstraintType::deserialize(const boost::property_tree::ptree& propTree, uci::type::MissionEnvironmentConstraintType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = MissionEnvironmentConstraintType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + MissionEnvironmentConstraintType_Names::ConstrainedEntity_Name) {
      ConstrainedEntityType::deserialize(valueType.second, accessor.chooseConstrainedEntity(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionEnvironmentConstraintType_Names::ConstrainedOpPoint_Name) {
      ConstrainedOpPointType::deserialize(valueType.second, accessor.chooseConstrainedOpPoint(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionEnvironmentConstraintType_Names::ConstrainedOpLine_Name) {
      ConstrainedOpLineType::deserialize(valueType.second, accessor.chooseConstrainedOpLine(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionEnvironmentConstraintType_Names::ConstrainedOpZone_Name) {
      ConstrainedOpZoneType::deserialize(valueType.second, accessor.chooseConstrainedOpZone(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionEnvironmentConstraintType_Names::ConstrainedOpVolume_Name) {
      ConstrainedOpVolumeType::deserialize(valueType.second, accessor.chooseConstrainedOpVolume(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionEnvironmentConstraintType_Names::System_Name) {
      SystemStatusMDT::deserialize(valueType.second, accessor.chooseSystem(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionEnvironmentConstraintType_Names::RiskAdjustment_Name) {
      RequirementRiskAdjustmentType::deserialize(valueType.second, accessor.chooseRiskAdjustment(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MissionEnvironmentConstraintType_Names::Parameter_Name) {
      ParameterAssertType::deserialize(valueType.second, accessor.chooseParameter(), nodeName, nsPrefix);
    }
  }
}

std::string MissionEnvironmentConstraintType::serialize(const uci::type::MissionEnvironmentConstraintType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? MissionEnvironmentConstraintType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, MissionEnvironmentConstraintType_Names::Extern_Type_Name);
  }
  if (accessor.isConstrainedEntity()) {
    ConstrainedEntityType::serialize(accessor.getConstrainedEntity(), node, MissionEnvironmentConstraintType_Names::ConstrainedEntity_Name);
  } else if (accessor.isConstrainedOpPoint()) {
    ConstrainedOpPointType::serialize(accessor.getConstrainedOpPoint(), node, MissionEnvironmentConstraintType_Names::ConstrainedOpPoint_Name);
  } else if (accessor.isConstrainedOpLine()) {
    ConstrainedOpLineType::serialize(accessor.getConstrainedOpLine(), node, MissionEnvironmentConstraintType_Names::ConstrainedOpLine_Name);
  } else if (accessor.isConstrainedOpZone()) {
    ConstrainedOpZoneType::serialize(accessor.getConstrainedOpZone(), node, MissionEnvironmentConstraintType_Names::ConstrainedOpZone_Name);
  } else if (accessor.isConstrainedOpVolume()) {
    ConstrainedOpVolumeType::serialize(accessor.getConstrainedOpVolume(), node, MissionEnvironmentConstraintType_Names::ConstrainedOpVolume_Name);
  } else if (accessor.isSystem()) {
    SystemStatusMDT::serialize(accessor.getSystem(), node, MissionEnvironmentConstraintType_Names::System_Name);
  } else if (accessor.isRiskAdjustment()) {
    RequirementRiskAdjustmentType::serialize(accessor.getRiskAdjustment(), node, MissionEnvironmentConstraintType_Names::RiskAdjustment_Name);
  } else if (accessor.isParameter()) {
    ParameterAssertType::serialize(accessor.getParameter(), node, MissionEnvironmentConstraintType_Names::Parameter_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::MissionEnvironmentConstraintType>().release());
}

uci::type::MissionEnvironmentConstraintType& MissionEnvironmentConstraintType::create(const uci::type::MissionEnvironmentConstraintType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::MissionEnvironmentConstraintType> newAccessor{boost::make_unique<asb_uci::type::MissionEnvironmentConstraintType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void MissionEnvironmentConstraintType::destroy(uci::type::MissionEnvironmentConstraintType& accessor) {
  delete dynamic_cast<asb_uci::type::MissionEnvironmentConstraintType*>(&accessor);
}

} // namespace type

} // namespace uci

