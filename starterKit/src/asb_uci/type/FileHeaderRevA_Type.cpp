/** @file FileHeaderRevA_Type.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/FileHeaderRevA_Type.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/CharOrSpacePairsType.h"
#include "asb_uci/type/NITF_CodewordsType.h"
#include "asb_uci/type/NITF_ControlAndHandlingType.h"
#include "asb_uci/type/NITF_DateType.h"
#include "asb_uci/type/NITF_DeclassificationExemptionType.h"
#include "asb_uci/type/NITF_DeclassificationType.h"
#include "asb_uci/type/NITF_ReleasingInstructionsType.h"
#include "asb_uci/type/VisibleLatin1String15Type.h"
#include "asb_uci/type/VisibleLatin1String18Type.h"
#include "asb_uci/type/VisibleLatin1String24Type.h"
#include "asb_uci/type/VisibleLatin1String40Type.h"
#include "asb_uci/type/VisibleLatin1String43Type.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/CharOrSpacePairsType.h"
#include "uci/type/FileHeaderRevA_Type.h"
#include "uci/type/NITF_ClassificationAuthorityType.h"
#include "uci/type/NITF_ClassificationReasonType.h"
#include "uci/type/NITF_CodewordsType.h"
#include "uci/type/NITF_ControlAndHandlingType.h"
#include "uci/type/NITF_DateType.h"
#include "uci/type/NITF_DeclassificationExemptionType.h"
#include "uci/type/NITF_DeclassificationType.h"
#include "uci/type/NITF_DowngradeType.h"
#include "uci/type/NITF_FileSecurityClassificationType.h"
#include "uci/type/NITF_ReleasingInstructionsType.h"
#include "uci/type/VisibleLatin1String15Type.h"
#include "uci/type/VisibleLatin1String18Type.h"
#include "uci/type/VisibleLatin1String24Type.h"
#include "uci/type/VisibleLatin1String40Type.h"
#include "uci/type/VisibleLatin1String43Type.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

FileHeaderRevA_Type::FileHeaderRevA_Type()
  : fileSecurityClassification_Accessor{boost::make_unique<NITF_FileSecurityClassificationType>()} {
}

FileHeaderRevA_Type::~FileHeaderRevA_Type() = default;

void FileHeaderRevA_Type::copy(const uci::type::FileHeaderRevA_Type& accessor) {
  copyImpl(accessor, false);
}

void FileHeaderRevA_Type::copyImpl(const uci::type::FileHeaderRevA_Type& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const FileHeaderRevA_Type&>(accessor);
    setFileSecurityClassification(*(accessorImpl.fileSecurityClassification_Accessor));
    if (accessorImpl.fileClassificationSystem_Accessor) {
      setFileClassificationSystem(*(accessorImpl.fileClassificationSystem_Accessor));
    } else {
      fileClassificationSystem_Accessor.reset();
    }
    if (accessorImpl.fileCodewords_Accessor) {
      setFileCodewords(*(accessorImpl.fileCodewords_Accessor));
    } else {
      fileCodewords_Accessor.reset();
    }
    if (accessorImpl.fileControlAndHandling_Accessor) {
      setFileControlAndHandling(*(accessorImpl.fileControlAndHandling_Accessor));
    } else {
      fileControlAndHandling_Accessor.reset();
    }
    if (accessorImpl.fileReleasingInstructions_Accessor) {
      setFileReleasingInstructions(*(accessorImpl.fileReleasingInstructions_Accessor));
    } else {
      fileReleasingInstructions_Accessor.reset();
    }
    if (accessorImpl.fileDeclassificationType_Accessor) {
      setFileDeclassificationType(*(accessorImpl.fileDeclassificationType_Accessor));
    } else {
      fileDeclassificationType_Accessor.reset();
    }
    if (accessorImpl.fileDeclassificationDate_Accessor) {
      setFileDeclassificationDate(*(accessorImpl.fileDeclassificationDate_Accessor));
    } else {
      fileDeclassificationDate_Accessor.reset();
    }
    if (accessorImpl.fileDeclassificationExemption_Accessor) {
      setFileDeclassificationExemption(*(accessorImpl.fileDeclassificationExemption_Accessor));
    } else {
      fileDeclassificationExemption_Accessor.reset();
    }
    if (accessorImpl.fileDowngrade_Accessor) {
      setFileDowngrade(*(accessorImpl.fileDowngrade_Accessor));
    } else {
      fileDowngrade_Accessor.reset();
    }
    if (accessorImpl.fileDowngradeDate_Accessor) {
      setFileDowngradeDate(*(accessorImpl.fileDowngradeDate_Accessor));
    } else {
      fileDowngradeDate_Accessor.reset();
    }
    if (accessorImpl.fileClassificationText_Accessor) {
      setFileClassificationText(*(accessorImpl.fileClassificationText_Accessor));
    } else {
      fileClassificationText_Accessor.reset();
    }
    if (accessorImpl.fileClassificationAuthorityType_Accessor) {
      setFileClassificationAuthorityType(*(accessorImpl.fileClassificationAuthorityType_Accessor));
    } else {
      fileClassificationAuthorityType_Accessor.reset();
    }
    if (accessorImpl.fileClassificationAuthority_Accessor) {
      setFileClassificationAuthority(*(accessorImpl.fileClassificationAuthority_Accessor));
    } else {
      fileClassificationAuthority_Accessor.reset();
    }
    if (accessorImpl.fileClassificationReason_Accessor) {
      setFileClassificationReason(*(accessorImpl.fileClassificationReason_Accessor));
    } else {
      fileClassificationReason_Accessor.reset();
    }
    if (accessorImpl.fileSecuritySourceDate_Accessor) {
      setFileSecuritySourceDate(*(accessorImpl.fileSecuritySourceDate_Accessor));
    } else {
      fileSecuritySourceDate_Accessor.reset();
    }
    if (accessorImpl.fileSecurityControlNumber_Accessor) {
      setFileSecurityControlNumber(*(accessorImpl.fileSecurityControlNumber_Accessor));
    } else {
      fileSecurityControlNumber_Accessor.reset();
    }
    if (accessorImpl.originatorsName_Accessor) {
      setOriginatorsName(*(accessorImpl.originatorsName_Accessor));
    } else {
      originatorsName_Accessor.reset();
    }
    if (accessorImpl.originatorsPhone_Accessor) {
      setOriginatorsPhone(*(accessorImpl.originatorsPhone_Accessor));
    } else {
      originatorsPhone_Accessor.reset();
    }
  }
}

void FileHeaderRevA_Type::reset() noexcept {
  fileSecurityClassification_Accessor->reset();
  fileClassificationSystem_Accessor.reset();
  fileCodewords_Accessor.reset();
  fileControlAndHandling_Accessor.reset();
  fileReleasingInstructions_Accessor.reset();
  fileDeclassificationType_Accessor.reset();
  fileDeclassificationDate_Accessor.reset();
  fileDeclassificationExemption_Accessor.reset();
  fileDowngrade_Accessor.reset();
  fileDowngradeDate_Accessor.reset();
  fileClassificationText_Accessor.reset();
  fileClassificationAuthorityType_Accessor.reset();
  fileClassificationAuthority_Accessor.reset();
  fileClassificationReason_Accessor.reset();
  fileSecuritySourceDate_Accessor.reset();
  fileSecurityControlNumber_Accessor.reset();
  originatorsName_Accessor.reset();
  originatorsPhone_Accessor.reset();
}

const uci::type::NITF_FileSecurityClassificationType& FileHeaderRevA_Type::getFileSecurityClassification() const noexcept {
  return *fileSecurityClassification_Accessor;
}

uci::type::NITF_FileSecurityClassificationType& FileHeaderRevA_Type::getFileSecurityClassification() noexcept {
  return *fileSecurityClassification_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecurityClassification(const uci::type::NITF_FileSecurityClassificationType& value) {
  return setFileSecurityClassification(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecurityClassification(const std::string& value) {
  return setFileSecurityClassification(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecurityClassification(const char* value) {
  fileSecurityClassification_Accessor->setStringValue(value);
  return *this;
}

uci::type::CharOrSpacePairsType& FileHeaderRevA_Type::getFileClassificationSystem_() const {
  if (fileClassificationSystem_Accessor) {
    return *fileClassificationSystem_Accessor;
  }
  throw uci::base::UCIException("Error in getFileClassificationSystem(): An attempt was made to get an optional field that was not enabled, call hasFileClassificationSystem() to determine if it is safe to call getFileClassificationSystem()");
}

const uci::type::CharOrSpacePairsType& FileHeaderRevA_Type::getFileClassificationSystem() const {
  return getFileClassificationSystem_();
}

uci::type::CharOrSpacePairsType& FileHeaderRevA_Type::getFileClassificationSystem() {
  return getFileClassificationSystem_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationSystem(const uci::type::CharOrSpacePairsType& value) {
  return setFileClassificationSystem(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationSystem(const std::string& value) {
  return setFileClassificationSystem(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationSystem(const char* value) {
  enableFileClassificationSystem().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileClassificationSystem() const noexcept {
  return static_cast<bool>(fileClassificationSystem_Accessor);
}

uci::type::CharOrSpacePairsType& FileHeaderRevA_Type::enableFileClassificationSystem(uci::base::accessorType::AccessorType type) {
  if (!fileClassificationSystem_Accessor) {
    fileClassificationSystem_Accessor = CharOrSpacePairsType::create(type);
  }
  return *fileClassificationSystem_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileClassificationSystem() noexcept {
  fileClassificationSystem_Accessor.reset();
  return *this;
}

uci::type::NITF_CodewordsType& FileHeaderRevA_Type::getFileCodewords_() const {
  if (fileCodewords_Accessor) {
    return *fileCodewords_Accessor;
  }
  throw uci::base::UCIException("Error in getFileCodewords(): An attempt was made to get an optional field that was not enabled, call hasFileCodewords() to determine if it is safe to call getFileCodewords()");
}

const uci::type::NITF_CodewordsType& FileHeaderRevA_Type::getFileCodewords() const {
  return getFileCodewords_();
}

uci::type::NITF_CodewordsType& FileHeaderRevA_Type::getFileCodewords() {
  return getFileCodewords_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileCodewords(const uci::type::NITF_CodewordsType& value) {
  return setFileCodewords(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileCodewords(const std::string& value) {
  return setFileCodewords(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileCodewords(const char* value) {
  enableFileCodewords().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileCodewords() const noexcept {
  return static_cast<bool>(fileCodewords_Accessor);
}

uci::type::NITF_CodewordsType& FileHeaderRevA_Type::enableFileCodewords(uci::base::accessorType::AccessorType type) {
  if (!fileCodewords_Accessor) {
    fileCodewords_Accessor = NITF_CodewordsType::create(type);
  }
  return *fileCodewords_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileCodewords() noexcept {
  fileCodewords_Accessor.reset();
  return *this;
}

uci::type::NITF_ControlAndHandlingType& FileHeaderRevA_Type::getFileControlAndHandling_() const {
  if (fileControlAndHandling_Accessor) {
    return *fileControlAndHandling_Accessor;
  }
  throw uci::base::UCIException("Error in getFileControlAndHandling(): An attempt was made to get an optional field that was not enabled, call hasFileControlAndHandling() to determine if it is safe to call getFileControlAndHandling()");
}

const uci::type::NITF_ControlAndHandlingType& FileHeaderRevA_Type::getFileControlAndHandling() const {
  return getFileControlAndHandling_();
}

uci::type::NITF_ControlAndHandlingType& FileHeaderRevA_Type::getFileControlAndHandling() {
  return getFileControlAndHandling_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileControlAndHandling(const uci::type::NITF_ControlAndHandlingType& value) {
  return setFileControlAndHandling(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileControlAndHandling(const std::string& value) {
  return setFileControlAndHandling(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileControlAndHandling(const char* value) {
  enableFileControlAndHandling().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileControlAndHandling() const noexcept {
  return static_cast<bool>(fileControlAndHandling_Accessor);
}

uci::type::NITF_ControlAndHandlingType& FileHeaderRevA_Type::enableFileControlAndHandling(uci::base::accessorType::AccessorType type) {
  if (!fileControlAndHandling_Accessor) {
    fileControlAndHandling_Accessor = NITF_ControlAndHandlingType::create(type);
  }
  return *fileControlAndHandling_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileControlAndHandling() noexcept {
  fileControlAndHandling_Accessor.reset();
  return *this;
}

uci::type::NITF_ReleasingInstructionsType& FileHeaderRevA_Type::getFileReleasingInstructions_() const {
  if (fileReleasingInstructions_Accessor) {
    return *fileReleasingInstructions_Accessor;
  }
  throw uci::base::UCIException("Error in getFileReleasingInstructions(): An attempt was made to get an optional field that was not enabled, call hasFileReleasingInstructions() to determine if it is safe to call getFileReleasingInstructions()");
}

const uci::type::NITF_ReleasingInstructionsType& FileHeaderRevA_Type::getFileReleasingInstructions() const {
  return getFileReleasingInstructions_();
}

uci::type::NITF_ReleasingInstructionsType& FileHeaderRevA_Type::getFileReleasingInstructions() {
  return getFileReleasingInstructions_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileReleasingInstructions(const uci::type::NITF_ReleasingInstructionsType& value) {
  return setFileReleasingInstructions(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileReleasingInstructions(const std::string& value) {
  return setFileReleasingInstructions(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileReleasingInstructions(const char* value) {
  enableFileReleasingInstructions().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileReleasingInstructions() const noexcept {
  return static_cast<bool>(fileReleasingInstructions_Accessor);
}

uci::type::NITF_ReleasingInstructionsType& FileHeaderRevA_Type::enableFileReleasingInstructions(uci::base::accessorType::AccessorType type) {
  if (!fileReleasingInstructions_Accessor) {
    fileReleasingInstructions_Accessor = NITF_ReleasingInstructionsType::create(type);
  }
  return *fileReleasingInstructions_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileReleasingInstructions() noexcept {
  fileReleasingInstructions_Accessor.reset();
  return *this;
}

uci::type::NITF_DeclassificationType& FileHeaderRevA_Type::getFileDeclassificationType_() const {
  if (fileDeclassificationType_Accessor) {
    return *fileDeclassificationType_Accessor;
  }
  throw uci::base::UCIException("Error in getFileDeclassificationType(): An attempt was made to get an optional field that was not enabled, call hasFileDeclassificationType() to determine if it is safe to call getFileDeclassificationType()");
}

const uci::type::NITF_DeclassificationType& FileHeaderRevA_Type::getFileDeclassificationType() const {
  return getFileDeclassificationType_();
}

uci::type::NITF_DeclassificationType& FileHeaderRevA_Type::getFileDeclassificationType() {
  return getFileDeclassificationType_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationType(const uci::type::NITF_DeclassificationType& value) {
  return setFileDeclassificationType(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationType(const std::string& value) {
  return setFileDeclassificationType(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationType(const char* value) {
  enableFileDeclassificationType().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileDeclassificationType() const noexcept {
  return static_cast<bool>(fileDeclassificationType_Accessor);
}

uci::type::NITF_DeclassificationType& FileHeaderRevA_Type::enableFileDeclassificationType(uci::base::accessorType::AccessorType type) {
  if (!fileDeclassificationType_Accessor) {
    fileDeclassificationType_Accessor = NITF_DeclassificationType::create(type);
  }
  return *fileDeclassificationType_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileDeclassificationType() noexcept {
  fileDeclassificationType_Accessor.reset();
  return *this;
}

uci::type::NITF_DateType& FileHeaderRevA_Type::getFileDeclassificationDate_() const {
  if (fileDeclassificationDate_Accessor) {
    return *fileDeclassificationDate_Accessor;
  }
  throw uci::base::UCIException("Error in getFileDeclassificationDate(): An attempt was made to get an optional field that was not enabled, call hasFileDeclassificationDate() to determine if it is safe to call getFileDeclassificationDate()");
}

const uci::type::NITF_DateType& FileHeaderRevA_Type::getFileDeclassificationDate() const {
  return getFileDeclassificationDate_();
}

uci::type::NITF_DateType& FileHeaderRevA_Type::getFileDeclassificationDate() {
  return getFileDeclassificationDate_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationDate(const uci::type::NITF_DateType& value) {
  return setFileDeclassificationDate(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationDate(const std::string& value) {
  return setFileDeclassificationDate(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationDate(const char* value) {
  enableFileDeclassificationDate().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileDeclassificationDate() const noexcept {
  return static_cast<bool>(fileDeclassificationDate_Accessor);
}

uci::type::NITF_DateType& FileHeaderRevA_Type::enableFileDeclassificationDate(uci::base::accessorType::AccessorType type) {
  if (!fileDeclassificationDate_Accessor) {
    fileDeclassificationDate_Accessor = NITF_DateType::create(type);
  }
  return *fileDeclassificationDate_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileDeclassificationDate() noexcept {
  fileDeclassificationDate_Accessor.reset();
  return *this;
}

uci::type::NITF_DeclassificationExemptionType& FileHeaderRevA_Type::getFileDeclassificationExemption_() const {
  if (fileDeclassificationExemption_Accessor) {
    return *fileDeclassificationExemption_Accessor;
  }
  throw uci::base::UCIException("Error in getFileDeclassificationExemption(): An attempt was made to get an optional field that was not enabled, call hasFileDeclassificationExemption() to determine if it is safe to call getFileDeclassificationExemption()");
}

const uci::type::NITF_DeclassificationExemptionType& FileHeaderRevA_Type::getFileDeclassificationExemption() const {
  return getFileDeclassificationExemption_();
}

uci::type::NITF_DeclassificationExemptionType& FileHeaderRevA_Type::getFileDeclassificationExemption() {
  return getFileDeclassificationExemption_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationExemption(const uci::type::NITF_DeclassificationExemptionType& value) {
  return setFileDeclassificationExemption(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationExemption(const std::string& value) {
  return setFileDeclassificationExemption(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDeclassificationExemption(const char* value) {
  enableFileDeclassificationExemption().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileDeclassificationExemption() const noexcept {
  return static_cast<bool>(fileDeclassificationExemption_Accessor);
}

uci::type::NITF_DeclassificationExemptionType& FileHeaderRevA_Type::enableFileDeclassificationExemption(uci::base::accessorType::AccessorType type) {
  if (!fileDeclassificationExemption_Accessor) {
    fileDeclassificationExemption_Accessor = NITF_DeclassificationExemptionType::create(type);
  }
  return *fileDeclassificationExemption_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileDeclassificationExemption() noexcept {
  fileDeclassificationExemption_Accessor.reset();
  return *this;
}

uci::type::NITF_DowngradeType& FileHeaderRevA_Type::getFileDowngrade_() const {
  if (fileDowngrade_Accessor) {
    return *fileDowngrade_Accessor;
  }
  throw uci::base::UCIException("Error in getFileDowngrade(): An attempt was made to get an optional field that was not enabled, call hasFileDowngrade() to determine if it is safe to call getFileDowngrade()");
}

const uci::type::NITF_DowngradeType& FileHeaderRevA_Type::getFileDowngrade() const {
  return getFileDowngrade_();
}

uci::type::NITF_DowngradeType& FileHeaderRevA_Type::getFileDowngrade() {
  return getFileDowngrade_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDowngrade(const uci::type::NITF_DowngradeType& value) {
  return setFileDowngrade(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDowngrade(const std::string& value) {
  return setFileDowngrade(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDowngrade(const char* value) {
  enableFileDowngrade().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileDowngrade() const noexcept {
  return static_cast<bool>(fileDowngrade_Accessor);
}

uci::type::NITF_DowngradeType& FileHeaderRevA_Type::enableFileDowngrade(uci::base::accessorType::AccessorType type) {
  if (!fileDowngrade_Accessor) {
    fileDowngrade_Accessor = NITF_DowngradeType::create(type);
  }
  return *fileDowngrade_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileDowngrade() noexcept {
  fileDowngrade_Accessor.reset();
  return *this;
}

uci::type::NITF_DateType& FileHeaderRevA_Type::getFileDowngradeDate_() const {
  if (fileDowngradeDate_Accessor) {
    return *fileDowngradeDate_Accessor;
  }
  throw uci::base::UCIException("Error in getFileDowngradeDate(): An attempt was made to get an optional field that was not enabled, call hasFileDowngradeDate() to determine if it is safe to call getFileDowngradeDate()");
}

const uci::type::NITF_DateType& FileHeaderRevA_Type::getFileDowngradeDate() const {
  return getFileDowngradeDate_();
}

uci::type::NITF_DateType& FileHeaderRevA_Type::getFileDowngradeDate() {
  return getFileDowngradeDate_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDowngradeDate(const uci::type::NITF_DateType& value) {
  return setFileDowngradeDate(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDowngradeDate(const std::string& value) {
  return setFileDowngradeDate(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileDowngradeDate(const char* value) {
  enableFileDowngradeDate().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileDowngradeDate() const noexcept {
  return static_cast<bool>(fileDowngradeDate_Accessor);
}

uci::type::NITF_DateType& FileHeaderRevA_Type::enableFileDowngradeDate(uci::base::accessorType::AccessorType type) {
  if (!fileDowngradeDate_Accessor) {
    fileDowngradeDate_Accessor = NITF_DateType::create(type);
  }
  return *fileDowngradeDate_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileDowngradeDate() noexcept {
  fileDowngradeDate_Accessor.reset();
  return *this;
}

uci::type::VisibleLatin1String43Type& FileHeaderRevA_Type::getFileClassificationText_() const {
  if (fileClassificationText_Accessor) {
    return *fileClassificationText_Accessor;
  }
  throw uci::base::UCIException("Error in getFileClassificationText(): An attempt was made to get an optional field that was not enabled, call hasFileClassificationText() to determine if it is safe to call getFileClassificationText()");
}

const uci::type::VisibleLatin1String43Type& FileHeaderRevA_Type::getFileClassificationText() const {
  return getFileClassificationText_();
}

uci::type::VisibleLatin1String43Type& FileHeaderRevA_Type::getFileClassificationText() {
  return getFileClassificationText_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationText(const uci::type::VisibleLatin1String43Type& value) {
  return setFileClassificationText(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationText(const std::string& value) {
  return setFileClassificationText(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationText(const char* value) {
  enableFileClassificationText().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileClassificationText() const noexcept {
  return static_cast<bool>(fileClassificationText_Accessor);
}

uci::type::VisibleLatin1String43Type& FileHeaderRevA_Type::enableFileClassificationText(uci::base::accessorType::AccessorType type) {
  if (!fileClassificationText_Accessor) {
    fileClassificationText_Accessor = VisibleLatin1String43Type::create(type);
  }
  return *fileClassificationText_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileClassificationText() noexcept {
  fileClassificationText_Accessor.reset();
  return *this;
}

uci::type::NITF_ClassificationAuthorityType& FileHeaderRevA_Type::getFileClassificationAuthorityType_() const {
  if (fileClassificationAuthorityType_Accessor) {
    return *fileClassificationAuthorityType_Accessor;
  }
  throw uci::base::UCIException("Error in getFileClassificationAuthorityType(): An attempt was made to get an optional field that was not enabled, call hasFileClassificationAuthorityType() to determine if it is safe to call getFileClassificationAuthorityType()");
}

const uci::type::NITF_ClassificationAuthorityType& FileHeaderRevA_Type::getFileClassificationAuthorityType() const {
  return getFileClassificationAuthorityType_();
}

uci::type::NITF_ClassificationAuthorityType& FileHeaderRevA_Type::getFileClassificationAuthorityType() {
  return getFileClassificationAuthorityType_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationAuthorityType(const uci::type::NITF_ClassificationAuthorityType& value) {
  return setFileClassificationAuthorityType(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationAuthorityType(const std::string& value) {
  return setFileClassificationAuthorityType(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationAuthorityType(const char* value) {
  enableFileClassificationAuthorityType().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileClassificationAuthorityType() const noexcept {
  return static_cast<bool>(fileClassificationAuthorityType_Accessor);
}

uci::type::NITF_ClassificationAuthorityType& FileHeaderRevA_Type::enableFileClassificationAuthorityType(uci::base::accessorType::AccessorType type) {
  if (!fileClassificationAuthorityType_Accessor) {
    fileClassificationAuthorityType_Accessor = NITF_ClassificationAuthorityType::create(type);
  }
  return *fileClassificationAuthorityType_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileClassificationAuthorityType() noexcept {
  fileClassificationAuthorityType_Accessor.reset();
  return *this;
}

uci::type::VisibleLatin1String40Type& FileHeaderRevA_Type::getFileClassificationAuthority_() const {
  if (fileClassificationAuthority_Accessor) {
    return *fileClassificationAuthority_Accessor;
  }
  throw uci::base::UCIException("Error in getFileClassificationAuthority(): An attempt was made to get an optional field that was not enabled, call hasFileClassificationAuthority() to determine if it is safe to call getFileClassificationAuthority()");
}

const uci::type::VisibleLatin1String40Type& FileHeaderRevA_Type::getFileClassificationAuthority() const {
  return getFileClassificationAuthority_();
}

uci::type::VisibleLatin1String40Type& FileHeaderRevA_Type::getFileClassificationAuthority() {
  return getFileClassificationAuthority_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationAuthority(const uci::type::VisibleLatin1String40Type& value) {
  return setFileClassificationAuthority(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationAuthority(const std::string& value) {
  return setFileClassificationAuthority(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationAuthority(const char* value) {
  enableFileClassificationAuthority().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileClassificationAuthority() const noexcept {
  return static_cast<bool>(fileClassificationAuthority_Accessor);
}

uci::type::VisibleLatin1String40Type& FileHeaderRevA_Type::enableFileClassificationAuthority(uci::base::accessorType::AccessorType type) {
  if (!fileClassificationAuthority_Accessor) {
    fileClassificationAuthority_Accessor = VisibleLatin1String40Type::create(type);
  }
  return *fileClassificationAuthority_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileClassificationAuthority() noexcept {
  fileClassificationAuthority_Accessor.reset();
  return *this;
}

uci::type::NITF_ClassificationReasonType& FileHeaderRevA_Type::getFileClassificationReason_() const {
  if (fileClassificationReason_Accessor) {
    return *fileClassificationReason_Accessor;
  }
  throw uci::base::UCIException("Error in getFileClassificationReason(): An attempt was made to get an optional field that was not enabled, call hasFileClassificationReason() to determine if it is safe to call getFileClassificationReason()");
}

const uci::type::NITF_ClassificationReasonType& FileHeaderRevA_Type::getFileClassificationReason() const {
  return getFileClassificationReason_();
}

uci::type::NITF_ClassificationReasonType& FileHeaderRevA_Type::getFileClassificationReason() {
  return getFileClassificationReason_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationReason(const uci::type::NITF_ClassificationReasonType& value) {
  return setFileClassificationReason(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationReason(const std::string& value) {
  return setFileClassificationReason(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileClassificationReason(const char* value) {
  enableFileClassificationReason().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileClassificationReason() const noexcept {
  return static_cast<bool>(fileClassificationReason_Accessor);
}

uci::type::NITF_ClassificationReasonType& FileHeaderRevA_Type::enableFileClassificationReason(uci::base::accessorType::AccessorType type) {
  if (!fileClassificationReason_Accessor) {
    fileClassificationReason_Accessor = NITF_ClassificationReasonType::create(type);
  }
  return *fileClassificationReason_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileClassificationReason() noexcept {
  fileClassificationReason_Accessor.reset();
  return *this;
}

uci::type::NITF_DateType& FileHeaderRevA_Type::getFileSecuritySourceDate_() const {
  if (fileSecuritySourceDate_Accessor) {
    return *fileSecuritySourceDate_Accessor;
  }
  throw uci::base::UCIException("Error in getFileSecuritySourceDate(): An attempt was made to get an optional field that was not enabled, call hasFileSecuritySourceDate() to determine if it is safe to call getFileSecuritySourceDate()");
}

const uci::type::NITF_DateType& FileHeaderRevA_Type::getFileSecuritySourceDate() const {
  return getFileSecuritySourceDate_();
}

uci::type::NITF_DateType& FileHeaderRevA_Type::getFileSecuritySourceDate() {
  return getFileSecuritySourceDate_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecuritySourceDate(const uci::type::NITF_DateType& value) {
  return setFileSecuritySourceDate(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecuritySourceDate(const std::string& value) {
  return setFileSecuritySourceDate(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecuritySourceDate(const char* value) {
  enableFileSecuritySourceDate().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileSecuritySourceDate() const noexcept {
  return static_cast<bool>(fileSecuritySourceDate_Accessor);
}

uci::type::NITF_DateType& FileHeaderRevA_Type::enableFileSecuritySourceDate(uci::base::accessorType::AccessorType type) {
  if (!fileSecuritySourceDate_Accessor) {
    fileSecuritySourceDate_Accessor = NITF_DateType::create(type);
  }
  return *fileSecuritySourceDate_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileSecuritySourceDate() noexcept {
  fileSecuritySourceDate_Accessor.reset();
  return *this;
}

uci::type::VisibleLatin1String15Type& FileHeaderRevA_Type::getFileSecurityControlNumber_() const {
  if (fileSecurityControlNumber_Accessor) {
    return *fileSecurityControlNumber_Accessor;
  }
  throw uci::base::UCIException("Error in getFileSecurityControlNumber(): An attempt was made to get an optional field that was not enabled, call hasFileSecurityControlNumber() to determine if it is safe to call getFileSecurityControlNumber()");
}

const uci::type::VisibleLatin1String15Type& FileHeaderRevA_Type::getFileSecurityControlNumber() const {
  return getFileSecurityControlNumber_();
}

uci::type::VisibleLatin1String15Type& FileHeaderRevA_Type::getFileSecurityControlNumber() {
  return getFileSecurityControlNumber_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecurityControlNumber(const uci::type::VisibleLatin1String15Type& value) {
  return setFileSecurityControlNumber(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecurityControlNumber(const std::string& value) {
  return setFileSecurityControlNumber(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setFileSecurityControlNumber(const char* value) {
  enableFileSecurityControlNumber().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasFileSecurityControlNumber() const noexcept {
  return static_cast<bool>(fileSecurityControlNumber_Accessor);
}

uci::type::VisibleLatin1String15Type& FileHeaderRevA_Type::enableFileSecurityControlNumber(uci::base::accessorType::AccessorType type) {
  if (!fileSecurityControlNumber_Accessor) {
    fileSecurityControlNumber_Accessor = VisibleLatin1String15Type::create(type);
  }
  return *fileSecurityControlNumber_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearFileSecurityControlNumber() noexcept {
  fileSecurityControlNumber_Accessor.reset();
  return *this;
}

uci::type::VisibleLatin1String24Type& FileHeaderRevA_Type::getOriginatorsName_() const {
  if (originatorsName_Accessor) {
    return *originatorsName_Accessor;
  }
  throw uci::base::UCIException("Error in getOriginatorsName(): An attempt was made to get an optional field that was not enabled, call hasOriginatorsName() to determine if it is safe to call getOriginatorsName()");
}

const uci::type::VisibleLatin1String24Type& FileHeaderRevA_Type::getOriginatorsName() const {
  return getOriginatorsName_();
}

uci::type::VisibleLatin1String24Type& FileHeaderRevA_Type::getOriginatorsName() {
  return getOriginatorsName_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setOriginatorsName(const uci::type::VisibleLatin1String24Type& value) {
  return setOriginatorsName(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setOriginatorsName(const std::string& value) {
  return setOriginatorsName(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setOriginatorsName(const char* value) {
  enableOriginatorsName().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasOriginatorsName() const noexcept {
  return static_cast<bool>(originatorsName_Accessor);
}

uci::type::VisibleLatin1String24Type& FileHeaderRevA_Type::enableOriginatorsName(uci::base::accessorType::AccessorType type) {
  if (!originatorsName_Accessor) {
    originatorsName_Accessor = VisibleLatin1String24Type::create(type);
  }
  return *originatorsName_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearOriginatorsName() noexcept {
  originatorsName_Accessor.reset();
  return *this;
}

uci::type::VisibleLatin1String18Type& FileHeaderRevA_Type::getOriginatorsPhone_() const {
  if (originatorsPhone_Accessor) {
    return *originatorsPhone_Accessor;
  }
  throw uci::base::UCIException("Error in getOriginatorsPhone(): An attempt was made to get an optional field that was not enabled, call hasOriginatorsPhone() to determine if it is safe to call getOriginatorsPhone()");
}

const uci::type::VisibleLatin1String18Type& FileHeaderRevA_Type::getOriginatorsPhone() const {
  return getOriginatorsPhone_();
}

uci::type::VisibleLatin1String18Type& FileHeaderRevA_Type::getOriginatorsPhone() {
  return getOriginatorsPhone_();
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setOriginatorsPhone(const uci::type::VisibleLatin1String18Type& value) {
  return setOriginatorsPhone(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setOriginatorsPhone(const std::string& value) {
  return setOriginatorsPhone(value.c_str());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::setOriginatorsPhone(const char* value) {
  enableOriginatorsPhone().setStringValue(value);
  return *this;
}

bool FileHeaderRevA_Type::hasOriginatorsPhone() const noexcept {
  return static_cast<bool>(originatorsPhone_Accessor);
}

uci::type::VisibleLatin1String18Type& FileHeaderRevA_Type::enableOriginatorsPhone(uci::base::accessorType::AccessorType type) {
  if (!originatorsPhone_Accessor) {
    originatorsPhone_Accessor = VisibleLatin1String18Type::create(type);
  }
  return *originatorsPhone_Accessor;
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::clearOriginatorsPhone() noexcept {
  originatorsPhone_Accessor.reset();
  return *this;
}

std::unique_ptr<FileHeaderRevA_Type> FileHeaderRevA_Type::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::fileHeaderRevA_Type : type};
  return (requestedType == uci::type::accessorType::fileHeaderRevA_Type) ? boost::make_unique<FileHeaderRevA_Type>() : nullptr;
}

/**  */
namespace FileHeaderRevA_Type_Names {

constexpr const char* Extern_Type_Name{"FileHeaderRevA_Type"};
constexpr const char* FileSecurityClassification_Name{"FileSecurityClassification"};
constexpr const char* FileClassificationSystem_Name{"FileClassificationSystem"};
constexpr const char* FileCodewords_Name{"FileCodewords"};
constexpr const char* FileControlAndHandling_Name{"FileControlAndHandling"};
constexpr const char* FileReleasingInstructions_Name{"FileReleasingInstructions"};
constexpr const char* FileDeclassificationType_Name{"FileDeclassificationType"};
constexpr const char* FileDeclassificationDate_Name{"FileDeclassificationDate"};
constexpr const char* FileDeclassificationExemption_Name{"FileDeclassificationExemption"};
constexpr const char* FileDowngrade_Name{"FileDowngrade"};
constexpr const char* FileDowngradeDate_Name{"FileDowngradeDate"};
constexpr const char* FileClassificationText_Name{"FileClassificationText"};
constexpr const char* FileClassificationAuthorityType_Name{"FileClassificationAuthorityType"};
constexpr const char* FileClassificationAuthority_Name{"FileClassificationAuthority"};
constexpr const char* FileClassificationReason_Name{"FileClassificationReason"};
constexpr const char* FileSecuritySourceDate_Name{"FileSecuritySourceDate"};
constexpr const char* FileSecurityControlNumber_Name{"FileSecurityControlNumber"};
constexpr const char* OriginatorsName_Name{"OriginatorsName"};
constexpr const char* OriginatorsPhone_Name{"OriginatorsPhone"};

} // namespace FileHeaderRevA_Type_Names

void FileHeaderRevA_Type::deserialize(const boost::property_tree::ptree& propTree, uci::type::FileHeaderRevA_Type& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = FileHeaderRevA_Type_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileSecurityClassification_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileSecurityClassification(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileClassificationSystem_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileClassificationSystem(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileCodewords_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileCodewords(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileControlAndHandling_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileControlAndHandling(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileReleasingInstructions_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileReleasingInstructions(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileDeclassificationType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileDeclassificationType(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileDeclassificationDate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileDeclassificationDate(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileDeclassificationExemption_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileDeclassificationExemption(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileDowngrade_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileDowngrade(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileDowngradeDate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileDowngradeDate(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileClassificationText_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileClassificationText(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileClassificationAuthorityType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileClassificationAuthorityType(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileClassificationAuthority_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileClassificationAuthority(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileClassificationReason_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileClassificationReason(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileSecuritySourceDate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileSecuritySourceDate(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::FileSecurityControlNumber_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileSecurityControlNumber(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::OriginatorsName_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setOriginatorsName(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderRevA_Type_Names::OriginatorsPhone_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setOriginatorsPhone(*value);
      }
    }
  }
}

std::string FileHeaderRevA_Type::serialize(const uci::type::FileHeaderRevA_Type& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? FileHeaderRevA_Type_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, FileHeaderRevA_Type_Names::Extern_Type_Name);
  }
  asb_uci::util::SerializationHelpers::serializeString(accessor.getFileSecurityClassification(), node, FileHeaderRevA_Type_Names::FileSecurityClassification_Name);
  if (accessor.hasFileClassificationSystem()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileClassificationSystem(), node, FileHeaderRevA_Type_Names::FileClassificationSystem_Name);
  }
  if (accessor.hasFileCodewords()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileCodewords(), node, FileHeaderRevA_Type_Names::FileCodewords_Name);
  }
  if (accessor.hasFileControlAndHandling()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileControlAndHandling(), node, FileHeaderRevA_Type_Names::FileControlAndHandling_Name);
  }
  if (accessor.hasFileReleasingInstructions()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileReleasingInstructions(), node, FileHeaderRevA_Type_Names::FileReleasingInstructions_Name);
  }
  if (accessor.hasFileDeclassificationType()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileDeclassificationType(), node, FileHeaderRevA_Type_Names::FileDeclassificationType_Name);
  }
  if (accessor.hasFileDeclassificationDate()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileDeclassificationDate(), node, FileHeaderRevA_Type_Names::FileDeclassificationDate_Name);
  }
  if (accessor.hasFileDeclassificationExemption()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileDeclassificationExemption(), node, FileHeaderRevA_Type_Names::FileDeclassificationExemption_Name);
  }
  if (accessor.hasFileDowngrade()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileDowngrade(), node, FileHeaderRevA_Type_Names::FileDowngrade_Name);
  }
  if (accessor.hasFileDowngradeDate()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileDowngradeDate(), node, FileHeaderRevA_Type_Names::FileDowngradeDate_Name);
  }
  if (accessor.hasFileClassificationText()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileClassificationText(), node, FileHeaderRevA_Type_Names::FileClassificationText_Name);
  }
  if (accessor.hasFileClassificationAuthorityType()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileClassificationAuthorityType(), node, FileHeaderRevA_Type_Names::FileClassificationAuthorityType_Name);
  }
  if (accessor.hasFileClassificationAuthority()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileClassificationAuthority(), node, FileHeaderRevA_Type_Names::FileClassificationAuthority_Name);
  }
  if (accessor.hasFileClassificationReason()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileClassificationReason(), node, FileHeaderRevA_Type_Names::FileClassificationReason_Name);
  }
  if (accessor.hasFileSecuritySourceDate()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileSecuritySourceDate(), node, FileHeaderRevA_Type_Names::FileSecuritySourceDate_Name);
  }
  if (accessor.hasFileSecurityControlNumber()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileSecurityControlNumber(), node, FileHeaderRevA_Type_Names::FileSecurityControlNumber_Name);
  }
  if (accessor.hasOriginatorsName()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getOriginatorsName(), node, FileHeaderRevA_Type_Names::OriginatorsName_Name);
  }
  if (accessor.hasOriginatorsPhone()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getOriginatorsPhone(), node, FileHeaderRevA_Type_Names::OriginatorsPhone_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::FileHeaderRevA_Type>().release());
}

uci::type::FileHeaderRevA_Type& FileHeaderRevA_Type::create(const uci::type::FileHeaderRevA_Type& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::FileHeaderRevA_Type> newAccessor{boost::make_unique<asb_uci::type::FileHeaderRevA_Type>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void FileHeaderRevA_Type::destroy(uci::type::FileHeaderRevA_Type& accessor) {
  delete dynamic_cast<asb_uci::type::FileHeaderRevA_Type*>(&accessor);
}

} // namespace type

} // namespace uci

