/** @file IR_ImageParamsType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/IR_ImageParamsType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/FrequencyRangeType.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/DistanceType.h"
#include "uci/type/DurationType.h"
#include "uci/type/FrequencyRangeType.h"
#include "uci/type/IR_ImageParamsType.h"
#include "uci/type/TemperatureType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

IR_ImageParamsType::IR_ImageParamsType() = default;

IR_ImageParamsType::~IR_ImageParamsType() = default;

void IR_ImageParamsType::copy(const uci::type::IR_ImageParamsType& accessor) {
  copyImpl(accessor, false);
}

void IR_ImageParamsType::copyImpl(const uci::type::IR_ImageParamsType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const IR_ImageParamsType&>(accessor);
    if (accessorImpl.hasSpectralFrequencyResolution()) {
      setSpectralFrequencyResolution(accessorImpl.getSpectralFrequencyResolution());
    } else {
      clearSpectralFrequencyResolution();
    }
    if (accessorImpl.hasTemperatureResolution()) {
      setTemperatureResolution(accessorImpl.getTemperatureResolution());
    } else {
      clearTemperatureResolution();
    }
    if (accessorImpl.iR_ImageSetting_Accessor) {
      setIR_ImageSetting(*(accessorImpl.iR_ImageSetting_Accessor));
    } else {
      iR_ImageSetting_Accessor.reset();
    }
    if (accessorImpl.hasProductResolutionTime()) {
      setProductResolutionTime(accessorImpl.getProductResolutionTime());
    } else {
      clearProductResolutionTime();
    }
  }
}

void IR_ImageParamsType::reset() noexcept {
  clearSpectralFrequencyResolution();
  clearTemperatureResolution();
  iR_ImageSetting_Accessor.reset();
  clearProductResolutionTime();
}

uci::type::DistanceTypeValue IR_ImageParamsType::getSpectralFrequencyResolution() const {
  if (spectralFrequencyResolution_Accessor) {
    return *spectralFrequencyResolution_Accessor;
  }
  throw uci::base::UCIException("Error in getSpectralFrequencyResolution(): An attempt was made to get an optional field that was not enabled, call hasSpectralFrequencyResolution() to determine if it is safe to call getSpectralFrequencyResolution()");
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::setSpectralFrequencyResolution(uci::type::DistanceTypeValue value) {
  spectralFrequencyResolution_Accessor = value;
  return *this;
}

bool IR_ImageParamsType::hasSpectralFrequencyResolution() const noexcept {
  return spectralFrequencyResolution_Accessor.has_value();
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::clearSpectralFrequencyResolution() noexcept {
  spectralFrequencyResolution_Accessor.reset();
  return *this;
}

uci::type::TemperatureTypeValue IR_ImageParamsType::getTemperatureResolution() const {
  if (temperatureResolution_Accessor) {
    return *temperatureResolution_Accessor;
  }
  throw uci::base::UCIException("Error in getTemperatureResolution(): An attempt was made to get an optional field that was not enabled, call hasTemperatureResolution() to determine if it is safe to call getTemperatureResolution()");
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::setTemperatureResolution(uci::type::TemperatureTypeValue value) {
  temperatureResolution_Accessor = value;
  return *this;
}

bool IR_ImageParamsType::hasTemperatureResolution() const noexcept {
  return temperatureResolution_Accessor.has_value();
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::clearTemperatureResolution() noexcept {
  temperatureResolution_Accessor.reset();
  return *this;
}

uci::type::FrequencyRangeType& IR_ImageParamsType::getIR_ImageSetting_() const {
  if (iR_ImageSetting_Accessor) {
    return *iR_ImageSetting_Accessor;
  }
  throw uci::base::UCIException("Error in getIR_ImageSetting(): An attempt was made to get an optional field that was not enabled, call hasIR_ImageSetting() to determine if it is safe to call getIR_ImageSetting()");
}

const uci::type::FrequencyRangeType& IR_ImageParamsType::getIR_ImageSetting() const {
  return getIR_ImageSetting_();
}

uci::type::FrequencyRangeType& IR_ImageParamsType::getIR_ImageSetting() {
  return getIR_ImageSetting_();
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::setIR_ImageSetting(const uci::type::FrequencyRangeType& accessor) {
  enableIR_ImageSetting();
  if (&accessor != iR_ImageSetting_Accessor.get()) {
    iR_ImageSetting_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool IR_ImageParamsType::hasIR_ImageSetting() const noexcept {
  return static_cast<bool>(iR_ImageSetting_Accessor);
}

uci::type::FrequencyRangeType& IR_ImageParamsType::enableIR_ImageSetting(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::frequencyRangeType : type};
  if ((!iR_ImageSetting_Accessor) || (iR_ImageSetting_Accessor->getAccessorType() != requestedType)) {
    iR_ImageSetting_Accessor = FrequencyRangeType::create(requestedType);
    if (!iR_ImageSetting_Accessor) {
      throw uci::base::UCIException("Error in enableIR_ImageSetting(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *iR_ImageSetting_Accessor;
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::clearIR_ImageSetting() noexcept {
  iR_ImageSetting_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue IR_ImageParamsType::getProductResolutionTime() const {
  if (productResolutionTime_Accessor) {
    return *productResolutionTime_Accessor;
  }
  throw uci::base::UCIException("Error in getProductResolutionTime(): An attempt was made to get an optional field that was not enabled, call hasProductResolutionTime() to determine if it is safe to call getProductResolutionTime()");
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::setProductResolutionTime(uci::type::DurationTypeValue value) {
  productResolutionTime_Accessor = value;
  return *this;
}

bool IR_ImageParamsType::hasProductResolutionTime() const noexcept {
  return productResolutionTime_Accessor.has_value();
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::clearProductResolutionTime() noexcept {
  productResolutionTime_Accessor.reset();
  return *this;
}

std::unique_ptr<IR_ImageParamsType> IR_ImageParamsType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::iR_ImageParamsType : type};
  return (requestedType == uci::type::accessorType::iR_ImageParamsType) ? boost::make_unique<IR_ImageParamsType>() : nullptr;
}

/**  */
namespace IR_ImageParamsType_Names {

constexpr const char* Extern_Type_Name{"IR_ImageParamsType"};
constexpr const char* SpectralFrequencyResolution_Name{"SpectralFrequencyResolution"};
constexpr const char* TemperatureResolution_Name{"TemperatureResolution"};
constexpr const char* IR_ImageSetting_Name{"IR_ImageSetting"};
constexpr const char* ProductResolutionTime_Name{"ProductResolutionTime"};

} // namespace IR_ImageParamsType_Names

void IR_ImageParamsType::deserialize(const boost::property_tree::ptree& propTree, uci::type::IR_ImageParamsType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = IR_ImageParamsType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + IR_ImageParamsType_Names::SpectralFrequencyResolution_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setSpectralFrequencyResolution(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + IR_ImageParamsType_Names::TemperatureResolution_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setTemperatureResolution(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + IR_ImageParamsType_Names::IR_ImageSetting_Name) {
      FrequencyRangeType::deserialize(valueType.second, accessor.enableIR_ImageSetting(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + IR_ImageParamsType_Names::ProductResolutionTime_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setProductResolutionTime(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    }
  }
}

std::string IR_ImageParamsType::serialize(const uci::type::IR_ImageParamsType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? IR_ImageParamsType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, IR_ImageParamsType_Names::Extern_Type_Name);
  }
  if (accessor.hasSpectralFrequencyResolution()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getSpectralFrequencyResolution(), node, IR_ImageParamsType_Names::SpectralFrequencyResolution_Name);
  }
  if (accessor.hasTemperatureResolution()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getTemperatureResolution(), node, IR_ImageParamsType_Names::TemperatureResolution_Name);
  }
  if (accessor.hasIR_ImageSetting()) {
    FrequencyRangeType::serialize(accessor.getIR_ImageSetting(), node, IR_ImageParamsType_Names::IR_ImageSetting_Name);
  }
  if (accessor.hasProductResolutionTime()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getProductResolutionTime(), node, IR_ImageParamsType_Names::ProductResolutionTime_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::IR_ImageParamsType& IR_ImageParamsType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::IR_ImageParamsType>().release());
}

uci::type::IR_ImageParamsType& IR_ImageParamsType::create(const uci::type::IR_ImageParamsType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::IR_ImageParamsType> newAccessor{boost::make_unique<asb_uci::type::IR_ImageParamsType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void IR_ImageParamsType::destroy(uci::type::IR_ImageParamsType& accessor) {
  delete dynamic_cast<asb_uci::type::IR_ImageParamsType*>(&accessor);
}

} // namespace type

} // namespace uci

