/** @file ReadinessItemStatusType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:14 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/ReadinessItemStatusType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/CapabilityBaseType.h"
#include "../../../include/asb_uci/type/CapabilityStatusBaseType.h"
#include "../../../include/asb_uci/type/ControlStatusMDT.h"
#include "../../../include/asb_uci/type/OperationalStatusEnum.h"
#include "../../../include/asb_uci/type/PackageStatusMDT.h"
#include "../../../include/asb_uci/type/PlanningFunctionMDT.h"
#include "../../../include/asb_uci/type/PlanningFunctionStatusMDT.h"
#include "../../../include/asb_uci/type/StoreManagementStatusMDT.h"
#include "../../../include/asb_uci/type/SubsystemConfigurationMDT.h"
#include "../../../include/asb_uci/type/SubsystemStatusMDT.h"
#include "../../../include/asb_uci/type/SystemStatusMDT.h"
#include "../../../include/asb_uci/type/VisibleString256Type.h"
#include "../../../include/asb_uci/util/DerivedTypesDeserializer.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CapabilityBaseType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CapabilityStatusBaseType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ControlStatusMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/OperationalStatusEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PackageStatusMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PlanningFunctionMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PlanningFunctionStatusMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ReadinessItemStatusType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/StoreManagementStatusMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SubsystemConfigurationMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SubsystemStatusMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SystemStatusMDT.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/VisibleString256Type.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

ReadinessItemStatusType::ReadinessItemStatusType()
  : operationalStatus_Accessor{boost::make_unique<OperationalStatusEnum>()},
    subsystemStatus_Accessor{boost::make_unique<SubsystemStatus>(0, SIZE_MAX)},
    subsystemConfiguration_Accessor{boost::make_unique<SubsystemConfiguration>(0, SIZE_MAX)},
    capability_Accessor{boost::make_unique<Capability>(0, SIZE_MAX)},
    capabilityStatus_Accessor{boost::make_unique<CapabilityStatus>(0, SIZE_MAX)},
    storeManagementStatus_Accessor{boost::make_unique<StoreManagementStatus>(0, SIZE_MAX)},
    controlStatus_Accessor{boost::make_unique<ControlStatus>(0, SIZE_MAX)},
    packageStatus_Accessor{boost::make_unique<PackageStatus>(0, SIZE_MAX)} {
}

ReadinessItemStatusType::~ReadinessItemStatusType() = default;

void ReadinessItemStatusType::copy(const uci::type::ReadinessItemStatusType& accessor) {
  copyImpl(accessor, false);
}

void ReadinessItemStatusType::copyImpl(const uci::type::ReadinessItemStatusType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const ReadinessItemStatusType&>(accessor);
    setOperationalStatus(*(accessorImpl.operationalStatus_Accessor));
    if (accessorImpl.reason_Accessor) {
      setReason(*(accessorImpl.reason_Accessor));
    } else {
      reason_Accessor.reset();
    }
    if (accessorImpl.systemStatus_Accessor) {
      setSystemStatus(*(accessorImpl.systemStatus_Accessor));
    } else {
      systemStatus_Accessor.reset();
    }
    setSubsystemStatus(*(accessorImpl.subsystemStatus_Accessor));
    setSubsystemConfiguration(*(accessorImpl.subsystemConfiguration_Accessor));
    setCapability(*(accessorImpl.capability_Accessor));
    setCapabilityStatus(*(accessorImpl.capabilityStatus_Accessor));
    setStoreManagementStatus(*(accessorImpl.storeManagementStatus_Accessor));
    setControlStatus(*(accessorImpl.controlStatus_Accessor));
    if (accessorImpl.planningFunction_Accessor) {
      setPlanningFunction(*(accessorImpl.planningFunction_Accessor));
    } else {
      planningFunction_Accessor.reset();
    }
    if (accessorImpl.planningFunctionStatus_Accessor) {
      setPlanningFunctionStatus(*(accessorImpl.planningFunctionStatus_Accessor));
    } else {
      planningFunctionStatus_Accessor.reset();
    }
    setPackageStatus(*(accessorImpl.packageStatus_Accessor));
  }
}

void ReadinessItemStatusType::reset() noexcept {
  operationalStatus_Accessor->reset();
  reason_Accessor.reset();
  systemStatus_Accessor.reset();
  subsystemStatus_Accessor->reset();
  subsystemConfiguration_Accessor->reset();
  capability_Accessor->reset();
  capabilityStatus_Accessor->reset();
  storeManagementStatus_Accessor->reset();
  controlStatus_Accessor->reset();
  planningFunction_Accessor.reset();
  planningFunctionStatus_Accessor.reset();
  packageStatus_Accessor->reset();
}

const uci::type::OperationalStatusEnum& ReadinessItemStatusType::getOperationalStatus() const {
  return *operationalStatus_Accessor;
}

uci::type::OperationalStatusEnum& ReadinessItemStatusType::getOperationalStatus() {
  return *operationalStatus_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setOperationalStatus(const uci::type::OperationalStatusEnum& accessor) {
  if (&accessor != operationalStatus_Accessor.get()) {
    operationalStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setOperationalStatus(uci::type::OperationalStatusEnum::EnumerationItem value) {
  operationalStatus_Accessor->setValue(value);
  return *this;
}


asb_uci::type::VisibleString256Type& ReadinessItemStatusType::getReason_() const {
  if (reason_Accessor) {
    return *reason_Accessor;
  }
  throw uci::base::UCIException("Error in getReason(): An attempt was made to get an optional field that was not enabled, call hasReason() to determine if it is safe to call getReason()");
}

const asb_uci::type::VisibleString256Type& ReadinessItemStatusType::getReason() const {
  return getReason_();
}

asb_uci::type::VisibleString256Type& ReadinessItemStatusType::getReason() {
  return getReason_();
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setReason(const asb_uci::type::VisibleString256Type& value) {
  return setReason(value.c_str());
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setReason(const std::string& value) {
  return setReason(value.c_str());
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setReason(const char* value) {
  enableReason().setStringValue(value);
  return *this;
}

bool ReadinessItemStatusType::hasReason() const noexcept {
  return static_cast<bool>(reason_Accessor);
}

asb_uci::type::VisibleString256Type& ReadinessItemStatusType::enableReason(uci::base::accessorType::AccessorType type) {
  if (!reason_Accessor) {
    reason_Accessor =  asb_uci::type::VisibleString256Type::create(type);
  }
  return *reason_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::clearReason() noexcept {
  reason_Accessor.reset();
  return *this;
}

uci::type::SystemStatusMDT& ReadinessItemStatusType::getSystemStatus_() const {
  if (systemStatus_Accessor) {
    return *systemStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getSystemStatus(): An attempt was made to get an optional field that was not enabled, call hasSystemStatus() to determine if it is safe to call getSystemStatus()");
}

const uci::type::SystemStatusMDT& ReadinessItemStatusType::getSystemStatus() const {
  return getSystemStatus_();
}

uci::type::SystemStatusMDT& ReadinessItemStatusType::getSystemStatus() {
  return getSystemStatus_();
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setSystemStatus(const uci::type::SystemStatusMDT& accessor) {
  enableSystemStatus();
  if (&accessor != systemStatus_Accessor.get()) {
    systemStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool ReadinessItemStatusType::hasSystemStatus() const noexcept {
  return static_cast<bool>(systemStatus_Accessor);
}

uci::type::SystemStatusMDT& ReadinessItemStatusType::enableSystemStatus(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::systemStatusMDT : type};
  if ((!systemStatus_Accessor) || (systemStatus_Accessor->getAccessorType() != requestedType)) {
    systemStatus_Accessor = SystemStatusMDT::create(requestedType);
    if (!systemStatus_Accessor) {
      throw uci::base::UCIException("Error in enableSystemStatus(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *systemStatus_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::clearSystemStatus() noexcept {
  systemStatus_Accessor.reset();
  return *this;
}

const uci::type::ReadinessItemStatusType::SubsystemStatus& ReadinessItemStatusType::getSubsystemStatus() const {
  return *subsystemStatus_Accessor;
}

uci::type::ReadinessItemStatusType::SubsystemStatus& ReadinessItemStatusType::getSubsystemStatus() {
  return *subsystemStatus_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setSubsystemStatus(const uci::type::ReadinessItemStatusType::SubsystemStatus& accessor) {
  if (&accessor != subsystemStatus_Accessor.get()) {
    subsystemStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::ReadinessItemStatusType::SubsystemConfiguration& ReadinessItemStatusType::getSubsystemConfiguration() const {
  return *subsystemConfiguration_Accessor;
}

uci::type::ReadinessItemStatusType::SubsystemConfiguration& ReadinessItemStatusType::getSubsystemConfiguration() {
  return *subsystemConfiguration_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setSubsystemConfiguration(const uci::type::ReadinessItemStatusType::SubsystemConfiguration& accessor) {
  if (&accessor != subsystemConfiguration_Accessor.get()) {
    subsystemConfiguration_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::ReadinessItemStatusType::Capability& ReadinessItemStatusType::getCapability() const {
  return *capability_Accessor;
}

uci::type::ReadinessItemStatusType::Capability& ReadinessItemStatusType::getCapability() {
  return *capability_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setCapability(const uci::type::ReadinessItemStatusType::Capability& accessor) {
  if (&accessor != capability_Accessor.get()) {
    capability_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::ReadinessItemStatusType::CapabilityStatus& ReadinessItemStatusType::getCapabilityStatus() const {
  return *capabilityStatus_Accessor;
}

uci::type::ReadinessItemStatusType::CapabilityStatus& ReadinessItemStatusType::getCapabilityStatus() {
  return *capabilityStatus_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setCapabilityStatus(const uci::type::ReadinessItemStatusType::CapabilityStatus& accessor) {
  if (&accessor != capabilityStatus_Accessor.get()) {
    capabilityStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::ReadinessItemStatusType::StoreManagementStatus& ReadinessItemStatusType::getStoreManagementStatus() const {
  return *storeManagementStatus_Accessor;
}

uci::type::ReadinessItemStatusType::StoreManagementStatus& ReadinessItemStatusType::getStoreManagementStatus() {
  return *storeManagementStatus_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setStoreManagementStatus(const uci::type::ReadinessItemStatusType::StoreManagementStatus& accessor) {
  if (&accessor != storeManagementStatus_Accessor.get()) {
    storeManagementStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::ReadinessItemStatusType::ControlStatus& ReadinessItemStatusType::getControlStatus() const {
  return *controlStatus_Accessor;
}

uci::type::ReadinessItemStatusType::ControlStatus& ReadinessItemStatusType::getControlStatus() {
  return *controlStatus_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setControlStatus(const uci::type::ReadinessItemStatusType::ControlStatus& accessor) {
  if (&accessor != controlStatus_Accessor.get()) {
    controlStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::PlanningFunctionMDT& ReadinessItemStatusType::getPlanningFunction_() const {
  if (planningFunction_Accessor) {
    return *planningFunction_Accessor;
  }
  throw uci::base::UCIException("Error in getPlanningFunction(): An attempt was made to get an optional field that was not enabled, call hasPlanningFunction() to determine if it is safe to call getPlanningFunction()");
}

const uci::type::PlanningFunctionMDT& ReadinessItemStatusType::getPlanningFunction() const {
  return getPlanningFunction_();
}

uci::type::PlanningFunctionMDT& ReadinessItemStatusType::getPlanningFunction() {
  return getPlanningFunction_();
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setPlanningFunction(const uci::type::PlanningFunctionMDT& accessor) {
  enablePlanningFunction();
  if (&accessor != planningFunction_Accessor.get()) {
    planningFunction_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool ReadinessItemStatusType::hasPlanningFunction() const noexcept {
  return static_cast<bool>(planningFunction_Accessor);
}

uci::type::PlanningFunctionMDT& ReadinessItemStatusType::enablePlanningFunction(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::planningFunctionMDT : type};
  if ((!planningFunction_Accessor) || (planningFunction_Accessor->getAccessorType() != requestedType)) {
    planningFunction_Accessor = PlanningFunctionMDT::create(requestedType);
    if (!planningFunction_Accessor) {
      throw uci::base::UCIException("Error in enablePlanningFunction(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *planningFunction_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::clearPlanningFunction() noexcept {
  planningFunction_Accessor.reset();
  return *this;
}

uci::type::PlanningFunctionStatusMDT& ReadinessItemStatusType::getPlanningFunctionStatus_() const {
  if (planningFunctionStatus_Accessor) {
    return *planningFunctionStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getPlanningFunctionStatus(): An attempt was made to get an optional field that was not enabled, call hasPlanningFunctionStatus() to determine if it is safe to call getPlanningFunctionStatus()");
}

const uci::type::PlanningFunctionStatusMDT& ReadinessItemStatusType::getPlanningFunctionStatus() const {
  return getPlanningFunctionStatus_();
}

uci::type::PlanningFunctionStatusMDT& ReadinessItemStatusType::getPlanningFunctionStatus() {
  return getPlanningFunctionStatus_();
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setPlanningFunctionStatus(const uci::type::PlanningFunctionStatusMDT& accessor) {
  enablePlanningFunctionStatus();
  if (&accessor != planningFunctionStatus_Accessor.get()) {
    planningFunctionStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool ReadinessItemStatusType::hasPlanningFunctionStatus() const noexcept {
  return static_cast<bool>(planningFunctionStatus_Accessor);
}

uci::type::PlanningFunctionStatusMDT& ReadinessItemStatusType::enablePlanningFunctionStatus(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::planningFunctionStatusMDT : type};
  if ((!planningFunctionStatus_Accessor) || (planningFunctionStatus_Accessor->getAccessorType() != requestedType)) {
    planningFunctionStatus_Accessor = PlanningFunctionStatusMDT::create(requestedType);
    if (!planningFunctionStatus_Accessor) {
      throw uci::base::UCIException("Error in enablePlanningFunctionStatus(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *planningFunctionStatus_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::clearPlanningFunctionStatus() noexcept {
  planningFunctionStatus_Accessor.reset();
  return *this;
}

const uci::type::ReadinessItemStatusType::PackageStatus& ReadinessItemStatusType::getPackageStatus() const {
  return *packageStatus_Accessor;
}

uci::type::ReadinessItemStatusType::PackageStatus& ReadinessItemStatusType::getPackageStatus() {
  return *packageStatus_Accessor;
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::setPackageStatus(const uci::type::ReadinessItemStatusType::PackageStatus& accessor) {
  if (&accessor != packageStatus_Accessor.get()) {
    packageStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

std::unique_ptr<ReadinessItemStatusType> ReadinessItemStatusType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::readinessItemStatusType : type};
  return (requestedType == uci::type::accessorType::readinessItemStatusType) ? boost::make_unique<ReadinessItemStatusType>() : nullptr;
}

/**  */
namespace ReadinessItemStatusType_Names {

constexpr const char* Extern_Type_Name{"ReadinessItemStatusType"};
constexpr const char* OperationalStatus_Name{"OperationalStatus"};
constexpr const char* Reason_Name{"Reason"};
constexpr const char* SystemStatus_Name{"SystemStatus"};
constexpr const char* SubsystemStatus_Name{"SubsystemStatus"};
constexpr const char* SubsystemConfiguration_Name{"SubsystemConfiguration"};
constexpr const char* Capability_Name{"Capability"};
constexpr const char* CapabilityStatus_Name{"CapabilityStatus"};
constexpr const char* StoreManagementStatus_Name{"StoreManagementStatus"};
constexpr const char* ControlStatus_Name{"ControlStatus"};
constexpr const char* PlanningFunction_Name{"PlanningFunction"};
constexpr const char* PlanningFunctionStatus_Name{"PlanningFunctionStatus"};
constexpr const char* PackageStatus_Name{"PackageStatus"};

} // namespace ReadinessItemStatusType_Names

void ReadinessItemStatusType::deserialize(const boost::property_tree::ptree& propTree, uci::type::ReadinessItemStatusType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = ReadinessItemStatusType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::OperationalStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.getOperationalStatus().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::Reason_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setReason(*value);
      }
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::SystemStatus_Name) {
      SystemStatusMDT::deserialize(valueType.second, accessor.enableSystemStatus(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::SubsystemStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::ReadinessItemStatusType::SubsystemStatus& boundedList = accessor.getSubsystemStatus();
        const uci::type::ReadinessItemStatusType::SubsystemStatus::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::SubsystemStatusMDT::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::SubsystemConfiguration_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::ReadinessItemStatusType::SubsystemConfiguration& boundedList = accessor.getSubsystemConfiguration();
        const uci::type::ReadinessItemStatusType::SubsystemConfiguration::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::SubsystemConfigurationMDT::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::Capability_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::ReadinessItemStatusType::Capability& boundedList = accessor.getCapability();
        const uci::type::ReadinessItemStatusType::Capability::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1, asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix));
        asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::CapabilityStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::ReadinessItemStatusType::CapabilityStatus& boundedList = accessor.getCapabilityStatus();
        const uci::type::ReadinessItemStatusType::CapabilityStatus::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1, asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix));
        asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::StoreManagementStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::ReadinessItemStatusType::StoreManagementStatus& boundedList = accessor.getStoreManagementStatus();
        const uci::type::ReadinessItemStatusType::StoreManagementStatus::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::StoreManagementStatusMDT::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::ControlStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::ReadinessItemStatusType::ControlStatus& boundedList = accessor.getControlStatus();
        const uci::type::ReadinessItemStatusType::ControlStatus::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::ControlStatusMDT::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::PlanningFunction_Name) {
      PlanningFunctionMDT::deserialize(valueType.second, accessor.enablePlanningFunction(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::PlanningFunctionStatus_Name) {
      PlanningFunctionStatusMDT::deserialize(valueType.second, accessor.enablePlanningFunctionStatus(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + ReadinessItemStatusType_Names::PackageStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::ReadinessItemStatusType::PackageStatus& boundedList = accessor.getPackageStatus();
        const uci::type::ReadinessItemStatusType::PackageStatus::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::PackageStatusMDT::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    }
  }
}

std::string ReadinessItemStatusType::serialize(const uci::type::ReadinessItemStatusType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? ReadinessItemStatusType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, ReadinessItemStatusType_Names::Extern_Type_Name);
  }
  OperationalStatusEnum::serialize(accessor.getOperationalStatus(), node, ReadinessItemStatusType_Names::OperationalStatus_Name, false);
  if (accessor.hasReason()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getReason(), node, ReadinessItemStatusType_Names::Reason_Name);
  }
  if (accessor.hasSystemStatus()) {
    SystemStatusMDT::serialize(accessor.getSystemStatus(), node, ReadinessItemStatusType_Names::SystemStatus_Name);
  }
  {
    const uci::type::ReadinessItemStatusType::SubsystemStatus& boundedList = accessor.getSubsystemStatus();
    for (uci::type::ReadinessItemStatusType::SubsystemStatus::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::SubsystemStatusMDT::serialize(boundedList.at(i), node, ReadinessItemStatusType_Names::SubsystemStatus_Name);
    }
  }
  {
    const uci::type::ReadinessItemStatusType::SubsystemConfiguration& boundedList = accessor.getSubsystemConfiguration();
    for (uci::type::ReadinessItemStatusType::SubsystemConfiguration::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::SubsystemConfigurationMDT::serialize(boundedList.at(i), node, ReadinessItemStatusType_Names::SubsystemConfiguration_Name);
    }
  }
  {
    const uci::type::ReadinessItemStatusType::Capability& boundedList = accessor.getCapability();
    for (uci::type::ReadinessItemStatusType::Capability::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::CapabilityBaseType::serialize(boundedList.at(i), node, ReadinessItemStatusType_Names::Capability_Name);
    }
  }
  {
    const uci::type::ReadinessItemStatusType::CapabilityStatus& boundedList = accessor.getCapabilityStatus();
    for (uci::type::ReadinessItemStatusType::CapabilityStatus::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::CapabilityStatusBaseType::serialize(boundedList.at(i), node, ReadinessItemStatusType_Names::CapabilityStatus_Name);
    }
  }
  {
    const uci::type::ReadinessItemStatusType::StoreManagementStatus& boundedList = accessor.getStoreManagementStatus();
    for (uci::type::ReadinessItemStatusType::StoreManagementStatus::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::StoreManagementStatusMDT::serialize(boundedList.at(i), node, ReadinessItemStatusType_Names::StoreManagementStatus_Name);
    }
  }
  {
    const uci::type::ReadinessItemStatusType::ControlStatus& boundedList = accessor.getControlStatus();
    for (uci::type::ReadinessItemStatusType::ControlStatus::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::ControlStatusMDT::serialize(boundedList.at(i), node, ReadinessItemStatusType_Names::ControlStatus_Name);
    }
  }
  if (accessor.hasPlanningFunction()) {
    PlanningFunctionMDT::serialize(accessor.getPlanningFunction(), node, ReadinessItemStatusType_Names::PlanningFunction_Name);
  }
  if (accessor.hasPlanningFunctionStatus()) {
    PlanningFunctionStatusMDT::serialize(accessor.getPlanningFunctionStatus(), node, ReadinessItemStatusType_Names::PlanningFunctionStatus_Name);
  }
  {
    const uci::type::ReadinessItemStatusType::PackageStatus& boundedList = accessor.getPackageStatus();
    for (uci::type::ReadinessItemStatusType::PackageStatus::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::PackageStatusMDT::serialize(boundedList.at(i), node, ReadinessItemStatusType_Names::PackageStatus_Name);
    }
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::ReadinessItemStatusType>().release());
}

uci::type::ReadinessItemStatusType& ReadinessItemStatusType::create(const uci::type::ReadinessItemStatusType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::ReadinessItemStatusType> newAccessor{boost::make_unique<asb_uci::type::ReadinessItemStatusType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void ReadinessItemStatusType::destroy(uci::type::ReadinessItemStatusType& accessor) {
  delete dynamic_cast<asb_uci::type::ReadinessItemStatusType*>(&accessor);
}

} // namespace type

} // namespace uci

