/** @file MISP_PackingPlanType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/MISP_PackingPlanType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/AlphanumericDashSpaceUnderscoreString16Type.h"
#include "asb_uci/type/AlphanumericDashSpaceUnderscoreString20Type.h"
#include "asb_uci/type/AlphanumericDashSpaceUnderscoreString40Type.h"
#include "asb_uci/type/MISP_OperationalModeEnum.h"
#include "asb_uci/type/MissionID_Type.h"
#include "asb_uci/type/TailNumberType.h"
#include "asb_uci/type/UMID_AudioID_Type.h"
#include "asb_uci/type/UMID_DataID_Type.h"
#include "asb_uci/type/UMID_SystemID_Type.h"
#include "asb_uci/type/UMID_VideoID_Type.h"
#include "asb_uci/type/VisibleString10Type.h"
#include "asb_uci/type/VisibleString20Type.h"
#include "asb_uci/type/VisibleString480Type.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/AlphanumericDashSpaceUnderscoreString16Type.h"
#include "uci/type/AlphanumericDashSpaceUnderscoreString20Type.h"
#include "uci/type/AlphanumericDashSpaceUnderscoreString40Type.h"
#include "uci/type/MISP_OperationalModeEnum.h"
#include "uci/type/MISP_PackingPlanType.h"
#include "uci/type/MissionID_Type.h"
#include "uci/type/TailNumberType.h"
#include "uci/type/UMID_AudioID_Type.h"
#include "uci/type/UMID_DataID_Type.h"
#include "uci/type/UMID_SystemID_Type.h"
#include "uci/type/UMID_VideoID_Type.h"
#include "uci/type/VisibleString10Type.h"
#include "uci/type/VisibleString20Type.h"
#include "uci/type/VisibleString480Type.h"
#include "xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

MISP_PackingPlanType::MISP_PackingPlanType()
  : missionID_Accessor{boost::make_unique<MissionID_Type>()},
    platformDesignation_Accessor{boost::make_unique<AlphanumericDashSpaceUnderscoreString20Type>()},
    imageSourceSensor_Accessor{boost::make_unique<VisibleString20Type>()} {
}

MISP_PackingPlanType::~MISP_PackingPlanType() = default;

void MISP_PackingPlanType::copy(const uci::type::MISP_PackingPlanType& accessor) {
  copyImpl(accessor, false);
}

void MISP_PackingPlanType::copyImpl(const uci::type::MISP_PackingPlanType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const MISP_PackingPlanType&>(accessor);
    setMissionID(*(accessorImpl.missionID_Accessor));
    setPlatformDesignation(*(accessorImpl.platformDesignation_Accessor));
    setImageSourceSensor(*(accessorImpl.imageSourceSensor_Accessor));
    if (accessorImpl.platformTailNumber_Accessor) {
      setPlatformTailNumber(*(accessorImpl.platformTailNumber_Accessor));
    } else {
      platformTailNumber_Accessor.reset();
    }
    if (accessorImpl.hasAirfieldBarometricPressure()) {
      setAirfieldBarometricPressure(accessorImpl.getAirfieldBarometricPressure());
    } else {
      clearAirfieldBarometricPressure();
    }
    if (accessorImpl.hasAirFieldElevation()) {
      setAirFieldElevation(accessorImpl.getAirFieldElevation());
    } else {
      clearAirFieldElevation();
    }
    if (accessorImpl.platformCallSign_Accessor) {
      setPlatformCallSign(*(accessorImpl.platformCallSign_Accessor));
    } else {
      platformCallSign_Accessor.reset();
    }
    if (accessorImpl.operationalMode_Accessor) {
      setOperationalMode(*(accessorImpl.operationalMode_Accessor));
    } else {
      operationalMode_Accessor.reset();
    }
    if (accessorImpl.classificationOrMarkingSystem_Accessor) {
      setClassificationOrMarkingSystem(*(accessorImpl.classificationOrMarkingSystem_Accessor));
    } else {
      classificationOrMarkingSystem_Accessor.reset();
    }
    if (accessorImpl.classificationComment_Accessor) {
      setClassificationComment(*(accessorImpl.classificationComment_Accessor));
    } else {
      classificationComment_Accessor.reset();
    }
    if (accessorImpl.uMID_VideoID_Accessor) {
      setUMID_VideoID(*(accessorImpl.uMID_VideoID_Accessor));
    } else {
      uMID_VideoID_Accessor.reset();
    }
    if (accessorImpl.uMID_AudioID_Accessor) {
      setUMID_AudioID(*(accessorImpl.uMID_AudioID_Accessor));
    } else {
      uMID_AudioID_Accessor.reset();
    }
    if (accessorImpl.uMID_DataID_Accessor) {
      setUMID_DataID(*(accessorImpl.uMID_DataID_Accessor));
    } else {
      uMID_DataID_Accessor.reset();
    }
    if (accessorImpl.uMID_SystemID_Accessor) {
      setUMID_SystemID(*(accessorImpl.uMID_SystemID_Accessor));
    } else {
      uMID_SystemID_Accessor.reset();
    }
    if (accessorImpl.itemDesignator_Accessor) {
      setItemDesignator(*(accessorImpl.itemDesignator_Accessor));
    } else {
      itemDesignator_Accessor.reset();
    }
  }
}

void MISP_PackingPlanType::reset() noexcept {
  missionID_Accessor->reset();
  platformDesignation_Accessor->reset();
  imageSourceSensor_Accessor->reset();
  platformTailNumber_Accessor.reset();
  clearAirfieldBarometricPressure();
  clearAirFieldElevation();
  platformCallSign_Accessor.reset();
  operationalMode_Accessor.reset();
  classificationOrMarkingSystem_Accessor.reset();
  classificationComment_Accessor.reset();
  uMID_VideoID_Accessor.reset();
  uMID_AudioID_Accessor.reset();
  uMID_DataID_Accessor.reset();
  uMID_SystemID_Accessor.reset();
  itemDesignator_Accessor.reset();
}

const uci::type::MissionID_Type& MISP_PackingPlanType::getMissionID() const {
  return *missionID_Accessor;
}

uci::type::MissionID_Type& MISP_PackingPlanType::getMissionID() {
  return *missionID_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setMissionID(const uci::type::MissionID_Type& accessor) {
  if (&accessor != missionID_Accessor.get()) {
    missionID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::AlphanumericDashSpaceUnderscoreString20Type& MISP_PackingPlanType::getPlatformDesignation() const noexcept {
  return *platformDesignation_Accessor;
}

uci::type::AlphanumericDashSpaceUnderscoreString20Type& MISP_PackingPlanType::getPlatformDesignation() noexcept {
  return *platformDesignation_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformDesignation(const uci::type::AlphanumericDashSpaceUnderscoreString20Type& value) {
  return setPlatformDesignation(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformDesignation(const std::string& value) {
  return setPlatformDesignation(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformDesignation(const char* value) {
  platformDesignation_Accessor->setStringValue(value);
  return *this;
}

const uci::type::VisibleString20Type& MISP_PackingPlanType::getImageSourceSensor() const noexcept {
  return *imageSourceSensor_Accessor;
}

uci::type::VisibleString20Type& MISP_PackingPlanType::getImageSourceSensor() noexcept {
  return *imageSourceSensor_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setImageSourceSensor(const uci::type::VisibleString20Type& value) {
  return setImageSourceSensor(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setImageSourceSensor(const std::string& value) {
  return setImageSourceSensor(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setImageSourceSensor(const char* value) {
  imageSourceSensor_Accessor->setStringValue(value);
  return *this;
}

uci::type::TailNumberType& MISP_PackingPlanType::getPlatformTailNumber_() const {
  if (platformTailNumber_Accessor) {
    return *platformTailNumber_Accessor;
  }
  throw uci::base::UCIException("Error in getPlatformTailNumber(): An attempt was made to get an optional field that was not enabled, call hasPlatformTailNumber() to determine if it is safe to call getPlatformTailNumber()");
}

const uci::type::TailNumberType& MISP_PackingPlanType::getPlatformTailNumber() const {
  return getPlatformTailNumber_();
}

uci::type::TailNumberType& MISP_PackingPlanType::getPlatformTailNumber() {
  return getPlatformTailNumber_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformTailNumber(const uci::type::TailNumberType& value) {
  return setPlatformTailNumber(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformTailNumber(const std::string& value) {
  return setPlatformTailNumber(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformTailNumber(const char* value) {
  enablePlatformTailNumber().setStringValue(value);
  return *this;
}

bool MISP_PackingPlanType::hasPlatformTailNumber() const noexcept {
  return static_cast<bool>(platformTailNumber_Accessor);
}

uci::type::TailNumberType& MISP_PackingPlanType::enablePlatformTailNumber(uci::base::accessorType::AccessorType type) {
  if (!platformTailNumber_Accessor) {
    platformTailNumber_Accessor = TailNumberType::create(type);
  }
  return *platformTailNumber_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearPlatformTailNumber() noexcept {
  platformTailNumber_Accessor.reset();
  return *this;
}

xs::Double MISP_PackingPlanType::getAirfieldBarometricPressure() const {
  if (airfieldBarometricPressure_Accessor) {
    return *airfieldBarometricPressure_Accessor;
  }
  throw uci::base::UCIException("Error in getAirfieldBarometricPressure(): An attempt was made to get an optional field that was not enabled, call hasAirfieldBarometricPressure() to determine if it is safe to call getAirfieldBarometricPressure()");
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setAirfieldBarometricPressure(xs::Double value) {
  airfieldBarometricPressure_Accessor = value;
  return *this;
}

bool MISP_PackingPlanType::hasAirfieldBarometricPressure() const noexcept {
  return airfieldBarometricPressure_Accessor.has_value();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearAirfieldBarometricPressure() noexcept {
  airfieldBarometricPressure_Accessor.reset();
  return *this;
}

xs::Double MISP_PackingPlanType::getAirFieldElevation() const {
  if (airFieldElevation_Accessor) {
    return *airFieldElevation_Accessor;
  }
  throw uci::base::UCIException("Error in getAirFieldElevation(): An attempt was made to get an optional field that was not enabled, call hasAirFieldElevation() to determine if it is safe to call getAirFieldElevation()");
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setAirFieldElevation(xs::Double value) {
  airFieldElevation_Accessor = value;
  return *this;
}

bool MISP_PackingPlanType::hasAirFieldElevation() const noexcept {
  return airFieldElevation_Accessor.has_value();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearAirFieldElevation() noexcept {
  airFieldElevation_Accessor.reset();
  return *this;
}

uci::type::VisibleString10Type& MISP_PackingPlanType::getPlatformCallSign_() const {
  if (platformCallSign_Accessor) {
    return *platformCallSign_Accessor;
  }
  throw uci::base::UCIException("Error in getPlatformCallSign(): An attempt was made to get an optional field that was not enabled, call hasPlatformCallSign() to determine if it is safe to call getPlatformCallSign()");
}

const uci::type::VisibleString10Type& MISP_PackingPlanType::getPlatformCallSign() const {
  return getPlatformCallSign_();
}

uci::type::VisibleString10Type& MISP_PackingPlanType::getPlatformCallSign() {
  return getPlatformCallSign_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformCallSign(const uci::type::VisibleString10Type& value) {
  return setPlatformCallSign(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformCallSign(const std::string& value) {
  return setPlatformCallSign(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setPlatformCallSign(const char* value) {
  enablePlatformCallSign().setStringValue(value);
  return *this;
}

bool MISP_PackingPlanType::hasPlatformCallSign() const noexcept {
  return static_cast<bool>(platformCallSign_Accessor);
}

uci::type::VisibleString10Type& MISP_PackingPlanType::enablePlatformCallSign(uci::base::accessorType::AccessorType type) {
  if (!platformCallSign_Accessor) {
    platformCallSign_Accessor = VisibleString10Type::create(type);
  }
  return *platformCallSign_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearPlatformCallSign() noexcept {
  platformCallSign_Accessor.reset();
  return *this;
}

uci::type::MISP_OperationalModeEnum& MISP_PackingPlanType::getOperationalMode_() const {
  if (operationalMode_Accessor) {
    return *operationalMode_Accessor;
  }
  throw uci::base::UCIException("Error in getOperationalMode(): An attempt was made to get an optional field that was not enabled, call hasOperationalMode() to determine if it is safe to call getOperationalMode()");
}

const uci::type::MISP_OperationalModeEnum& MISP_PackingPlanType::getOperationalMode() const {
  return getOperationalMode_();
}

uci::type::MISP_OperationalModeEnum& MISP_PackingPlanType::getOperationalMode() {
  return getOperationalMode_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setOperationalMode(const uci::type::MISP_OperationalModeEnum& accessor) {
  enableOperationalMode();
  if (&accessor != operationalMode_Accessor.get()) {
    operationalMode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setOperationalMode(const uci::type::MISP_OperationalModeEnum::EnumerationItem value) {
  enableOperationalMode().setValue(value);
  return *this;
}

bool MISP_PackingPlanType::hasOperationalMode() const noexcept {
  return static_cast<bool>(operationalMode_Accessor);
}

uci::type::MISP_OperationalModeEnum& MISP_PackingPlanType::enableOperationalMode(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::mISP_OperationalModeEnum : type};
  if ((!operationalMode_Accessor) || (operationalMode_Accessor->getAccessorType() != requestedType)) {
    operationalMode_Accessor = MISP_OperationalModeEnum::create(requestedType);
    if (!operationalMode_Accessor) {
      throw uci::base::UCIException("Error in enableOperationalMode(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *operationalMode_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearOperationalMode() noexcept {
  operationalMode_Accessor.reset();
  return *this;
}

uci::type::AlphanumericDashSpaceUnderscoreString40Type& MISP_PackingPlanType::getClassificationOrMarkingSystem_() const {
  if (classificationOrMarkingSystem_Accessor) {
    return *classificationOrMarkingSystem_Accessor;
  }
  throw uci::base::UCIException("Error in getClassificationOrMarkingSystem(): An attempt was made to get an optional field that was not enabled, call hasClassificationOrMarkingSystem() to determine if it is safe to call getClassificationOrMarkingSystem()");
}

const uci::type::AlphanumericDashSpaceUnderscoreString40Type& MISP_PackingPlanType::getClassificationOrMarkingSystem() const {
  return getClassificationOrMarkingSystem_();
}

uci::type::AlphanumericDashSpaceUnderscoreString40Type& MISP_PackingPlanType::getClassificationOrMarkingSystem() {
  return getClassificationOrMarkingSystem_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setClassificationOrMarkingSystem(const uci::type::AlphanumericDashSpaceUnderscoreString40Type& value) {
  return setClassificationOrMarkingSystem(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setClassificationOrMarkingSystem(const std::string& value) {
  return setClassificationOrMarkingSystem(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setClassificationOrMarkingSystem(const char* value) {
  enableClassificationOrMarkingSystem().setStringValue(value);
  return *this;
}

bool MISP_PackingPlanType::hasClassificationOrMarkingSystem() const noexcept {
  return static_cast<bool>(classificationOrMarkingSystem_Accessor);
}

uci::type::AlphanumericDashSpaceUnderscoreString40Type& MISP_PackingPlanType::enableClassificationOrMarkingSystem(uci::base::accessorType::AccessorType type) {
  if (!classificationOrMarkingSystem_Accessor) {
    classificationOrMarkingSystem_Accessor = AlphanumericDashSpaceUnderscoreString40Type::create(type);
  }
  return *classificationOrMarkingSystem_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearClassificationOrMarkingSystem() noexcept {
  classificationOrMarkingSystem_Accessor.reset();
  return *this;
}

uci::type::VisibleString480Type& MISP_PackingPlanType::getClassificationComment_() const {
  if (classificationComment_Accessor) {
    return *classificationComment_Accessor;
  }
  throw uci::base::UCIException("Error in getClassificationComment(): An attempt was made to get an optional field that was not enabled, call hasClassificationComment() to determine if it is safe to call getClassificationComment()");
}

const uci::type::VisibleString480Type& MISP_PackingPlanType::getClassificationComment() const {
  return getClassificationComment_();
}

uci::type::VisibleString480Type& MISP_PackingPlanType::getClassificationComment() {
  return getClassificationComment_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setClassificationComment(const uci::type::VisibleString480Type& value) {
  return setClassificationComment(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setClassificationComment(const std::string& value) {
  return setClassificationComment(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setClassificationComment(const char* value) {
  enableClassificationComment().setStringValue(value);
  return *this;
}

bool MISP_PackingPlanType::hasClassificationComment() const noexcept {
  return static_cast<bool>(classificationComment_Accessor);
}

uci::type::VisibleString480Type& MISP_PackingPlanType::enableClassificationComment(uci::base::accessorType::AccessorType type) {
  if (!classificationComment_Accessor) {
    classificationComment_Accessor = VisibleString480Type::create(type);
  }
  return *classificationComment_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearClassificationComment() noexcept {
  classificationComment_Accessor.reset();
  return *this;
}

uci::type::UMID_VideoID_Type& MISP_PackingPlanType::getUMID_VideoID_() const {
  if (uMID_VideoID_Accessor) {
    return *uMID_VideoID_Accessor;
  }
  throw uci::base::UCIException("Error in getUMID_VideoID(): An attempt was made to get an optional field that was not enabled, call hasUMID_VideoID() to determine if it is safe to call getUMID_VideoID()");
}

const uci::type::UMID_VideoID_Type& MISP_PackingPlanType::getUMID_VideoID() const {
  return getUMID_VideoID_();
}

uci::type::UMID_VideoID_Type& MISP_PackingPlanType::getUMID_VideoID() {
  return getUMID_VideoID_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setUMID_VideoID(const uci::type::UMID_VideoID_Type& accessor) {
  enableUMID_VideoID();
  if (&accessor != uMID_VideoID_Accessor.get()) {
    uMID_VideoID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MISP_PackingPlanType::hasUMID_VideoID() const noexcept {
  return static_cast<bool>(uMID_VideoID_Accessor);
}

uci::type::UMID_VideoID_Type& MISP_PackingPlanType::enableUMID_VideoID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::uMID_VideoID_Type : type};
  if ((!uMID_VideoID_Accessor) || (uMID_VideoID_Accessor->getAccessorType() != requestedType)) {
    uMID_VideoID_Accessor = UMID_VideoID_Type::create(requestedType);
    if (!uMID_VideoID_Accessor) {
      throw uci::base::UCIException("Error in enableUMID_VideoID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *uMID_VideoID_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearUMID_VideoID() noexcept {
  uMID_VideoID_Accessor.reset();
  return *this;
}

uci::type::UMID_AudioID_Type& MISP_PackingPlanType::getUMID_AudioID_() const {
  if (uMID_AudioID_Accessor) {
    return *uMID_AudioID_Accessor;
  }
  throw uci::base::UCIException("Error in getUMID_AudioID(): An attempt was made to get an optional field that was not enabled, call hasUMID_AudioID() to determine if it is safe to call getUMID_AudioID()");
}

const uci::type::UMID_AudioID_Type& MISP_PackingPlanType::getUMID_AudioID() const {
  return getUMID_AudioID_();
}

uci::type::UMID_AudioID_Type& MISP_PackingPlanType::getUMID_AudioID() {
  return getUMID_AudioID_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setUMID_AudioID(const uci::type::UMID_AudioID_Type& accessor) {
  enableUMID_AudioID();
  if (&accessor != uMID_AudioID_Accessor.get()) {
    uMID_AudioID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MISP_PackingPlanType::hasUMID_AudioID() const noexcept {
  return static_cast<bool>(uMID_AudioID_Accessor);
}

uci::type::UMID_AudioID_Type& MISP_PackingPlanType::enableUMID_AudioID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::uMID_AudioID_Type : type};
  if ((!uMID_AudioID_Accessor) || (uMID_AudioID_Accessor->getAccessorType() != requestedType)) {
    uMID_AudioID_Accessor = UMID_AudioID_Type::create(requestedType);
    if (!uMID_AudioID_Accessor) {
      throw uci::base::UCIException("Error in enableUMID_AudioID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *uMID_AudioID_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearUMID_AudioID() noexcept {
  uMID_AudioID_Accessor.reset();
  return *this;
}

uci::type::UMID_DataID_Type& MISP_PackingPlanType::getUMID_DataID_() const {
  if (uMID_DataID_Accessor) {
    return *uMID_DataID_Accessor;
  }
  throw uci::base::UCIException("Error in getUMID_DataID(): An attempt was made to get an optional field that was not enabled, call hasUMID_DataID() to determine if it is safe to call getUMID_DataID()");
}

const uci::type::UMID_DataID_Type& MISP_PackingPlanType::getUMID_DataID() const {
  return getUMID_DataID_();
}

uci::type::UMID_DataID_Type& MISP_PackingPlanType::getUMID_DataID() {
  return getUMID_DataID_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setUMID_DataID(const uci::type::UMID_DataID_Type& accessor) {
  enableUMID_DataID();
  if (&accessor != uMID_DataID_Accessor.get()) {
    uMID_DataID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MISP_PackingPlanType::hasUMID_DataID() const noexcept {
  return static_cast<bool>(uMID_DataID_Accessor);
}

uci::type::UMID_DataID_Type& MISP_PackingPlanType::enableUMID_DataID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::uMID_DataID_Type : type};
  if ((!uMID_DataID_Accessor) || (uMID_DataID_Accessor->getAccessorType() != requestedType)) {
    uMID_DataID_Accessor = UMID_DataID_Type::create(requestedType);
    if (!uMID_DataID_Accessor) {
      throw uci::base::UCIException("Error in enableUMID_DataID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *uMID_DataID_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearUMID_DataID() noexcept {
  uMID_DataID_Accessor.reset();
  return *this;
}

uci::type::UMID_SystemID_Type& MISP_PackingPlanType::getUMID_SystemID_() const {
  if (uMID_SystemID_Accessor) {
    return *uMID_SystemID_Accessor;
  }
  throw uci::base::UCIException("Error in getUMID_SystemID(): An attempt was made to get an optional field that was not enabled, call hasUMID_SystemID() to determine if it is safe to call getUMID_SystemID()");
}

const uci::type::UMID_SystemID_Type& MISP_PackingPlanType::getUMID_SystemID() const {
  return getUMID_SystemID_();
}

uci::type::UMID_SystemID_Type& MISP_PackingPlanType::getUMID_SystemID() {
  return getUMID_SystemID_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setUMID_SystemID(const uci::type::UMID_SystemID_Type& accessor) {
  enableUMID_SystemID();
  if (&accessor != uMID_SystemID_Accessor.get()) {
    uMID_SystemID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool MISP_PackingPlanType::hasUMID_SystemID() const noexcept {
  return static_cast<bool>(uMID_SystemID_Accessor);
}

uci::type::UMID_SystemID_Type& MISP_PackingPlanType::enableUMID_SystemID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::uMID_SystemID_Type : type};
  if ((!uMID_SystemID_Accessor) || (uMID_SystemID_Accessor->getAccessorType() != requestedType)) {
    uMID_SystemID_Accessor = UMID_SystemID_Type::create(requestedType);
    if (!uMID_SystemID_Accessor) {
      throw uci::base::UCIException("Error in enableUMID_SystemID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *uMID_SystemID_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearUMID_SystemID() noexcept {
  uMID_SystemID_Accessor.reset();
  return *this;
}

uci::type::AlphanumericDashSpaceUnderscoreString16Type& MISP_PackingPlanType::getItemDesignator_() const {
  if (itemDesignator_Accessor) {
    return *itemDesignator_Accessor;
  }
  throw uci::base::UCIException("Error in getItemDesignator(): An attempt was made to get an optional field that was not enabled, call hasItemDesignator() to determine if it is safe to call getItemDesignator()");
}

const uci::type::AlphanumericDashSpaceUnderscoreString16Type& MISP_PackingPlanType::getItemDesignator() const {
  return getItemDesignator_();
}

uci::type::AlphanumericDashSpaceUnderscoreString16Type& MISP_PackingPlanType::getItemDesignator() {
  return getItemDesignator_();
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setItemDesignator(const uci::type::AlphanumericDashSpaceUnderscoreString16Type& value) {
  return setItemDesignator(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setItemDesignator(const std::string& value) {
  return setItemDesignator(value.c_str());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::setItemDesignator(const char* value) {
  enableItemDesignator().setStringValue(value);
  return *this;
}

bool MISP_PackingPlanType::hasItemDesignator() const noexcept {
  return static_cast<bool>(itemDesignator_Accessor);
}

uci::type::AlphanumericDashSpaceUnderscoreString16Type& MISP_PackingPlanType::enableItemDesignator(uci::base::accessorType::AccessorType type) {
  if (!itemDesignator_Accessor) {
    itemDesignator_Accessor = AlphanumericDashSpaceUnderscoreString16Type::create(type);
  }
  return *itemDesignator_Accessor;
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::clearItemDesignator() noexcept {
  itemDesignator_Accessor.reset();
  return *this;
}

std::unique_ptr<MISP_PackingPlanType> MISP_PackingPlanType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::mISP_PackingPlanType : type};
  return (requestedType == uci::type::accessorType::mISP_PackingPlanType) ? boost::make_unique<MISP_PackingPlanType>() : nullptr;
}

/**  */
namespace MISP_PackingPlanType_Names {

constexpr const char* Extern_Type_Name{"MISP_PackingPlanType"};
constexpr const char* MissionID_Name{"MissionID"};
constexpr const char* PlatformDesignation_Name{"PlatformDesignation"};
constexpr const char* ImageSourceSensor_Name{"ImageSourceSensor"};
constexpr const char* PlatformTailNumber_Name{"PlatformTailNumber"};
constexpr const char* AirfieldBarometricPressure_Name{"AirfieldBarometricPressure"};
constexpr const char* AirFieldElevation_Name{"AirFieldElevation"};
constexpr const char* PlatformCallSign_Name{"PlatformCallSign"};
constexpr const char* OperationalMode_Name{"OperationalMode"};
constexpr const char* ClassificationOrMarkingSystem_Name{"ClassificationOrMarkingSystem"};
constexpr const char* ClassificationComment_Name{"ClassificationComment"};
constexpr const char* UMID_VideoID_Name{"UMID_VideoID"};
constexpr const char* UMID_AudioID_Name{"UMID_AudioID"};
constexpr const char* UMID_DataID_Name{"UMID_DataID"};
constexpr const char* UMID_SystemID_Name{"UMID_SystemID"};
constexpr const char* ItemDesignator_Name{"ItemDesignator"};

} // namespace MISP_PackingPlanType_Names

void MISP_PackingPlanType::deserialize(const boost::property_tree::ptree& propTree, uci::type::MISP_PackingPlanType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = MISP_PackingPlanType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::MissionID_Name) {
      MissionID_Type::deserialize(valueType.second, accessor.getMissionID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::PlatformDesignation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPlatformDesignation(*value);
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::ImageSourceSensor_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setImageSourceSensor(*value);
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::PlatformTailNumber_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPlatformTailNumber(*value);
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::AirfieldBarometricPressure_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAirfieldBarometricPressure(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::AirFieldElevation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setAirFieldElevation(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::PlatformCallSign_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPlatformCallSign(*value);
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::OperationalMode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableOperationalMode().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::ClassificationOrMarkingSystem_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setClassificationOrMarkingSystem(*value);
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::ClassificationComment_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setClassificationComment(*value);
      }
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::UMID_VideoID_Name) {
      UMID_VideoID_Type::deserialize(valueType.second, accessor.enableUMID_VideoID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::UMID_AudioID_Name) {
      UMID_AudioID_Type::deserialize(valueType.second, accessor.enableUMID_AudioID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::UMID_DataID_Name) {
      UMID_DataID_Type::deserialize(valueType.second, accessor.enableUMID_DataID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::UMID_SystemID_Name) {
      UMID_SystemID_Type::deserialize(valueType.second, accessor.enableUMID_SystemID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + MISP_PackingPlanType_Names::ItemDesignator_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setItemDesignator(*value);
      }
    }
  }
}

std::string MISP_PackingPlanType::serialize(const uci::type::MISP_PackingPlanType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? MISP_PackingPlanType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, MISP_PackingPlanType_Names::Extern_Type_Name);
  }
  MissionID_Type::serialize(accessor.getMissionID(), node, MISP_PackingPlanType_Names::MissionID_Name);
  asb_uci::util::SerializationHelpers::serializeString(accessor.getPlatformDesignation(), node, MISP_PackingPlanType_Names::PlatformDesignation_Name);
  asb_uci::util::SerializationHelpers::serializeString(accessor.getImageSourceSensor(), node, MISP_PackingPlanType_Names::ImageSourceSensor_Name);
  if (accessor.hasPlatformTailNumber()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getPlatformTailNumber(), node, MISP_PackingPlanType_Names::PlatformTailNumber_Name);
  }
  if (accessor.hasAirfieldBarometricPressure()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getAirfieldBarometricPressure(), node, MISP_PackingPlanType_Names::AirfieldBarometricPressure_Name);
  }
  if (accessor.hasAirFieldElevation()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getAirFieldElevation(), node, MISP_PackingPlanType_Names::AirFieldElevation_Name);
  }
  if (accessor.hasPlatformCallSign()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getPlatformCallSign(), node, MISP_PackingPlanType_Names::PlatformCallSign_Name);
  }
  if (accessor.hasOperationalMode()) {
    MISP_OperationalModeEnum::serialize(accessor.getOperationalMode(), node, MISP_PackingPlanType_Names::OperationalMode_Name, false);
  }
  if (accessor.hasClassificationOrMarkingSystem()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getClassificationOrMarkingSystem(), node, MISP_PackingPlanType_Names::ClassificationOrMarkingSystem_Name);
  }
  if (accessor.hasClassificationComment()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getClassificationComment(), node, MISP_PackingPlanType_Names::ClassificationComment_Name);
  }
  if (accessor.hasUMID_VideoID()) {
    UMID_VideoID_Type::serialize(accessor.getUMID_VideoID(), node, MISP_PackingPlanType_Names::UMID_VideoID_Name);
  }
  if (accessor.hasUMID_AudioID()) {
    UMID_AudioID_Type::serialize(accessor.getUMID_AudioID(), node, MISP_PackingPlanType_Names::UMID_AudioID_Name);
  }
  if (accessor.hasUMID_DataID()) {
    UMID_DataID_Type::serialize(accessor.getUMID_DataID(), node, MISP_PackingPlanType_Names::UMID_DataID_Name);
  }
  if (accessor.hasUMID_SystemID()) {
    UMID_SystemID_Type::serialize(accessor.getUMID_SystemID(), node, MISP_PackingPlanType_Names::UMID_SystemID_Name);
  }
  if (accessor.hasItemDesignator()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getItemDesignator(), node, MISP_PackingPlanType_Names::ItemDesignator_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::MISP_PackingPlanType>().release());
}

uci::type::MISP_PackingPlanType& MISP_PackingPlanType::create(const uci::type::MISP_PackingPlanType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::MISP_PackingPlanType> newAccessor{boost::make_unique<asb_uci::type::MISP_PackingPlanType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void MISP_PackingPlanType::destroy(uci::type::MISP_PackingPlanType& accessor) {
  delete dynamic_cast<asb_uci::type::MISP_PackingPlanType*>(&accessor);
}

} // namespace type

} // namespace uci

