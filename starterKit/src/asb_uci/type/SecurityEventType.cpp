/** @file SecurityEventType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/SecurityEventType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/SecurityAccessType.h"
#include "../../../include/asb_uci/type/SecurityAuditManagementType.h"
#include "../../../include/asb_uci/type/SecurityAuthenticationType.h"
#include "../../../include/asb_uci/type/SecurityFileManagementType.h"
#include "../../../include/asb_uci/type/SecurityIntegrityType.h"
#include "../../../include/asb_uci/type/SecurityIntrusionDetectionType.h"
#include "../../../include/asb_uci/type/SecurityKeyManagementType.h"
#include "../../../include/asb_uci/type/SecurityPolicyManagementType.h"
#include "../../../include/asb_uci/type/SecuritySanitizationType.h"
#include "../../../include/asb_uci/type/SecuritySystemType.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityAccessType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityAuditManagementType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityAuthenticationType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityEventType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityFileManagementType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityIntegrityType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityIntrusionDetectionType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityKeyManagementType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecurityPolicyManagementType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecuritySanitizationType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SecuritySystemType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

SecurityEventType::SecurityEventType() = default;

SecurityEventType::~SecurityEventType() = default;

void SecurityEventType::copy(const uci::type::SecurityEventType& accessor) {
  copyImpl(accessor, false);
}

void SecurityEventType::copyImpl(const uci::type::SecurityEventType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const SecurityEventType&>(accessor);
    if (accessorImpl.accountAccess_Accessor) {
      setAccountAccess(*(accessorImpl.accountAccess_Accessor));
    } else {
      accountAccess_Accessor.reset();
    }
    if (accessorImpl.authentication_Accessor) {
      setAuthentication(*(accessorImpl.authentication_Accessor));
    } else {
      authentication_Accessor.reset();
    }
    if (accessorImpl.integrity_Accessor) {
      setIntegrity(*(accessorImpl.integrity_Accessor));
    } else {
      integrity_Accessor.reset();
    }
    if (accessorImpl.auditManagement_Accessor) {
      setAuditManagement(*(accessorImpl.auditManagement_Accessor));
    } else {
      auditManagement_Accessor.reset();
    }
    if (accessorImpl.fileManagement_Accessor) {
      setFileManagement(*(accessorImpl.fileManagement_Accessor));
    } else {
      fileManagement_Accessor.reset();
    }
    if (accessorImpl.keyManagement_Accessor) {
      setKeyManagement(*(accessorImpl.keyManagement_Accessor));
    } else {
      keyManagement_Accessor.reset();
    }
    if (accessorImpl.policyManagement_Accessor) {
      setPolicyManagement(*(accessorImpl.policyManagement_Accessor));
    } else {
      policyManagement_Accessor.reset();
    }
    if (accessorImpl.system_Accessor) {
      setSystem(*(accessorImpl.system_Accessor));
    } else {
      system_Accessor.reset();
    }
    if (accessorImpl.intrusionDetection_Accessor) {
      setIntrusionDetection(*(accessorImpl.intrusionDetection_Accessor));
    } else {
      intrusionDetection_Accessor.reset();
    }
    if (accessorImpl.sanitization_Accessor) {
      setSanitization(*(accessorImpl.sanitization_Accessor));
    } else {
      sanitization_Accessor.reset();
    }
  }
}

void SecurityEventType::reset() noexcept {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
}

uci::type::SecurityEventType::SecurityEventTypeChoice SecurityEventType::getSecurityEventTypeChoiceOrdinal() const noexcept {
  if (accountAccess_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_ACCOUNTACCESS;
  }
  if (authentication_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_AUTHENTICATION;
  }
  if (integrity_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_INTEGRITY;
  }
  if (auditManagement_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_AUDITMANAGEMENT;
  }
  if (fileManagement_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_FILEMANAGEMENT;
  }
  if (keyManagement_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_KEYMANAGEMENT;
  }
  if (policyManagement_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_POLICYMANAGEMENT;
  }
  if (system_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_SYSTEM;
  }
  if (intrusionDetection_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_INTRUSIONDETECTION;
  }
  if (sanitization_Accessor) {
    return SECURITYEVENTTYPE_CHOICE_SANITIZATION;
  }
  return SECURITYEVENTTYPE_CHOICE_NONE;
}

uci::type::SecurityEventType& SecurityEventType::setSecurityEventTypeChoiceOrdinal(uci::type::SecurityEventType::SecurityEventTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case SECURITYEVENTTYPE_CHOICE_ACCOUNTACCESS:
      chooseAccountAccess("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_AUTHENTICATION:
      chooseAuthentication("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_INTEGRITY:
      chooseIntegrity("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_AUDITMANAGEMENT:
      chooseAuditManagement("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_FILEMANAGEMENT:
      chooseFileManagement("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_KEYMANAGEMENT:
      chooseKeyManagement("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_POLICYMANAGEMENT:
      choosePolicyManagement("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_SYSTEM:
      chooseSystem("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_INTRUSIONDETECTION:
      chooseIntrusionDetection("setSecurityEventTypeChoiceOrdinal", type);
      break;
    case SECURITYEVENTTYPE_CHOICE_SANITIZATION:
      chooseSanitization("setSecurityEventTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setSecurityEventTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::SecurityAccessType& SecurityEventType::getAccountAccess_() const {
  if (accountAccess_Accessor) {
    return *accountAccess_Accessor;
  }
  throw uci::base::UCIException("Error in getAccountAccess(): Unable to get AccountAccess, field not selected");
}

const uci::type::SecurityAccessType& SecurityEventType::getAccountAccess() const {
  return getAccountAccess_();
}

uci::type::SecurityAccessType& SecurityEventType::getAccountAccess() {
  return getAccountAccess_();
}

uci::type::SecurityEventType& SecurityEventType::setAccountAccess(const uci::type::SecurityAccessType& accessor) {
  chooseAccountAccess();
  if (&accessor != accountAccess_Accessor.get()) {
    accountAccess_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isAccountAccess() const noexcept {
  return static_cast<bool>(accountAccess_Accessor);
}

uci::type::SecurityAccessType& SecurityEventType::chooseAccountAccess(const std::string& method, uci::base::accessorType::AccessorType type) {
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityAccessType : type};
  if ((!accountAccess_Accessor) || (accountAccess_Accessor->getAccessorType() != requestedType)) {
    accountAccess_Accessor = SecurityAccessType::create(type);
    if (!accountAccess_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *accountAccess_Accessor;
}

uci::type::SecurityAccessType& SecurityEventType::chooseAccountAccess(uci::base::accessorType::AccessorType type) {
  return chooseAccountAccess("chooseAccountAccess", type);
}

uci::type::SecurityAuthenticationType& SecurityEventType::getAuthentication_() const {
  if (authentication_Accessor) {
    return *authentication_Accessor;
  }
  throw uci::base::UCIException("Error in getAuthentication(): Unable to get Authentication, field not selected");
}

const uci::type::SecurityAuthenticationType& SecurityEventType::getAuthentication() const {
  return getAuthentication_();
}

uci::type::SecurityAuthenticationType& SecurityEventType::getAuthentication() {
  return getAuthentication_();
}

uci::type::SecurityEventType& SecurityEventType::setAuthentication(const uci::type::SecurityAuthenticationType& accessor) {
  chooseAuthentication();
  if (&accessor != authentication_Accessor.get()) {
    authentication_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isAuthentication() const noexcept {
  return static_cast<bool>(authentication_Accessor);
}

uci::type::SecurityAuthenticationType& SecurityEventType::chooseAuthentication(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityAuthenticationType : type};
  if ((!authentication_Accessor) || (authentication_Accessor->getAccessorType() != requestedType)) {
    authentication_Accessor = SecurityAuthenticationType::create(type);
    if (!authentication_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *authentication_Accessor;
}

uci::type::SecurityAuthenticationType& SecurityEventType::chooseAuthentication(uci::base::accessorType::AccessorType type) {
  return chooseAuthentication("chooseAuthentication", type);
}

uci::type::SecurityIntegrityType& SecurityEventType::getIntegrity_() const {
  if (integrity_Accessor) {
    return *integrity_Accessor;
  }
  throw uci::base::UCIException("Error in getIntegrity(): Unable to get Integrity, field not selected");
}

const uci::type::SecurityIntegrityType& SecurityEventType::getIntegrity() const {
  return getIntegrity_();
}

uci::type::SecurityIntegrityType& SecurityEventType::getIntegrity() {
  return getIntegrity_();
}

uci::type::SecurityEventType& SecurityEventType::setIntegrity(const uci::type::SecurityIntegrityType& accessor) {
  chooseIntegrity();
  if (&accessor != integrity_Accessor.get()) {
    integrity_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isIntegrity() const noexcept {
  return static_cast<bool>(integrity_Accessor);
}

uci::type::SecurityIntegrityType& SecurityEventType::chooseIntegrity(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityIntegrityType : type};
  if ((!integrity_Accessor) || (integrity_Accessor->getAccessorType() != requestedType)) {
    integrity_Accessor = SecurityIntegrityType::create(type);
    if (!integrity_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *integrity_Accessor;
}

uci::type::SecurityIntegrityType& SecurityEventType::chooseIntegrity(uci::base::accessorType::AccessorType type) {
  return chooseIntegrity("chooseIntegrity", type);
}

uci::type::SecurityAuditManagementType& SecurityEventType::getAuditManagement_() const {
  if (auditManagement_Accessor) {
    return *auditManagement_Accessor;
  }
  throw uci::base::UCIException("Error in getAuditManagement(): Unable to get AuditManagement, field not selected");
}

const uci::type::SecurityAuditManagementType& SecurityEventType::getAuditManagement() const {
  return getAuditManagement_();
}

uci::type::SecurityAuditManagementType& SecurityEventType::getAuditManagement() {
  return getAuditManagement_();
}

uci::type::SecurityEventType& SecurityEventType::setAuditManagement(const uci::type::SecurityAuditManagementType& accessor) {
  chooseAuditManagement();
  if (&accessor != auditManagement_Accessor.get()) {
    auditManagement_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isAuditManagement() const noexcept {
  return static_cast<bool>(auditManagement_Accessor);
}

uci::type::SecurityAuditManagementType& SecurityEventType::chooseAuditManagement(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityAuditManagementType : type};
  if ((!auditManagement_Accessor) || (auditManagement_Accessor->getAccessorType() != requestedType)) {
    auditManagement_Accessor = SecurityAuditManagementType::create(type);
    if (!auditManagement_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *auditManagement_Accessor;
}

uci::type::SecurityAuditManagementType& SecurityEventType::chooseAuditManagement(uci::base::accessorType::AccessorType type) {
  return chooseAuditManagement("chooseAuditManagement", type);
}

uci::type::SecurityFileManagementType& SecurityEventType::getFileManagement_() const {
  if (fileManagement_Accessor) {
    return *fileManagement_Accessor;
  }
  throw uci::base::UCIException("Error in getFileManagement(): Unable to get FileManagement, field not selected");
}

const uci::type::SecurityFileManagementType& SecurityEventType::getFileManagement() const {
  return getFileManagement_();
}

uci::type::SecurityFileManagementType& SecurityEventType::getFileManagement() {
  return getFileManagement_();
}

uci::type::SecurityEventType& SecurityEventType::setFileManagement(const uci::type::SecurityFileManagementType& accessor) {
  chooseFileManagement();
  if (&accessor != fileManagement_Accessor.get()) {
    fileManagement_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isFileManagement() const noexcept {
  return static_cast<bool>(fileManagement_Accessor);
}

uci::type::SecurityFileManagementType& SecurityEventType::chooseFileManagement(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityFileManagementType : type};
  if ((!fileManagement_Accessor) || (fileManagement_Accessor->getAccessorType() != requestedType)) {
    fileManagement_Accessor = SecurityFileManagementType::create(type);
    if (!fileManagement_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *fileManagement_Accessor;
}

uci::type::SecurityFileManagementType& SecurityEventType::chooseFileManagement(uci::base::accessorType::AccessorType type) {
  return chooseFileManagement("chooseFileManagement", type);
}

uci::type::SecurityKeyManagementType& SecurityEventType::getKeyManagement_() const {
  if (keyManagement_Accessor) {
    return *keyManagement_Accessor;
  }
  throw uci::base::UCIException("Error in getKeyManagement(): Unable to get KeyManagement, field not selected");
}

const uci::type::SecurityKeyManagementType& SecurityEventType::getKeyManagement() const {
  return getKeyManagement_();
}

uci::type::SecurityKeyManagementType& SecurityEventType::getKeyManagement() {
  return getKeyManagement_();
}

uci::type::SecurityEventType& SecurityEventType::setKeyManagement(const uci::type::SecurityKeyManagementType& accessor) {
  chooseKeyManagement();
  if (&accessor != keyManagement_Accessor.get()) {
    keyManagement_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isKeyManagement() const noexcept {
  return static_cast<bool>(keyManagement_Accessor);
}

uci::type::SecurityKeyManagementType& SecurityEventType::chooseKeyManagement(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityKeyManagementType : type};
  if ((!keyManagement_Accessor) || (keyManagement_Accessor->getAccessorType() != requestedType)) {
    keyManagement_Accessor = SecurityKeyManagementType::create(type);
    if (!keyManagement_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *keyManagement_Accessor;
}

uci::type::SecurityKeyManagementType& SecurityEventType::chooseKeyManagement(uci::base::accessorType::AccessorType type) {
  return chooseKeyManagement("chooseKeyManagement", type);
}

uci::type::SecurityPolicyManagementType& SecurityEventType::getPolicyManagement_() const {
  if (policyManagement_Accessor) {
    return *policyManagement_Accessor;
  }
  throw uci::base::UCIException("Error in getPolicyManagement(): Unable to get PolicyManagement, field not selected");
}

const uci::type::SecurityPolicyManagementType& SecurityEventType::getPolicyManagement() const {
  return getPolicyManagement_();
}

uci::type::SecurityPolicyManagementType& SecurityEventType::getPolicyManagement() {
  return getPolicyManagement_();
}

uci::type::SecurityEventType& SecurityEventType::setPolicyManagement(const uci::type::SecurityPolicyManagementType& accessor) {
  choosePolicyManagement();
  if (&accessor != policyManagement_Accessor.get()) {
    policyManagement_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isPolicyManagement() const noexcept {
  return static_cast<bool>(policyManagement_Accessor);
}

uci::type::SecurityPolicyManagementType& SecurityEventType::choosePolicyManagement(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityPolicyManagementType : type};
  if ((!policyManagement_Accessor) || (policyManagement_Accessor->getAccessorType() != requestedType)) {
    policyManagement_Accessor = SecurityPolicyManagementType::create(type);
    if (!policyManagement_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *policyManagement_Accessor;
}

uci::type::SecurityPolicyManagementType& SecurityEventType::choosePolicyManagement(uci::base::accessorType::AccessorType type) {
  return choosePolicyManagement("choosePolicyManagement", type);
}

uci::type::SecuritySystemType& SecurityEventType::getSystem_() const {
  if (system_Accessor) {
    return *system_Accessor;
  }
  throw uci::base::UCIException("Error in getSystem(): Unable to get System, field not selected");
}

const uci::type::SecuritySystemType& SecurityEventType::getSystem() const {
  return getSystem_();
}

uci::type::SecuritySystemType& SecurityEventType::getSystem() {
  return getSystem_();
}

uci::type::SecurityEventType& SecurityEventType::setSystem(const uci::type::SecuritySystemType& accessor) {
  chooseSystem();
  if (&accessor != system_Accessor.get()) {
    system_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isSystem() const noexcept {
  return static_cast<bool>(system_Accessor);
}

uci::type::SecuritySystemType& SecurityEventType::chooseSystem(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  intrusionDetection_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securitySystemType : type};
  if ((!system_Accessor) || (system_Accessor->getAccessorType() != requestedType)) {
    system_Accessor = SecuritySystemType::create(type);
    if (!system_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *system_Accessor;
}

uci::type::SecuritySystemType& SecurityEventType::chooseSystem(uci::base::accessorType::AccessorType type) {
  return chooseSystem("chooseSystem", type);
}

uci::type::SecurityIntrusionDetectionType& SecurityEventType::getIntrusionDetection_() const {
  if (intrusionDetection_Accessor) {
    return *intrusionDetection_Accessor;
  }
  throw uci::base::UCIException("Error in getIntrusionDetection(): Unable to get IntrusionDetection, field not selected");
}

const uci::type::SecurityIntrusionDetectionType& SecurityEventType::getIntrusionDetection() const {
  return getIntrusionDetection_();
}

uci::type::SecurityIntrusionDetectionType& SecurityEventType::getIntrusionDetection() {
  return getIntrusionDetection_();
}

uci::type::SecurityEventType& SecurityEventType::setIntrusionDetection(const uci::type::SecurityIntrusionDetectionType& accessor) {
  chooseIntrusionDetection();
  if (&accessor != intrusionDetection_Accessor.get()) {
    intrusionDetection_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isIntrusionDetection() const noexcept {
  return static_cast<bool>(intrusionDetection_Accessor);
}

uci::type::SecurityIntrusionDetectionType& SecurityEventType::chooseIntrusionDetection(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  sanitization_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityIntrusionDetectionType : type};
  if ((!intrusionDetection_Accessor) || (intrusionDetection_Accessor->getAccessorType() != requestedType)) {
    intrusionDetection_Accessor = SecurityIntrusionDetectionType::create(type);
    if (!intrusionDetection_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *intrusionDetection_Accessor;
}

uci::type::SecurityIntrusionDetectionType& SecurityEventType::chooseIntrusionDetection(uci::base::accessorType::AccessorType type) {
  return chooseIntrusionDetection("chooseIntrusionDetection", type);
}

uci::type::SecuritySanitizationType& SecurityEventType::getSanitization_() const {
  if (sanitization_Accessor) {
    return *sanitization_Accessor;
  }
  throw uci::base::UCIException("Error in getSanitization(): Unable to get Sanitization, field not selected");
}

const uci::type::SecuritySanitizationType& SecurityEventType::getSanitization() const {
  return getSanitization_();
}

uci::type::SecuritySanitizationType& SecurityEventType::getSanitization() {
  return getSanitization_();
}

uci::type::SecurityEventType& SecurityEventType::setSanitization(const uci::type::SecuritySanitizationType& accessor) {
  chooseSanitization();
  if (&accessor != sanitization_Accessor.get()) {
    sanitization_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SecurityEventType::isSanitization() const noexcept {
  return static_cast<bool>(sanitization_Accessor);
}

uci::type::SecuritySanitizationType& SecurityEventType::chooseSanitization(const std::string& method, uci::base::accessorType::AccessorType type) {
  accountAccess_Accessor.reset();
  authentication_Accessor.reset();
  integrity_Accessor.reset();
  auditManagement_Accessor.reset();
  fileManagement_Accessor.reset();
  keyManagement_Accessor.reset();
  policyManagement_Accessor.reset();
  system_Accessor.reset();
  intrusionDetection_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securitySanitizationType : type};
  if ((!sanitization_Accessor) || (sanitization_Accessor->getAccessorType() != requestedType)) {
    sanitization_Accessor = SecuritySanitizationType::create(type);
    if (!sanitization_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *sanitization_Accessor;
}

uci::type::SecuritySanitizationType& SecurityEventType::chooseSanitization(uci::base::accessorType::AccessorType type) {
  return chooseSanitization("chooseSanitization", type);
}

std::unique_ptr<SecurityEventType> SecurityEventType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityEventType : type};
  return (requestedType == uci::type::accessorType::securityEventType) ? boost::make_unique<SecurityEventType>() : nullptr;
}

/**  */
namespace SecurityEventType_Names {

constexpr const char* Extern_Type_Name{"SecurityEventType"};
constexpr const char* AccountAccess_Name{"AccountAccess"};
constexpr const char* Authentication_Name{"Authentication"};
constexpr const char* Integrity_Name{"Integrity"};
constexpr const char* AuditManagement_Name{"AuditManagement"};
constexpr const char* FileManagement_Name{"FileManagement"};
constexpr const char* KeyManagement_Name{"KeyManagement"};
constexpr const char* PolicyManagement_Name{"PolicyManagement"};
constexpr const char* System_Name{"System"};
constexpr const char* IntrusionDetection_Name{"IntrusionDetection"};
constexpr const char* Sanitization_Name{"Sanitization"};

} // namespace SecurityEventType_Names

void SecurityEventType::deserialize(const boost::property_tree::ptree& propTree, uci::type::SecurityEventType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = SecurityEventType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::AccountAccess_Name) {
      SecurityAccessType::deserialize(valueType.second, accessor.chooseAccountAccess(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::Authentication_Name) {
      SecurityAuthenticationType::deserialize(valueType.second, accessor.chooseAuthentication(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::Integrity_Name) {
      SecurityIntegrityType::deserialize(valueType.second, accessor.chooseIntegrity(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::AuditManagement_Name) {
      SecurityAuditManagementType::deserialize(valueType.second, accessor.chooseAuditManagement(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::FileManagement_Name) {
      SecurityFileManagementType::deserialize(valueType.second, accessor.chooseFileManagement(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::KeyManagement_Name) {
      SecurityKeyManagementType::deserialize(valueType.second, accessor.chooseKeyManagement(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::PolicyManagement_Name) {
      SecurityPolicyManagementType::deserialize(valueType.second, accessor.choosePolicyManagement(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::System_Name) {
      SecuritySystemType::deserialize(valueType.second, accessor.chooseSystem(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::IntrusionDetection_Name) {
      SecurityIntrusionDetectionType::deserialize(valueType.second, accessor.chooseIntrusionDetection(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityEventType_Names::Sanitization_Name) {
      SecuritySanitizationType::deserialize(valueType.second, accessor.chooseSanitization(), nodeName, nsPrefix);
    }
  }
}

std::string SecurityEventType::serialize(const uci::type::SecurityEventType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? SecurityEventType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, SecurityEventType_Names::Extern_Type_Name);
  }
  if (accessor.isAccountAccess()) {
    SecurityAccessType::serialize(accessor.getAccountAccess(), node, SecurityEventType_Names::AccountAccess_Name);
  } else if (accessor.isAuthentication()) {
    SecurityAuthenticationType::serialize(accessor.getAuthentication(), node, SecurityEventType_Names::Authentication_Name);
  } else if (accessor.isIntegrity()) {
    SecurityIntegrityType::serialize(accessor.getIntegrity(), node, SecurityEventType_Names::Integrity_Name);
  } else if (accessor.isAuditManagement()) {
    SecurityAuditManagementType::serialize(accessor.getAuditManagement(), node, SecurityEventType_Names::AuditManagement_Name);
  } else if (accessor.isFileManagement()) {
    SecurityFileManagementType::serialize(accessor.getFileManagement(), node, SecurityEventType_Names::FileManagement_Name);
  } else if (accessor.isKeyManagement()) {
    SecurityKeyManagementType::serialize(accessor.getKeyManagement(), node, SecurityEventType_Names::KeyManagement_Name);
  } else if (accessor.isPolicyManagement()) {
    SecurityPolicyManagementType::serialize(accessor.getPolicyManagement(), node, SecurityEventType_Names::PolicyManagement_Name);
  } else if (accessor.isSystem()) {
    SecuritySystemType::serialize(accessor.getSystem(), node, SecurityEventType_Names::System_Name);
  } else if (accessor.isIntrusionDetection()) {
    SecurityIntrusionDetectionType::serialize(accessor.getIntrusionDetection(), node, SecurityEventType_Names::IntrusionDetection_Name);
  } else if (accessor.isSanitization()) {
    SecuritySanitizationType::serialize(accessor.getSanitization(), node, SecurityEventType_Names::Sanitization_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::SecurityEventType& SecurityEventType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::SecurityEventType>().release());
}

uci::type::SecurityEventType& SecurityEventType::create(const uci::type::SecurityEventType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::SecurityEventType> newAccessor{boost::make_unique<asb_uci::type::SecurityEventType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void SecurityEventType::destroy(uci::type::SecurityEventType& accessor) {
  delete dynamic_cast<asb_uci::type::SecurityEventType*>(&accessor);
}

} // namespace type

} // namespace uci

