/** @file FuzeType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/FuzeType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/FuzeTriggerType.h"
#include "asb_uci/type/VisibleString1024Type.h"
#include "asb_uci/type/WeaponFuzeModeEnum.h"
#include "asb_uci/type/WeaponFuzePositionEnum.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/DurationType.h"
#include "uci/type/FuzeTriggerType.h"
#include "uci/type/FuzeType.h"
#include "uci/type/VisibleString1024Type.h"
#include "uci/type/WeaponFuzeModeEnum.h"
#include "uci/type/WeaponFuzePositionEnum.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

FuzeType::FuzeType()
  : fuzeTrigger_Accessor{boost::make_unique<FuzeTriggerType>()} {
}

FuzeType::~FuzeType() = default;

void FuzeType::copy(const uci::type::FuzeType& accessor) {
  copyImpl(accessor, false);
}

void FuzeType::copyImpl(const uci::type::FuzeType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const FuzeType&>(accessor);
    setFuzeTrigger(*(accessorImpl.fuzeTrigger_Accessor));
    if (accessorImpl.fuzeMode_Accessor) {
      setFuzeMode(*(accessorImpl.fuzeMode_Accessor));
    } else {
      fuzeMode_Accessor.reset();
    }
    if (accessorImpl.fuzePosition_Accessor) {
      setFuzePosition(*(accessorImpl.fuzePosition_Accessor));
    } else {
      fuzePosition_Accessor.reset();
    }
    if (accessorImpl.mnemonic_Accessor) {
      setMnemonic(*(accessorImpl.mnemonic_Accessor));
    } else {
      mnemonic_Accessor.reset();
    }
    if (accessorImpl.hasFuzeSeparationArmTime()) {
      setFuzeSeparationArmTime(accessorImpl.getFuzeSeparationArmTime());
    } else {
      clearFuzeSeparationArmTime();
    }
  }
}

void FuzeType::reset() noexcept {
  fuzeTrigger_Accessor->reset();
  fuzeMode_Accessor.reset();
  fuzePosition_Accessor.reset();
  mnemonic_Accessor.reset();
  clearFuzeSeparationArmTime();
}

const uci::type::FuzeTriggerType& FuzeType::getFuzeTrigger() const {
  return *fuzeTrigger_Accessor;
}

uci::type::FuzeTriggerType& FuzeType::getFuzeTrigger() {
  return *fuzeTrigger_Accessor;
}

uci::type::FuzeType& FuzeType::setFuzeTrigger(const uci::type::FuzeTriggerType& accessor) {
  if (&accessor != fuzeTrigger_Accessor.get()) {
    fuzeTrigger_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeaponFuzeModeEnum& FuzeType::getFuzeMode_() const {
  if (fuzeMode_Accessor) {
    return *fuzeMode_Accessor;
  }
  throw uci::base::UCIException("Error in getFuzeMode(): An attempt was made to get an optional field that was not enabled, call hasFuzeMode() to determine if it is safe to call getFuzeMode()");
}

const uci::type::WeaponFuzeModeEnum& FuzeType::getFuzeMode() const {
  return getFuzeMode_();
}

uci::type::WeaponFuzeModeEnum& FuzeType::getFuzeMode() {
  return getFuzeMode_();
}

uci::type::FuzeType& FuzeType::setFuzeMode(const uci::type::WeaponFuzeModeEnum& accessor) {
  enableFuzeMode();
  if (&accessor != fuzeMode_Accessor.get()) {
    fuzeMode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::FuzeType& FuzeType::setFuzeMode(const uci::type::WeaponFuzeModeEnum::EnumerationItem value) {
  enableFuzeMode().setValue(value);
  return *this;
}

bool FuzeType::hasFuzeMode() const noexcept {
  return static_cast<bool>(fuzeMode_Accessor);
}

uci::type::WeaponFuzeModeEnum& FuzeType::enableFuzeMode(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weaponFuzeModeEnum : type};
  if ((!fuzeMode_Accessor) || (fuzeMode_Accessor->getAccessorType() != requestedType)) {
    fuzeMode_Accessor = WeaponFuzeModeEnum::create(requestedType);
    if (!fuzeMode_Accessor) {
      throw uci::base::UCIException("Error in enableFuzeMode(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *fuzeMode_Accessor;
}

uci::type::FuzeType& FuzeType::clearFuzeMode() noexcept {
  fuzeMode_Accessor.reset();
  return *this;
}

uci::type::WeaponFuzePositionEnum& FuzeType::getFuzePosition_() const {
  if (fuzePosition_Accessor) {
    return *fuzePosition_Accessor;
  }
  throw uci::base::UCIException("Error in getFuzePosition(): An attempt was made to get an optional field that was not enabled, call hasFuzePosition() to determine if it is safe to call getFuzePosition()");
}

const uci::type::WeaponFuzePositionEnum& FuzeType::getFuzePosition() const {
  return getFuzePosition_();
}

uci::type::WeaponFuzePositionEnum& FuzeType::getFuzePosition() {
  return getFuzePosition_();
}

uci::type::FuzeType& FuzeType::setFuzePosition(const uci::type::WeaponFuzePositionEnum& accessor) {
  enableFuzePosition();
  if (&accessor != fuzePosition_Accessor.get()) {
    fuzePosition_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::FuzeType& FuzeType::setFuzePosition(const uci::type::WeaponFuzePositionEnum::EnumerationItem value) {
  enableFuzePosition().setValue(value);
  return *this;
}

bool FuzeType::hasFuzePosition() const noexcept {
  return static_cast<bool>(fuzePosition_Accessor);
}

uci::type::WeaponFuzePositionEnum& FuzeType::enableFuzePosition(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weaponFuzePositionEnum : type};
  if ((!fuzePosition_Accessor) || (fuzePosition_Accessor->getAccessorType() != requestedType)) {
    fuzePosition_Accessor = WeaponFuzePositionEnum::create(requestedType);
    if (!fuzePosition_Accessor) {
      throw uci::base::UCIException("Error in enableFuzePosition(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *fuzePosition_Accessor;
}

uci::type::FuzeType& FuzeType::clearFuzePosition() noexcept {
  fuzePosition_Accessor.reset();
  return *this;
}

uci::type::VisibleString1024Type& FuzeType::getMnemonic_() const {
  if (mnemonic_Accessor) {
    return *mnemonic_Accessor;
  }
  throw uci::base::UCIException("Error in getMnemonic(): An attempt was made to get an optional field that was not enabled, call hasMnemonic() to determine if it is safe to call getMnemonic()");
}

const uci::type::VisibleString1024Type& FuzeType::getMnemonic() const {
  return getMnemonic_();
}

uci::type::VisibleString1024Type& FuzeType::getMnemonic() {
  return getMnemonic_();
}

uci::type::FuzeType& FuzeType::setMnemonic(const uci::type::VisibleString1024Type& value) {
  return setMnemonic(value.c_str());
}

uci::type::FuzeType& FuzeType::setMnemonic(const std::string& value) {
  return setMnemonic(value.c_str());
}

uci::type::FuzeType& FuzeType::setMnemonic(const char* value) {
  enableMnemonic().setStringValue(value);
  return *this;
}

bool FuzeType::hasMnemonic() const noexcept {
  return static_cast<bool>(mnemonic_Accessor);
}

uci::type::VisibleString1024Type& FuzeType::enableMnemonic(uci::base::accessorType::AccessorType type) {
  if (!mnemonic_Accessor) {
    mnemonic_Accessor = VisibleString1024Type::create(type);
  }
  return *mnemonic_Accessor;
}

uci::type::FuzeType& FuzeType::clearMnemonic() noexcept {
  mnemonic_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue FuzeType::getFuzeSeparationArmTime() const {
  if (fuzeSeparationArmTime_Accessor) {
    return *fuzeSeparationArmTime_Accessor;
  }
  throw uci::base::UCIException("Error in getFuzeSeparationArmTime(): An attempt was made to get an optional field that was not enabled, call hasFuzeSeparationArmTime() to determine if it is safe to call getFuzeSeparationArmTime()");
}

uci::type::FuzeType& FuzeType::setFuzeSeparationArmTime(uci::type::DurationTypeValue value) {
  fuzeSeparationArmTime_Accessor = value;
  return *this;
}

bool FuzeType::hasFuzeSeparationArmTime() const noexcept {
  return fuzeSeparationArmTime_Accessor.has_value();
}

uci::type::FuzeType& FuzeType::clearFuzeSeparationArmTime() noexcept {
  fuzeSeparationArmTime_Accessor.reset();
  return *this;
}

std::unique_ptr<FuzeType> FuzeType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::fuzeType : type};
  return (requestedType == uci::type::accessorType::fuzeType) ? boost::make_unique<FuzeType>() : nullptr;
}

/**  */
namespace FuzeType_Names {

constexpr const char* Extern_Type_Name{"FuzeType"};
constexpr const char* FuzeTrigger_Name{"FuzeTrigger"};
constexpr const char* FuzeMode_Name{"FuzeMode"};
constexpr const char* FuzePosition_Name{"FuzePosition"};
constexpr const char* Mnemonic_Name{"Mnemonic"};
constexpr const char* FuzeSeparationArmTime_Name{"FuzeSeparationArmTime"};

} // namespace FuzeType_Names

void FuzeType::deserialize(const boost::property_tree::ptree& propTree, uci::type::FuzeType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = FuzeType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + FuzeType_Names::FuzeTrigger_Name) {
      FuzeTriggerType::deserialize(valueType.second, accessor.getFuzeTrigger(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + FuzeType_Names::FuzeMode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableFuzeMode().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + FuzeType_Names::FuzePosition_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableFuzePosition().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + FuzeType_Names::Mnemonic_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setMnemonic(*value);
      }
    } else if (valueType.first == nsPrefix + FuzeType_Names::FuzeSeparationArmTime_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFuzeSeparationArmTime(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    }
  }
}

std::string FuzeType::serialize(const uci::type::FuzeType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? FuzeType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, FuzeType_Names::Extern_Type_Name);
  }
  FuzeTriggerType::serialize(accessor.getFuzeTrigger(), node, FuzeType_Names::FuzeTrigger_Name);
  if (accessor.hasFuzeMode()) {
    WeaponFuzeModeEnum::serialize(accessor.getFuzeMode(), node, FuzeType_Names::FuzeMode_Name, false);
  }
  if (accessor.hasFuzePosition()) {
    WeaponFuzePositionEnum::serialize(accessor.getFuzePosition(), node, FuzeType_Names::FuzePosition_Name, false);
  }
  if (accessor.hasMnemonic()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getMnemonic(), node, FuzeType_Names::Mnemonic_Name);
  }
  if (accessor.hasFuzeSeparationArmTime()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getFuzeSeparationArmTime(), node, FuzeType_Names::FuzeSeparationArmTime_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::FuzeType& FuzeType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::FuzeType>().release());
}

uci::type::FuzeType& FuzeType::create(const uci::type::FuzeType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::FuzeType> newAccessor{boost::make_unique<asb_uci::type::FuzeType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void FuzeType::destroy(uci::type::FuzeType& accessor) {
  delete dynamic_cast<asb_uci::type::FuzeType*>(&accessor);
}

} // namespace type

} // namespace uci

