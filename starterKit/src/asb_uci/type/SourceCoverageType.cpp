/** @file SourceCoverageType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/SourceCoverageType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/AngleHalfPairType.h"
#include "../../../include/asb_uci/type/AnglePairType.h"
#include "../../../include/asb_uci/type/AngleRateRangeType.h"
#include "../../../include/asb_uci/type/CapabilityCoverageAreaID_Type.h"
#include "../../../include/asb_uci/type/DoubleMinMaxType.h"
#include "../../../include/asb_uci/type/LOS_MeasurementEnum.h"
#include "../../../include/asb_uci/type/SlantRangeConstraintsType.h"
#include "../../../include/asb_uci/type/SpeedRangeType.h"
#include "../../../include/asb_uci/util/DerivedTypesDeserializer.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/AngleHalfPairType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/AnglePairType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/AngleRateRangeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CapabilityCoverageAreaID_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DoubleMinMaxType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/LOS_MeasurementEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SlantRangeConstraintsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SourceCoverageType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SpeedRangeType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

SourceCoverageType::SourceCoverageType()
  : capabilityCoverageAreaID_Accessor{boost::make_unique<CapabilityCoverageAreaID>(0, SIZE_MAX)} {
}

SourceCoverageType::~SourceCoverageType() = default;

void SourceCoverageType::copy(const uci::type::SourceCoverageType& accessor) {
  copyImpl(accessor, false);
}

void SourceCoverageType::copyImpl(const uci::type::SourceCoverageType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const SourceCoverageType&>(accessor);
    if (accessorImpl.fOV_ReferenceFrame_Accessor) {
      setFOV_ReferenceFrame(*(accessorImpl.fOV_ReferenceFrame_Accessor));
    } else {
      fOV_ReferenceFrame_Accessor.reset();
    }
    if (accessorImpl.rangeLimits_Accessor) {
      setRangeLimits(*(accessorImpl.rangeLimits_Accessor));
    } else {
      rangeLimits_Accessor.reset();
    }
    if (accessorImpl.rangeRateLimits_Accessor) {
      setRangeRateLimits(*(accessorImpl.rangeRateLimits_Accessor));
    } else {
      rangeRateLimits_Accessor.reset();
    }
    if (accessorImpl.azimuthLimits_Accessor) {
      setAzimuthLimits(*(accessorImpl.azimuthLimits_Accessor));
    } else {
      azimuthLimits_Accessor.reset();
    }
    if (accessorImpl.elevationLimits_Accessor) {
      setElevationLimits(*(accessorImpl.elevationLimits_Accessor));
    } else {
      elevationLimits_Accessor.reset();
    }
    if (accessorImpl.azimuthAngleRateLimits_Accessor) {
      setAzimuthAngleRateLimits(*(accessorImpl.azimuthAngleRateLimits_Accessor));
    } else {
      azimuthAngleRateLimits_Accessor.reset();
    }
    if (accessorImpl.elevationAngleRateLimits_Accessor) {
      setElevationAngleRateLimits(*(accessorImpl.elevationAngleRateLimits_Accessor));
    } else {
      elevationAngleRateLimits_Accessor.reset();
    }
    if (accessorImpl.cosconeY_RangeLimits_Accessor) {
      setCosconeY_RangeLimits(*(accessorImpl.cosconeY_RangeLimits_Accessor));
    } else {
      cosconeY_RangeLimits_Accessor.reset();
    }
    if (accessorImpl.cosconeZ_RangeLimits_Accessor) {
      setCosconeZ_RangeLimits(*(accessorImpl.cosconeZ_RangeLimits_Accessor));
    } else {
      cosconeZ_RangeLimits_Accessor.reset();
    }
    if (accessorImpl.cosconeY_RateRangeLimits_Accessor) {
      setCosconeY_RateRangeLimits(*(accessorImpl.cosconeY_RateRangeLimits_Accessor));
    } else {
      cosconeY_RateRangeLimits_Accessor.reset();
    }
    if (accessorImpl.cosconeZ_RateRangeLimits_Accessor) {
      setCosconeZ_RateRangeLimits(*(accessorImpl.cosconeZ_RateRangeLimits_Accessor));
    } else {
      cosconeZ_RateRangeLimits_Accessor.reset();
    }
    setCapabilityCoverageAreaID(*(accessorImpl.capabilityCoverageAreaID_Accessor));
  }
}

void SourceCoverageType::reset() noexcept {
  fOV_ReferenceFrame_Accessor.reset();
  rangeLimits_Accessor.reset();
  rangeRateLimits_Accessor.reset();
  azimuthLimits_Accessor.reset();
  elevationLimits_Accessor.reset();
  azimuthAngleRateLimits_Accessor.reset();
  elevationAngleRateLimits_Accessor.reset();
  cosconeY_RangeLimits_Accessor.reset();
  cosconeZ_RangeLimits_Accessor.reset();
  cosconeY_RateRangeLimits_Accessor.reset();
  cosconeZ_RateRangeLimits_Accessor.reset();
  capabilityCoverageAreaID_Accessor->reset();
}

uci::type::LOS_MeasurementEnum& SourceCoverageType::getFOV_ReferenceFrame_() const {
  if (fOV_ReferenceFrame_Accessor) {
    return *fOV_ReferenceFrame_Accessor;
  }
  throw uci::base::UCIException("Error in getFOV_ReferenceFrame(): An attempt was made to get an optional field that was not enabled, call hasFOV_ReferenceFrame() to determine if it is safe to call getFOV_ReferenceFrame()");
}

const uci::type::LOS_MeasurementEnum& SourceCoverageType::getFOV_ReferenceFrame() const {
  return getFOV_ReferenceFrame_();
}

uci::type::LOS_MeasurementEnum& SourceCoverageType::getFOV_ReferenceFrame() {
  return getFOV_ReferenceFrame_();
}

uci::type::SourceCoverageType& SourceCoverageType::setFOV_ReferenceFrame(const uci::type::LOS_MeasurementEnum& accessor) {
  enableFOV_ReferenceFrame();
  if (&accessor != fOV_ReferenceFrame_Accessor.get()) {
    fOV_ReferenceFrame_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SourceCoverageType& SourceCoverageType::setFOV_ReferenceFrame(const uci::type::LOS_MeasurementEnum::EnumerationItem value) {
  enableFOV_ReferenceFrame().setValue(value);
  return *this;
}

bool SourceCoverageType::hasFOV_ReferenceFrame() const noexcept {
  return static_cast<bool>(fOV_ReferenceFrame_Accessor);
}

uci::type::LOS_MeasurementEnum& SourceCoverageType::enableFOV_ReferenceFrame(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::lOS_MeasurementEnum : type};
  if ((!fOV_ReferenceFrame_Accessor) || (fOV_ReferenceFrame_Accessor->getAccessorType() != requestedType)) {
    fOV_ReferenceFrame_Accessor = LOS_MeasurementEnum::create(requestedType);
    if (!fOV_ReferenceFrame_Accessor) {
      throw uci::base::UCIException("Error in enableFOV_ReferenceFrame(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *fOV_ReferenceFrame_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearFOV_ReferenceFrame() noexcept {
  fOV_ReferenceFrame_Accessor.reset();
  return *this;
}

uci::type::SlantRangeConstraintsType& SourceCoverageType::getRangeLimits_() const {
  if (rangeLimits_Accessor) {
    return *rangeLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getRangeLimits(): An attempt was made to get an optional field that was not enabled, call hasRangeLimits() to determine if it is safe to call getRangeLimits()");
}

const uci::type::SlantRangeConstraintsType& SourceCoverageType::getRangeLimits() const {
  return getRangeLimits_();
}

uci::type::SlantRangeConstraintsType& SourceCoverageType::getRangeLimits() {
  return getRangeLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setRangeLimits(const uci::type::SlantRangeConstraintsType& accessor) {
  enableRangeLimits();
  if (&accessor != rangeLimits_Accessor.get()) {
    rangeLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasRangeLimits() const noexcept {
  return static_cast<bool>(rangeLimits_Accessor);
}

uci::type::SlantRangeConstraintsType& SourceCoverageType::enableRangeLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::slantRangeConstraintsType : type};
  if ((!rangeLimits_Accessor) || (rangeLimits_Accessor->getAccessorType() != requestedType)) {
    rangeLimits_Accessor = SlantRangeConstraintsType::create(requestedType);
    if (!rangeLimits_Accessor) {
      throw uci::base::UCIException("Error in enableRangeLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *rangeLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearRangeLimits() noexcept {
  rangeLimits_Accessor.reset();
  return *this;
}

uci::type::SpeedRangeType& SourceCoverageType::getRangeRateLimits_() const {
  if (rangeRateLimits_Accessor) {
    return *rangeRateLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getRangeRateLimits(): An attempt was made to get an optional field that was not enabled, call hasRangeRateLimits() to determine if it is safe to call getRangeRateLimits()");
}

const uci::type::SpeedRangeType& SourceCoverageType::getRangeRateLimits() const {
  return getRangeRateLimits_();
}

uci::type::SpeedRangeType& SourceCoverageType::getRangeRateLimits() {
  return getRangeRateLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setRangeRateLimits(const uci::type::SpeedRangeType& accessor) {
  enableRangeRateLimits();
  if (&accessor != rangeRateLimits_Accessor.get()) {
    rangeRateLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasRangeRateLimits() const noexcept {
  return static_cast<bool>(rangeRateLimits_Accessor);
}

uci::type::SpeedRangeType& SourceCoverageType::enableRangeRateLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::speedRangeType : type};
  if ((!rangeRateLimits_Accessor) || (rangeRateLimits_Accessor->getAccessorType() != requestedType)) {
    rangeRateLimits_Accessor = SpeedRangeType::create(requestedType);
    if (!rangeRateLimits_Accessor) {
      throw uci::base::UCIException("Error in enableRangeRateLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *rangeRateLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearRangeRateLimits() noexcept {
  rangeRateLimits_Accessor.reset();
  return *this;
}

uci::type::AnglePairType& SourceCoverageType::getAzimuthLimits_() const {
  if (azimuthLimits_Accessor) {
    return *azimuthLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getAzimuthLimits(): An attempt was made to get an optional field that was not enabled, call hasAzimuthLimits() to determine if it is safe to call getAzimuthLimits()");
}

const uci::type::AnglePairType& SourceCoverageType::getAzimuthLimits() const {
  return getAzimuthLimits_();
}

uci::type::AnglePairType& SourceCoverageType::getAzimuthLimits() {
  return getAzimuthLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setAzimuthLimits(const uci::type::AnglePairType& accessor) {
  enableAzimuthLimits(accessor.getAccessorType());
  if (&accessor != azimuthLimits_Accessor.get()) {
    azimuthLimits_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool SourceCoverageType::hasAzimuthLimits() const noexcept {
  return static_cast<bool>(azimuthLimits_Accessor);
}

uci::type::AnglePairType& SourceCoverageType::enableAzimuthLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::anglePairType : type};
  if ((!azimuthLimits_Accessor) || (azimuthLimits_Accessor->getAccessorType() != requestedType)) {
    azimuthLimits_Accessor = AnglePairType::create(requestedType);
    if (!azimuthLimits_Accessor) {
      throw uci::base::UCIException("Error in enableAzimuthLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *azimuthLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearAzimuthLimits() noexcept {
  azimuthLimits_Accessor.reset();
  return *this;
}

uci::type::AngleHalfPairType& SourceCoverageType::getElevationLimits_() const {
  if (elevationLimits_Accessor) {
    return *elevationLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getElevationLimits(): An attempt was made to get an optional field that was not enabled, call hasElevationLimits() to determine if it is safe to call getElevationLimits()");
}

const uci::type::AngleHalfPairType& SourceCoverageType::getElevationLimits() const {
  return getElevationLimits_();
}

uci::type::AngleHalfPairType& SourceCoverageType::getElevationLimits() {
  return getElevationLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setElevationLimits(const uci::type::AngleHalfPairType& accessor) {
  enableElevationLimits();
  if (&accessor != elevationLimits_Accessor.get()) {
    elevationLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasElevationLimits() const noexcept {
  return static_cast<bool>(elevationLimits_Accessor);
}

uci::type::AngleHalfPairType& SourceCoverageType::enableElevationLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::angleHalfPairType : type};
  if ((!elevationLimits_Accessor) || (elevationLimits_Accessor->getAccessorType() != requestedType)) {
    elevationLimits_Accessor = AngleHalfPairType::create(requestedType);
    if (!elevationLimits_Accessor) {
      throw uci::base::UCIException("Error in enableElevationLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *elevationLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearElevationLimits() noexcept {
  elevationLimits_Accessor.reset();
  return *this;
}

uci::type::AngleRateRangeType& SourceCoverageType::getAzimuthAngleRateLimits_() const {
  if (azimuthAngleRateLimits_Accessor) {
    return *azimuthAngleRateLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getAzimuthAngleRateLimits(): An attempt was made to get an optional field that was not enabled, call hasAzimuthAngleRateLimits() to determine if it is safe to call getAzimuthAngleRateLimits()");
}

const uci::type::AngleRateRangeType& SourceCoverageType::getAzimuthAngleRateLimits() const {
  return getAzimuthAngleRateLimits_();
}

uci::type::AngleRateRangeType& SourceCoverageType::getAzimuthAngleRateLimits() {
  return getAzimuthAngleRateLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setAzimuthAngleRateLimits(const uci::type::AngleRateRangeType& accessor) {
  enableAzimuthAngleRateLimits();
  if (&accessor != azimuthAngleRateLimits_Accessor.get()) {
    azimuthAngleRateLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasAzimuthAngleRateLimits() const noexcept {
  return static_cast<bool>(azimuthAngleRateLimits_Accessor);
}

uci::type::AngleRateRangeType& SourceCoverageType::enableAzimuthAngleRateLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::angleRateRangeType : type};
  if ((!azimuthAngleRateLimits_Accessor) || (azimuthAngleRateLimits_Accessor->getAccessorType() != requestedType)) {
    azimuthAngleRateLimits_Accessor = AngleRateRangeType::create(requestedType);
    if (!azimuthAngleRateLimits_Accessor) {
      throw uci::base::UCIException("Error in enableAzimuthAngleRateLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *azimuthAngleRateLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearAzimuthAngleRateLimits() noexcept {
  azimuthAngleRateLimits_Accessor.reset();
  return *this;
}

uci::type::AngleRateRangeType& SourceCoverageType::getElevationAngleRateLimits_() const {
  if (elevationAngleRateLimits_Accessor) {
    return *elevationAngleRateLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getElevationAngleRateLimits(): An attempt was made to get an optional field that was not enabled, call hasElevationAngleRateLimits() to determine if it is safe to call getElevationAngleRateLimits()");
}

const uci::type::AngleRateRangeType& SourceCoverageType::getElevationAngleRateLimits() const {
  return getElevationAngleRateLimits_();
}

uci::type::AngleRateRangeType& SourceCoverageType::getElevationAngleRateLimits() {
  return getElevationAngleRateLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setElevationAngleRateLimits(const uci::type::AngleRateRangeType& accessor) {
  enableElevationAngleRateLimits();
  if (&accessor != elevationAngleRateLimits_Accessor.get()) {
    elevationAngleRateLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasElevationAngleRateLimits() const noexcept {
  return static_cast<bool>(elevationAngleRateLimits_Accessor);
}

uci::type::AngleRateRangeType& SourceCoverageType::enableElevationAngleRateLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::angleRateRangeType : type};
  if ((!elevationAngleRateLimits_Accessor) || (elevationAngleRateLimits_Accessor->getAccessorType() != requestedType)) {
    elevationAngleRateLimits_Accessor = AngleRateRangeType::create(requestedType);
    if (!elevationAngleRateLimits_Accessor) {
      throw uci::base::UCIException("Error in enableElevationAngleRateLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *elevationAngleRateLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearElevationAngleRateLimits() noexcept {
  elevationAngleRateLimits_Accessor.reset();
  return *this;
}

uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeY_RangeLimits_() const {
  if (cosconeY_RangeLimits_Accessor) {
    return *cosconeY_RangeLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getCosconeY_RangeLimits(): An attempt was made to get an optional field that was not enabled, call hasCosconeY_RangeLimits() to determine if it is safe to call getCosconeY_RangeLimits()");
}

const uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeY_RangeLimits() const {
  return getCosconeY_RangeLimits_();
}

uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeY_RangeLimits() {
  return getCosconeY_RangeLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setCosconeY_RangeLimits(const uci::type::DoubleMinMaxType& accessor) {
  enableCosconeY_RangeLimits();
  if (&accessor != cosconeY_RangeLimits_Accessor.get()) {
    cosconeY_RangeLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasCosconeY_RangeLimits() const noexcept {
  return static_cast<bool>(cosconeY_RangeLimits_Accessor);
}

uci::type::DoubleMinMaxType& SourceCoverageType::enableCosconeY_RangeLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::doubleMinMaxType : type};
  if ((!cosconeY_RangeLimits_Accessor) || (cosconeY_RangeLimits_Accessor->getAccessorType() != requestedType)) {
    cosconeY_RangeLimits_Accessor = DoubleMinMaxType::create(requestedType);
    if (!cosconeY_RangeLimits_Accessor) {
      throw uci::base::UCIException("Error in enableCosconeY_RangeLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *cosconeY_RangeLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearCosconeY_RangeLimits() noexcept {
  cosconeY_RangeLimits_Accessor.reset();
  return *this;
}

uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeZ_RangeLimits_() const {
  if (cosconeZ_RangeLimits_Accessor) {
    return *cosconeZ_RangeLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getCosconeZ_RangeLimits(): An attempt was made to get an optional field that was not enabled, call hasCosconeZ_RangeLimits() to determine if it is safe to call getCosconeZ_RangeLimits()");
}

const uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeZ_RangeLimits() const {
  return getCosconeZ_RangeLimits_();
}

uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeZ_RangeLimits() {
  return getCosconeZ_RangeLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setCosconeZ_RangeLimits(const uci::type::DoubleMinMaxType& accessor) {
  enableCosconeZ_RangeLimits();
  if (&accessor != cosconeZ_RangeLimits_Accessor.get()) {
    cosconeZ_RangeLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasCosconeZ_RangeLimits() const noexcept {
  return static_cast<bool>(cosconeZ_RangeLimits_Accessor);
}

uci::type::DoubleMinMaxType& SourceCoverageType::enableCosconeZ_RangeLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::doubleMinMaxType : type};
  if ((!cosconeZ_RangeLimits_Accessor) || (cosconeZ_RangeLimits_Accessor->getAccessorType() != requestedType)) {
    cosconeZ_RangeLimits_Accessor = DoubleMinMaxType::create(requestedType);
    if (!cosconeZ_RangeLimits_Accessor) {
      throw uci::base::UCIException("Error in enableCosconeZ_RangeLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *cosconeZ_RangeLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearCosconeZ_RangeLimits() noexcept {
  cosconeZ_RangeLimits_Accessor.reset();
  return *this;
}

uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeY_RateRangeLimits_() const {
  if (cosconeY_RateRangeLimits_Accessor) {
    return *cosconeY_RateRangeLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getCosconeY_RateRangeLimits(): An attempt was made to get an optional field that was not enabled, call hasCosconeY_RateRangeLimits() to determine if it is safe to call getCosconeY_RateRangeLimits()");
}

const uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeY_RateRangeLimits() const {
  return getCosconeY_RateRangeLimits_();
}

uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeY_RateRangeLimits() {
  return getCosconeY_RateRangeLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setCosconeY_RateRangeLimits(const uci::type::DoubleMinMaxType& accessor) {
  enableCosconeY_RateRangeLimits();
  if (&accessor != cosconeY_RateRangeLimits_Accessor.get()) {
    cosconeY_RateRangeLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasCosconeY_RateRangeLimits() const noexcept {
  return static_cast<bool>(cosconeY_RateRangeLimits_Accessor);
}

uci::type::DoubleMinMaxType& SourceCoverageType::enableCosconeY_RateRangeLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::doubleMinMaxType : type};
  if ((!cosconeY_RateRangeLimits_Accessor) || (cosconeY_RateRangeLimits_Accessor->getAccessorType() != requestedType)) {
    cosconeY_RateRangeLimits_Accessor = DoubleMinMaxType::create(requestedType);
    if (!cosconeY_RateRangeLimits_Accessor) {
      throw uci::base::UCIException("Error in enableCosconeY_RateRangeLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *cosconeY_RateRangeLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearCosconeY_RateRangeLimits() noexcept {
  cosconeY_RateRangeLimits_Accessor.reset();
  return *this;
}

uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeZ_RateRangeLimits_() const {
  if (cosconeZ_RateRangeLimits_Accessor) {
    return *cosconeZ_RateRangeLimits_Accessor;
  }
  throw uci::base::UCIException("Error in getCosconeZ_RateRangeLimits(): An attempt was made to get an optional field that was not enabled, call hasCosconeZ_RateRangeLimits() to determine if it is safe to call getCosconeZ_RateRangeLimits()");
}

const uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeZ_RateRangeLimits() const {
  return getCosconeZ_RateRangeLimits_();
}

uci::type::DoubleMinMaxType& SourceCoverageType::getCosconeZ_RateRangeLimits() {
  return getCosconeZ_RateRangeLimits_();
}

uci::type::SourceCoverageType& SourceCoverageType::setCosconeZ_RateRangeLimits(const uci::type::DoubleMinMaxType& accessor) {
  enableCosconeZ_RateRangeLimits();
  if (&accessor != cosconeZ_RateRangeLimits_Accessor.get()) {
    cosconeZ_RateRangeLimits_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SourceCoverageType::hasCosconeZ_RateRangeLimits() const noexcept {
  return static_cast<bool>(cosconeZ_RateRangeLimits_Accessor);
}

uci::type::DoubleMinMaxType& SourceCoverageType::enableCosconeZ_RateRangeLimits(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::doubleMinMaxType : type};
  if ((!cosconeZ_RateRangeLimits_Accessor) || (cosconeZ_RateRangeLimits_Accessor->getAccessorType() != requestedType)) {
    cosconeZ_RateRangeLimits_Accessor = DoubleMinMaxType::create(requestedType);
    if (!cosconeZ_RateRangeLimits_Accessor) {
      throw uci::base::UCIException("Error in enableCosconeZ_RateRangeLimits(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *cosconeZ_RateRangeLimits_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::clearCosconeZ_RateRangeLimits() noexcept {
  cosconeZ_RateRangeLimits_Accessor.reset();
  return *this;
}

const uci::type::SourceCoverageType::CapabilityCoverageAreaID& SourceCoverageType::getCapabilityCoverageAreaID() const {
  return *capabilityCoverageAreaID_Accessor;
}

uci::type::SourceCoverageType::CapabilityCoverageAreaID& SourceCoverageType::getCapabilityCoverageAreaID() {
  return *capabilityCoverageAreaID_Accessor;
}

uci::type::SourceCoverageType& SourceCoverageType::setCapabilityCoverageAreaID(const uci::type::SourceCoverageType::CapabilityCoverageAreaID& accessor) {
  if (&accessor != capabilityCoverageAreaID_Accessor.get()) {
    capabilityCoverageAreaID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

std::unique_ptr<SourceCoverageType> SourceCoverageType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::sourceCoverageType : type};
  return (requestedType == uci::type::accessorType::sourceCoverageType) ? boost::make_unique<SourceCoverageType>() : nullptr;
}

/**  */
namespace SourceCoverageType_Names {

constexpr const char* Extern_Type_Name{"SourceCoverageType"};
constexpr const char* FOV_ReferenceFrame_Name{"FOV_ReferenceFrame"};
constexpr const char* RangeLimits_Name{"RangeLimits"};
constexpr const char* RangeRateLimits_Name{"RangeRateLimits"};
constexpr const char* AzimuthLimits_Name{"AzimuthLimits"};
constexpr const char* ElevationLimits_Name{"ElevationLimits"};
constexpr const char* AzimuthAngleRateLimits_Name{"AzimuthAngleRateLimits"};
constexpr const char* ElevationAngleRateLimits_Name{"ElevationAngleRateLimits"};
constexpr const char* CosconeY_RangeLimits_Name{"CosconeY_RangeLimits"};
constexpr const char* CosconeZ_RangeLimits_Name{"CosconeZ_RangeLimits"};
constexpr const char* CosconeY_RateRangeLimits_Name{"CosconeY_RateRangeLimits"};
constexpr const char* CosconeZ_RateRangeLimits_Name{"CosconeZ_RateRangeLimits"};
constexpr const char* CapabilityCoverageAreaID_Name{"CapabilityCoverageAreaID"};

} // namespace SourceCoverageType_Names

void SourceCoverageType::deserialize(const boost::property_tree::ptree& propTree, uci::type::SourceCoverageType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = SourceCoverageType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::FOV_ReferenceFrame_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableFOV_ReferenceFrame().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::RangeLimits_Name) {
      SlantRangeConstraintsType::deserialize(valueType.second, accessor.enableRangeLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::RangeRateLimits_Name) {
      SpeedRangeType::deserialize(valueType.second, accessor.enableRangeRateLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::AzimuthLimits_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableAzimuthLimits(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::ElevationLimits_Name) {
      AngleHalfPairType::deserialize(valueType.second, accessor.enableElevationLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::AzimuthAngleRateLimits_Name) {
      AngleRateRangeType::deserialize(valueType.second, accessor.enableAzimuthAngleRateLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::ElevationAngleRateLimits_Name) {
      AngleRateRangeType::deserialize(valueType.second, accessor.enableElevationAngleRateLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::CosconeY_RangeLimits_Name) {
      DoubleMinMaxType::deserialize(valueType.second, accessor.enableCosconeY_RangeLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::CosconeZ_RangeLimits_Name) {
      DoubleMinMaxType::deserialize(valueType.second, accessor.enableCosconeZ_RangeLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::CosconeY_RateRangeLimits_Name) {
      DoubleMinMaxType::deserialize(valueType.second, accessor.enableCosconeY_RateRangeLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::CosconeZ_RateRangeLimits_Name) {
      DoubleMinMaxType::deserialize(valueType.second, accessor.enableCosconeZ_RateRangeLimits(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SourceCoverageType_Names::CapabilityCoverageAreaID_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SourceCoverageType::CapabilityCoverageAreaID& boundedList = accessor.getCapabilityCoverageAreaID();
        const uci::type::SourceCoverageType::CapabilityCoverageAreaID::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::CapabilityCoverageAreaID_Type::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    }
  }
}

std::string SourceCoverageType::serialize(const uci::type::SourceCoverageType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? SourceCoverageType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, SourceCoverageType_Names::Extern_Type_Name);
  }
  if (accessor.hasFOV_ReferenceFrame()) {
    LOS_MeasurementEnum::serialize(accessor.getFOV_ReferenceFrame(), node, SourceCoverageType_Names::FOV_ReferenceFrame_Name, false);
  }
  if (accessor.hasRangeLimits()) {
    SlantRangeConstraintsType::serialize(accessor.getRangeLimits(), node, SourceCoverageType_Names::RangeLimits_Name);
  }
  if (accessor.hasRangeRateLimits()) {
    SpeedRangeType::serialize(accessor.getRangeRateLimits(), node, SourceCoverageType_Names::RangeRateLimits_Name);
  }
  if (accessor.hasAzimuthLimits()) {
    AnglePairType::serialize(accessor.getAzimuthLimits(), node, SourceCoverageType_Names::AzimuthLimits_Name);
  }
  if (accessor.hasElevationLimits()) {
    AngleHalfPairType::serialize(accessor.getElevationLimits(), node, SourceCoverageType_Names::ElevationLimits_Name);
  }
  if (accessor.hasAzimuthAngleRateLimits()) {
    AngleRateRangeType::serialize(accessor.getAzimuthAngleRateLimits(), node, SourceCoverageType_Names::AzimuthAngleRateLimits_Name);
  }
  if (accessor.hasElevationAngleRateLimits()) {
    AngleRateRangeType::serialize(accessor.getElevationAngleRateLimits(), node, SourceCoverageType_Names::ElevationAngleRateLimits_Name);
  }
  if (accessor.hasCosconeY_RangeLimits()) {
    DoubleMinMaxType::serialize(accessor.getCosconeY_RangeLimits(), node, SourceCoverageType_Names::CosconeY_RangeLimits_Name);
  }
  if (accessor.hasCosconeZ_RangeLimits()) {
    DoubleMinMaxType::serialize(accessor.getCosconeZ_RangeLimits(), node, SourceCoverageType_Names::CosconeZ_RangeLimits_Name);
  }
  if (accessor.hasCosconeY_RateRangeLimits()) {
    DoubleMinMaxType::serialize(accessor.getCosconeY_RateRangeLimits(), node, SourceCoverageType_Names::CosconeY_RateRangeLimits_Name);
  }
  if (accessor.hasCosconeZ_RateRangeLimits()) {
    DoubleMinMaxType::serialize(accessor.getCosconeZ_RateRangeLimits(), node, SourceCoverageType_Names::CosconeZ_RateRangeLimits_Name);
  }
  {
    const uci::type::SourceCoverageType::CapabilityCoverageAreaID& boundedList = accessor.getCapabilityCoverageAreaID();
    for (uci::type::SourceCoverageType::CapabilityCoverageAreaID::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::CapabilityCoverageAreaID_Type::serialize(boundedList.at(i), node, SourceCoverageType_Names::CapabilityCoverageAreaID_Name);
    }
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::SourceCoverageType& SourceCoverageType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::SourceCoverageType>().release());
}

uci::type::SourceCoverageType& SourceCoverageType::create(const uci::type::SourceCoverageType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::SourceCoverageType> newAccessor{boost::make_unique<asb_uci::type::SourceCoverageType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void SourceCoverageType::destroy(uci::type::SourceCoverageType& accessor) {
  delete dynamic_cast<asb_uci::type::SourceCoverageType*>(&accessor);
}

} // namespace type

} // namespace uci

