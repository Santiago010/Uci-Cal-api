/** @file EntityIdentityChoiceType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:12 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/EntityIdentityChoiceType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/EOB_IdentityType.h"
#include "asb_uci/type/EmitterIdentityType.h"
#include "asb_uci/type/EnvironmentIdentityType.h"
#include "asb_uci/type/FacilityIdentificationType.h"
#include "asb_uci/type/PlatformIdentityType.h"
#include "asb_uci/type/SpecificEmitterIdentityType.h"
#include "asb_uci/type/SpecificIdentityType.h"
#include "asb_uci/type/StandardIdentityType.h"
#include "asb_uci/type/StoreType.h"
#include "asb_uci/type/VehicleIdentificationType.h"
#include "asb_uci/util/DerivedTypesDeserializer.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/EOB_IdentityType.h"
#include "uci/type/EmitterIdentityType.h"
#include "uci/type/EntityIdentityChoiceType.h"
#include "uci/type/EnvironmentIdentityType.h"
#include "uci/type/FacilityIdentificationType.h"
#include "uci/type/PlatformIdentityType.h"
#include "uci/type/SpecificEmitterIdentityType.h"
#include "uci/type/SpecificIdentityType.h"
#include "uci/type/StandardIdentityType.h"
#include "uci/type/StoreType.h"
#include "uci/type/VehicleIdentificationType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

EntityIdentityChoiceType::EntityIdentityChoiceType() = default;

EntityIdentityChoiceType::~EntityIdentityChoiceType() = default;

void EntityIdentityChoiceType::copy(const uci::type::EntityIdentityChoiceType& accessor) {
  copyImpl(accessor, false);
}

void EntityIdentityChoiceType::copyImpl(const uci::type::EntityIdentityChoiceType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const EntityIdentityChoiceType&>(accessor);
    if (accessorImpl.standard_Accessor) {
      setStandard(*(accessorImpl.standard_Accessor));
    } else {
      standard_Accessor.reset();
    }
    if (accessorImpl.environment_Accessor) {
      setEnvironment(*(accessorImpl.environment_Accessor));
    } else {
      environment_Accessor.reset();
    }
    if (accessorImpl.platform_Accessor) {
      setPlatform(*(accessorImpl.platform_Accessor));
    } else {
      platform_Accessor.reset();
    }
    if (accessorImpl.specific_Accessor) {
      setSpecific(*(accessorImpl.specific_Accessor));
    } else {
      specific_Accessor.reset();
    }
    if (accessorImpl.emitter_Accessor) {
      setEmitter(*(accessorImpl.emitter_Accessor));
    } else {
      emitter_Accessor.reset();
    }
    if (accessorImpl.specificEmitter_Accessor) {
      setSpecificEmitter(*(accessorImpl.specificEmitter_Accessor));
    } else {
      specificEmitter_Accessor.reset();
    }
    if (accessorImpl.specificVehicle_Accessor) {
      setSpecificVehicle(*(accessorImpl.specificVehicle_Accessor));
    } else {
      specificVehicle_Accessor.reset();
    }
    if (accessorImpl.specificFacility_Accessor) {
      setSpecificFacility(*(accessorImpl.specificFacility_Accessor));
    } else {
      specificFacility_Accessor.reset();
    }
    if (accessorImpl.eOB_Accessor) {
      setEOB(*(accessorImpl.eOB_Accessor));
    } else {
      eOB_Accessor.reset();
    }
    if (accessorImpl.weapon_Accessor) {
      setWeapon(*(accessorImpl.weapon_Accessor));
    } else {
      weapon_Accessor.reset();
    }
  }
}

void EntityIdentityChoiceType::reset() noexcept {
  standard_Accessor.reset();
  environment_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
}

uci::type::EntityIdentityChoiceType::EntityIdentityChoiceTypeChoice EntityIdentityChoiceType::getEntityIdentityChoiceTypeChoiceOrdinal() const noexcept {
  if (standard_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_STANDARD;
  }
  if (environment_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_ENVIRONMENT;
  }
  if (platform_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_PLATFORM;
  }
  if (specific_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_SPECIFIC;
  }
  if (emitter_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_EMITTER;
  }
  if (specificEmitter_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_SPECIFICEMITTER;
  }
  if (specificVehicle_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_SPECIFICVEHICLE;
  }
  if (specificFacility_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_SPECIFICFACILITY;
  }
  if (eOB_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_EOB;
  }
  if (weapon_Accessor) {
    return ENTITYIDENTITYCHOICETYPE_CHOICE_WEAPON;
  }
  return ENTITYIDENTITYCHOICETYPE_CHOICE_NONE;
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setEntityIdentityChoiceTypeChoiceOrdinal(uci::type::EntityIdentityChoiceType::EntityIdentityChoiceTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case ENTITYIDENTITYCHOICETYPE_CHOICE_STANDARD:
      chooseStandard("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_ENVIRONMENT:
      chooseEnvironment("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_PLATFORM:
      choosePlatform("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_SPECIFIC:
      chooseSpecific("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_EMITTER:
      chooseEmitter("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_SPECIFICEMITTER:
      chooseSpecificEmitter("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_SPECIFICVEHICLE:
      chooseSpecificVehicle("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_SPECIFICFACILITY:
      chooseSpecificFacility("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_EOB:
      chooseEOB("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    case ENTITYIDENTITYCHOICETYPE_CHOICE_WEAPON:
      chooseWeapon("setEntityIdentityChoiceTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setEntityIdentityChoiceTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::StandardIdentityType& EntityIdentityChoiceType::getStandard_() const {
  if (standard_Accessor) {
    return *standard_Accessor;
  }
  throw uci::base::UCIException("Error in getStandard(): Unable to get Standard, field not selected");
}

const uci::type::StandardIdentityType& EntityIdentityChoiceType::getStandard() const {
  return getStandard_();
}

uci::type::StandardIdentityType& EntityIdentityChoiceType::getStandard() {
  return getStandard_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setStandard(const uci::type::StandardIdentityType& accessor) {
  chooseStandard("setStandard", accessor.getAccessorType());
  if (&accessor != standard_Accessor.get()) {
    standard_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EntityIdentityChoiceType::isStandard() const noexcept {
  return static_cast<bool>(standard_Accessor);
}

uci::type::StandardIdentityType& EntityIdentityChoiceType::chooseStandard(const std::string& method, uci::base::accessorType::AccessorType type) {
  environment_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::standardIdentityType : type};
  if ((!standard_Accessor) || (standard_Accessor->getAccessorType() != requestedType)) {
    standard_Accessor = StandardIdentityType::create(type);
    if (!standard_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *standard_Accessor;
}

uci::type::StandardIdentityType& EntityIdentityChoiceType::chooseStandard(uci::base::accessorType::AccessorType type) {
  return chooseStandard("chooseStandard", type);
}

uci::type::EnvironmentIdentityType& EntityIdentityChoiceType::getEnvironment_() const {
  if (environment_Accessor) {
    return *environment_Accessor;
  }
  throw uci::base::UCIException("Error in getEnvironment(): Unable to get Environment, field not selected");
}

const uci::type::EnvironmentIdentityType& EntityIdentityChoiceType::getEnvironment() const {
  return getEnvironment_();
}

uci::type::EnvironmentIdentityType& EntityIdentityChoiceType::getEnvironment() {
  return getEnvironment_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setEnvironment(const uci::type::EnvironmentIdentityType& accessor) {
  chooseEnvironment();
  if (&accessor != environment_Accessor.get()) {
    environment_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityIdentityChoiceType::isEnvironment() const noexcept {
  return static_cast<bool>(environment_Accessor);
}

uci::type::EnvironmentIdentityType& EntityIdentityChoiceType::chooseEnvironment(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::environmentIdentityType : type};
  if ((!environment_Accessor) || (environment_Accessor->getAccessorType() != requestedType)) {
    environment_Accessor = EnvironmentIdentityType::create(type);
    if (!environment_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *environment_Accessor;
}

uci::type::EnvironmentIdentityType& EntityIdentityChoiceType::chooseEnvironment(uci::base::accessorType::AccessorType type) {
  return chooseEnvironment("chooseEnvironment", type);
}

uci::type::PlatformIdentityType& EntityIdentityChoiceType::getPlatform_() const {
  if (platform_Accessor) {
    return *platform_Accessor;
  }
  throw uci::base::UCIException("Error in getPlatform(): Unable to get Platform, field not selected");
}

const uci::type::PlatformIdentityType& EntityIdentityChoiceType::getPlatform() const {
  return getPlatform_();
}

uci::type::PlatformIdentityType& EntityIdentityChoiceType::getPlatform() {
  return getPlatform_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setPlatform(const uci::type::PlatformIdentityType& accessor) {
  choosePlatform("setPlatform", accessor.getAccessorType());
  if (&accessor != platform_Accessor.get()) {
    platform_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EntityIdentityChoiceType::isPlatform() const noexcept {
  return static_cast<bool>(platform_Accessor);
}

uci::type::PlatformIdentityType& EntityIdentityChoiceType::choosePlatform(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  environment_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::platformIdentityType : type};
  if ((!platform_Accessor) || (platform_Accessor->getAccessorType() != requestedType)) {
    platform_Accessor = PlatformIdentityType::create(type);
    if (!platform_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *platform_Accessor;
}

uci::type::PlatformIdentityType& EntityIdentityChoiceType::choosePlatform(uci::base::accessorType::AccessorType type) {
  return choosePlatform("choosePlatform", type);
}

uci::type::SpecificIdentityType& EntityIdentityChoiceType::getSpecific_() const {
  if (specific_Accessor) {
    return *specific_Accessor;
  }
  throw uci::base::UCIException("Error in getSpecific(): Unable to get Specific, field not selected");
}

const uci::type::SpecificIdentityType& EntityIdentityChoiceType::getSpecific() const {
  return getSpecific_();
}

uci::type::SpecificIdentityType& EntityIdentityChoiceType::getSpecific() {
  return getSpecific_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setSpecific(const uci::type::SpecificIdentityType& accessor) {
  chooseSpecific("setSpecific", accessor.getAccessorType());
  if (&accessor != specific_Accessor.get()) {
    specific_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EntityIdentityChoiceType::isSpecific() const noexcept {
  return static_cast<bool>(specific_Accessor);
}

uci::type::SpecificIdentityType& EntityIdentityChoiceType::chooseSpecific(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  environment_Accessor.reset();
  platform_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::specificIdentityType : type};
  if ((!specific_Accessor) || (specific_Accessor->getAccessorType() != requestedType)) {
    specific_Accessor = SpecificIdentityType::create(type);
    if (!specific_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *specific_Accessor;
}

uci::type::SpecificIdentityType& EntityIdentityChoiceType::chooseSpecific(uci::base::accessorType::AccessorType type) {
  return chooseSpecific("chooseSpecific", type);
}

uci::type::EmitterIdentityType& EntityIdentityChoiceType::getEmitter_() const {
  if (emitter_Accessor) {
    return *emitter_Accessor;
  }
  throw uci::base::UCIException("Error in getEmitter(): Unable to get Emitter, field not selected");
}

const uci::type::EmitterIdentityType& EntityIdentityChoiceType::getEmitter() const {
  return getEmitter_();
}

uci::type::EmitterIdentityType& EntityIdentityChoiceType::getEmitter() {
  return getEmitter_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setEmitter(const uci::type::EmitterIdentityType& accessor) {
  chooseEmitter();
  if (&accessor != emitter_Accessor.get()) {
    emitter_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityIdentityChoiceType::isEmitter() const noexcept {
  return static_cast<bool>(emitter_Accessor);
}

uci::type::EmitterIdentityType& EntityIdentityChoiceType::chooseEmitter(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  environment_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::emitterIdentityType : type};
  if ((!emitter_Accessor) || (emitter_Accessor->getAccessorType() != requestedType)) {
    emitter_Accessor = EmitterIdentityType::create(type);
    if (!emitter_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *emitter_Accessor;
}

uci::type::EmitterIdentityType& EntityIdentityChoiceType::chooseEmitter(uci::base::accessorType::AccessorType type) {
  return chooseEmitter("chooseEmitter", type);
}

uci::type::SpecificEmitterIdentityType& EntityIdentityChoiceType::getSpecificEmitter_() const {
  if (specificEmitter_Accessor) {
    return *specificEmitter_Accessor;
  }
  throw uci::base::UCIException("Error in getSpecificEmitter(): Unable to get SpecificEmitter, field not selected");
}

const uci::type::SpecificEmitterIdentityType& EntityIdentityChoiceType::getSpecificEmitter() const {
  return getSpecificEmitter_();
}

uci::type::SpecificEmitterIdentityType& EntityIdentityChoiceType::getSpecificEmitter() {
  return getSpecificEmitter_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setSpecificEmitter(const uci::type::SpecificEmitterIdentityType& accessor) {
  chooseSpecificEmitter("setSpecificEmitter", accessor.getAccessorType());
  if (&accessor != specificEmitter_Accessor.get()) {
    specificEmitter_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EntityIdentityChoiceType::isSpecificEmitter() const noexcept {
  return static_cast<bool>(specificEmitter_Accessor);
}

uci::type::SpecificEmitterIdentityType& EntityIdentityChoiceType::chooseSpecificEmitter(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  environment_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::specificEmitterIdentityType : type};
  if ((!specificEmitter_Accessor) || (specificEmitter_Accessor->getAccessorType() != requestedType)) {
    specificEmitter_Accessor = SpecificEmitterIdentityType::create(type);
    if (!specificEmitter_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *specificEmitter_Accessor;
}

uci::type::SpecificEmitterIdentityType& EntityIdentityChoiceType::chooseSpecificEmitter(uci::base::accessorType::AccessorType type) {
  return chooseSpecificEmitter("chooseSpecificEmitter", type);
}

uci::type::VehicleIdentificationType& EntityIdentityChoiceType::getSpecificVehicle_() const {
  if (specificVehicle_Accessor) {
    return *specificVehicle_Accessor;
  }
  throw uci::base::UCIException("Error in getSpecificVehicle(): Unable to get SpecificVehicle, field not selected");
}

const uci::type::VehicleIdentificationType& EntityIdentityChoiceType::getSpecificVehicle() const {
  return getSpecificVehicle_();
}

uci::type::VehicleIdentificationType& EntityIdentityChoiceType::getSpecificVehicle() {
  return getSpecificVehicle_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setSpecificVehicle(const uci::type::VehicleIdentificationType& accessor) {
  chooseSpecificVehicle("setSpecificVehicle", accessor.getAccessorType());
  if (&accessor != specificVehicle_Accessor.get()) {
    specificVehicle_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EntityIdentityChoiceType::isSpecificVehicle() const noexcept {
  return static_cast<bool>(specificVehicle_Accessor);
}

uci::type::VehicleIdentificationType& EntityIdentityChoiceType::chooseSpecificVehicle(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  environment_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::vehicleIdentificationType : type};
  if ((!specificVehicle_Accessor) || (specificVehicle_Accessor->getAccessorType() != requestedType)) {
    specificVehicle_Accessor = VehicleIdentificationType::create(type);
    if (!specificVehicle_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *specificVehicle_Accessor;
}

uci::type::VehicleIdentificationType& EntityIdentityChoiceType::chooseSpecificVehicle(uci::base::accessorType::AccessorType type) {
  return chooseSpecificVehicle("chooseSpecificVehicle", type);
}

uci::type::FacilityIdentificationType& EntityIdentityChoiceType::getSpecificFacility_() const {
  if (specificFacility_Accessor) {
    return *specificFacility_Accessor;
  }
  throw uci::base::UCIException("Error in getSpecificFacility(): Unable to get SpecificFacility, field not selected");
}

const uci::type::FacilityIdentificationType& EntityIdentityChoiceType::getSpecificFacility() const {
  return getSpecificFacility_();
}

uci::type::FacilityIdentificationType& EntityIdentityChoiceType::getSpecificFacility() {
  return getSpecificFacility_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setSpecificFacility(const uci::type::FacilityIdentificationType& accessor) {
  chooseSpecificFacility(accessor.getAccessorType());
  if (&accessor != specificFacility_Accessor.get()) {
    specificFacility_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityIdentityChoiceType::isSpecificFacility() const noexcept {
  return static_cast<bool>(specificFacility_Accessor);
}

uci::type::FacilityIdentificationType& EntityIdentityChoiceType::chooseSpecificFacility(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  environment_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  eOB_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::facilityIdentificationType : type};
  if ((!specificFacility_Accessor) || (specificFacility_Accessor->getAccessorType() != requestedType)) {
    specificFacility_Accessor = FacilityIdentificationType::create(type);
    if (!specificFacility_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *specificFacility_Accessor;
}

uci::type::FacilityIdentificationType& EntityIdentityChoiceType::chooseSpecificFacility(uci::base::accessorType::AccessorType type) {
  return chooseSpecificFacility("chooseSpecificFacility", type);
}

uci::type::EOB_IdentityType& EntityIdentityChoiceType::getEOB_() const {
  if (eOB_Accessor) {
    return *eOB_Accessor;
  }
  throw uci::base::UCIException("Error in getEOB(): Unable to get EOB, field not selected");
}

const uci::type::EOB_IdentityType& EntityIdentityChoiceType::getEOB() const {
  return getEOB_();
}

uci::type::EOB_IdentityType& EntityIdentityChoiceType::getEOB() {
  return getEOB_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setEOB(const uci::type::EOB_IdentityType& accessor) {
  chooseEOB(accessor.getAccessorType());
  if (&accessor != eOB_Accessor.get()) {
    eOB_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityIdentityChoiceType::isEOB() const noexcept {
  return static_cast<bool>(eOB_Accessor);
}

uci::type::EOB_IdentityType& EntityIdentityChoiceType::chooseEOB(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  environment_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  weapon_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::eOB_IdentityType : type};
  if ((!eOB_Accessor) || (eOB_Accessor->getAccessorType() != requestedType)) {
    eOB_Accessor = EOB_IdentityType::create(type);
    if (!eOB_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *eOB_Accessor;
}

uci::type::EOB_IdentityType& EntityIdentityChoiceType::chooseEOB(uci::base::accessorType::AccessorType type) {
  return chooseEOB("chooseEOB", type);
}

uci::type::StoreType& EntityIdentityChoiceType::getWeapon_() const {
  if (weapon_Accessor) {
    return *weapon_Accessor;
  }
  throw uci::base::UCIException("Error in getWeapon(): Unable to get Weapon, field not selected");
}

const uci::type::StoreType& EntityIdentityChoiceType::getWeapon() const {
  return getWeapon_();
}

uci::type::StoreType& EntityIdentityChoiceType::getWeapon() {
  return getWeapon_();
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::setWeapon(const uci::type::StoreType& accessor) {
  chooseWeapon("setWeapon", accessor.getAccessorType());
  if (&accessor != weapon_Accessor.get()) {
    weapon_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool EntityIdentityChoiceType::isWeapon() const noexcept {
  return static_cast<bool>(weapon_Accessor);
}

uci::type::StoreType& EntityIdentityChoiceType::chooseWeapon(const std::string& method, uci::base::accessorType::AccessorType type) {
  standard_Accessor.reset();
  environment_Accessor.reset();
  platform_Accessor.reset();
  specific_Accessor.reset();
  emitter_Accessor.reset();
  specificEmitter_Accessor.reset();
  specificVehicle_Accessor.reset();
  specificFacility_Accessor.reset();
  eOB_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::storeType : type};
  if ((!weapon_Accessor) || (weapon_Accessor->getAccessorType() != requestedType)) {
    weapon_Accessor = StoreType::create(type);
    if (!weapon_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *weapon_Accessor;
}

uci::type::StoreType& EntityIdentityChoiceType::chooseWeapon(uci::base::accessorType::AccessorType type) {
  return chooseWeapon("chooseWeapon", type);
}

std::unique_ptr<EntityIdentityChoiceType> EntityIdentityChoiceType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityIdentityChoiceType : type};
  return (requestedType == uci::type::accessorType::entityIdentityChoiceType) ? boost::make_unique<EntityIdentityChoiceType>() : nullptr;
}

/**  */
namespace EntityIdentityChoiceType_Names {

constexpr const char* Extern_Type_Name{"EntityIdentityChoiceType"};
constexpr const char* Standard_Name{"Standard"};
constexpr const char* Environment_Name{"Environment"};
constexpr const char* Platform_Name{"Platform"};
constexpr const char* Specific_Name{"Specific"};
constexpr const char* Emitter_Name{"Emitter"};
constexpr const char* SpecificEmitter_Name{"SpecificEmitter"};
constexpr const char* SpecificVehicle_Name{"SpecificVehicle"};
constexpr const char* SpecificFacility_Name{"SpecificFacility"};
constexpr const char* EOB_Name{"EOB"};
constexpr const char* Weapon_Name{"Weapon"};

} // namespace EntityIdentityChoiceType_Names

void EntityIdentityChoiceType::deserialize(const boost::property_tree::ptree& propTree, uci::type::EntityIdentityChoiceType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = EntityIdentityChoiceType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::Standard_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseStandard(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::Environment_Name) {
      EnvironmentIdentityType::deserialize(valueType.second, accessor.chooseEnvironment(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::Platform_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.choosePlatform(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::Specific_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseSpecific(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::Emitter_Name) {
      EmitterIdentityType::deserialize(valueType.second, accessor.chooseEmitter(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::SpecificEmitter_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseSpecificEmitter(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::SpecificVehicle_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseSpecificVehicle(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::SpecificFacility_Name) {
      FacilityIdentificationType::deserialize(valueType.second, accessor.chooseSpecificFacility(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::EOB_Name) {
      EOB_IdentityType::deserialize(valueType.second, accessor.chooseEOB(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityIdentityChoiceType_Names::Weapon_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.chooseWeapon(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    }
  }
}

std::string EntityIdentityChoiceType::serialize(const uci::type::EntityIdentityChoiceType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? EntityIdentityChoiceType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, EntityIdentityChoiceType_Names::Extern_Type_Name);
  }
  if (accessor.isStandard()) {
    StandardIdentityType::serialize(accessor.getStandard(), node, EntityIdentityChoiceType_Names::Standard_Name);
  } else if (accessor.isEnvironment()) {
    EnvironmentIdentityType::serialize(accessor.getEnvironment(), node, EntityIdentityChoiceType_Names::Environment_Name);
  } else if (accessor.isPlatform()) {
    PlatformIdentityType::serialize(accessor.getPlatform(), node, EntityIdentityChoiceType_Names::Platform_Name);
  } else if (accessor.isSpecific()) {
    SpecificIdentityType::serialize(accessor.getSpecific(), node, EntityIdentityChoiceType_Names::Specific_Name);
  } else if (accessor.isEmitter()) {
    EmitterIdentityType::serialize(accessor.getEmitter(), node, EntityIdentityChoiceType_Names::Emitter_Name);
  } else if (accessor.isSpecificEmitter()) {
    SpecificEmitterIdentityType::serialize(accessor.getSpecificEmitter(), node, EntityIdentityChoiceType_Names::SpecificEmitter_Name);
  } else if (accessor.isSpecificVehicle()) {
    VehicleIdentificationType::serialize(accessor.getSpecificVehicle(), node, EntityIdentityChoiceType_Names::SpecificVehicle_Name);
  } else if (accessor.isSpecificFacility()) {
    FacilityIdentificationType::serialize(accessor.getSpecificFacility(), node, EntityIdentityChoiceType_Names::SpecificFacility_Name);
  } else if (accessor.isEOB()) {
    EOB_IdentityType::serialize(accessor.getEOB(), node, EntityIdentityChoiceType_Names::EOB_Name);
  } else if (accessor.isWeapon()) {
    StoreType::serialize(accessor.getWeapon(), node, EntityIdentityChoiceType_Names::Weapon_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::EntityIdentityChoiceType>().release());
}

uci::type::EntityIdentityChoiceType& EntityIdentityChoiceType::create(const uci::type::EntityIdentityChoiceType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::EntityIdentityChoiceType> newAccessor{boost::make_unique<asb_uci::type::EntityIdentityChoiceType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void EntityIdentityChoiceType::destroy(uci::type::EntityIdentityChoiceType& accessor) {
  delete dynamic_cast<asb_uci::type::EntityIdentityChoiceType*>(&accessor);
}

} // namespace type

} // namespace uci

