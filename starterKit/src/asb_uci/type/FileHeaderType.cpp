/** @file FileHeaderType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:13 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/FileHeaderType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/AlphanumericPunctuatedString11Type.h"
#include "asb_uci/type/AlphanumericSpaceString11Type.h"
#include "asb_uci/type/CountryCodeType.h"
#include "asb_uci/type/FIPS_ClassificationSystemType.h"
#include "asb_uci/type/FileDeclassificationEnum.h"
#include "asb_uci/type/FileHeaderClassificationAuthorityType.h"
#include "asb_uci/type/FileHeaderDowngradeStringType.h"
#include "asb_uci/type/NumericSpaceString11Type.h"
#include "asb_uci/type/SAR_CollectionReasonEnum.h"
#include "asb_uci/type/VisibleString16Type.h"
#include "asb_uci/type/VisibleString3Type.h"
#include "asb_uci/type/VisibleString80Type.h"
#include "asb_uci/type/VisibleString9Type.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/AlphanumericPunctuatedString11Type.h"
#include "uci/type/AlphanumericSpaceString11Type.h"
#include "uci/type/CountryCodeType.h"
#include "uci/type/FIPS_ClassificationSystemType.h"
#include "uci/type/FileDeclassificationEnum.h"
#include "uci/type/FileHeaderClassificationAuthorityType.h"
#include "uci/type/FileHeaderDowngradeStringType.h"
#include "uci/type/FileHeaderType.h"
#include "uci/type/NumericSpaceString11Type.h"
#include "uci/type/SAR_CollectionReasonEnum.h"
#include "uci/type/VisibleString16Type.h"
#include "uci/type/VisibleString3Type.h"
#include "uci/type/VisibleString80Type.h"
#include "uci/type/VisibleString9Type.h"
#include "xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

FileHeaderType::FileHeaderType() = default;

FileHeaderType::~FileHeaderType() = default;

void FileHeaderType::copy(const uci::type::FileHeaderType& accessor) {
  copyImpl(accessor, false);
}

void FileHeaderType::copyImpl(const uci::type::FileHeaderType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const FileHeaderType&>(accessor);
    if (accessorImpl.countryCode_Accessor) {
      setCountryCode(*(accessorImpl.countryCode_Accessor));
    } else {
      countryCode_Accessor.reset();
    }
    if (accessorImpl.sceneSource_Accessor) {
      setSceneSource(*(accessorImpl.sceneSource_Accessor));
    } else {
      sceneSource_Accessor.reset();
    }
    if (accessorImpl.originatingStationIdentifier_Accessor) {
      setOriginatingStationIdentifier(*(accessorImpl.originatingStationIdentifier_Accessor));
    } else {
      originatingStationIdentifier_Accessor.reset();
    }
    if (accessorImpl.hasCollectionIdentifier()) {
      setCollectionIdentifier(accessorImpl.getCollectionIdentifier());
    } else {
      clearCollectionIdentifier();
    }
    if (accessorImpl.fileTitle_Accessor) {
      setFileTitle(*(accessorImpl.fileTitle_Accessor));
    } else {
      fileTitle_Accessor.reset();
    }
    if (accessorImpl.originatorsName_Accessor) {
      setOriginatorsName(*(accessorImpl.originatorsName_Accessor));
    } else {
      originatorsName_Accessor.reset();
    }
    if (accessorImpl.originatorsPhone_Accessor) {
      setOriginatorsPhone(*(accessorImpl.originatorsPhone_Accessor));
    } else {
      originatorsPhone_Accessor.reset();
    }
    if (accessorImpl.fileClassificationSystem_Accessor) {
      setFileClassificationSystem(*(accessorImpl.fileClassificationSystem_Accessor));
    } else {
      fileClassificationSystem_Accessor.reset();
    }
    if (accessorImpl.fileSecurityControlNumber_Accessor) {
      setFileSecurityControlNumber(*(accessorImpl.fileSecurityControlNumber_Accessor));
    } else {
      fileSecurityControlNumber_Accessor.reset();
    }
    if (accessorImpl.fileControlAndHandling_Accessor) {
      setFileControlAndHandling(*(accessorImpl.fileControlAndHandling_Accessor));
    } else {
      fileControlAndHandling_Accessor.reset();
    }
    if (accessorImpl.fileDeclassificationType_Accessor) {
      setFileDeclassificationType(*(accessorImpl.fileDeclassificationType_Accessor));
    } else {
      fileDeclassificationType_Accessor.reset();
    }
    if (accessorImpl.fileClassificationAuthorityType_Accessor) {
      setFileClassificationAuthorityType(*(accessorImpl.fileClassificationAuthorityType_Accessor));
    } else {
      fileClassificationAuthorityType_Accessor.reset();
    }
    if (accessorImpl.fileDowngrade_Accessor) {
      setFileDowngrade(*(accessorImpl.fileDowngrade_Accessor));
    } else {
      fileDowngrade_Accessor.reset();
    }
    if (accessorImpl.fileSecuritySourceDate_Accessor) {
      setFileSecuritySourceDate(*(accessorImpl.fileSecuritySourceDate_Accessor));
    } else {
      fileSecuritySourceDate_Accessor.reset();
    }
  }
}

void FileHeaderType::reset() noexcept {
  countryCode_Accessor.reset();
  sceneSource_Accessor.reset();
  originatingStationIdentifier_Accessor.reset();
  clearCollectionIdentifier();
  fileTitle_Accessor.reset();
  originatorsName_Accessor.reset();
  originatorsPhone_Accessor.reset();
  fileClassificationSystem_Accessor.reset();
  fileSecurityControlNumber_Accessor.reset();
  fileControlAndHandling_Accessor.reset();
  fileDeclassificationType_Accessor.reset();
  fileClassificationAuthorityType_Accessor.reset();
  fileDowngrade_Accessor.reset();
  fileSecuritySourceDate_Accessor.reset();
}

uci::type::CountryCodeType& FileHeaderType::getCountryCode_() const {
  if (countryCode_Accessor) {
    return *countryCode_Accessor;
  }
  throw uci::base::UCIException("Error in getCountryCode(): An attempt was made to get an optional field that was not enabled, call hasCountryCode() to determine if it is safe to call getCountryCode()");
}

const uci::type::CountryCodeType& FileHeaderType::getCountryCode() const {
  return getCountryCode_();
}

uci::type::CountryCodeType& FileHeaderType::getCountryCode() {
  return getCountryCode_();
}

uci::type::FileHeaderType& FileHeaderType::setCountryCode(const uci::type::CountryCodeType& accessor) {
  enableCountryCode();
  if (&accessor != countryCode_Accessor.get()) {
    countryCode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool FileHeaderType::hasCountryCode() const noexcept {
  return static_cast<bool>(countryCode_Accessor);
}

uci::type::CountryCodeType& FileHeaderType::enableCountryCode(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::countryCodeType : type};
  if ((!countryCode_Accessor) || (countryCode_Accessor->getAccessorType() != requestedType)) {
    countryCode_Accessor = CountryCodeType::create(requestedType);
    if (!countryCode_Accessor) {
      throw uci::base::UCIException("Error in enableCountryCode(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *countryCode_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearCountryCode() noexcept {
  countryCode_Accessor.reset();
  return *this;
}

uci::type::SAR_CollectionReasonEnum& FileHeaderType::getSceneSource_() const {
  if (sceneSource_Accessor) {
    return *sceneSource_Accessor;
  }
  throw uci::base::UCIException("Error in getSceneSource(): An attempt was made to get an optional field that was not enabled, call hasSceneSource() to determine if it is safe to call getSceneSource()");
}

const uci::type::SAR_CollectionReasonEnum& FileHeaderType::getSceneSource() const {
  return getSceneSource_();
}

uci::type::SAR_CollectionReasonEnum& FileHeaderType::getSceneSource() {
  return getSceneSource_();
}

uci::type::FileHeaderType& FileHeaderType::setSceneSource(const uci::type::SAR_CollectionReasonEnum& accessor) {
  enableSceneSource();
  if (&accessor != sceneSource_Accessor.get()) {
    sceneSource_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::FileHeaderType& FileHeaderType::setSceneSource(const uci::type::SAR_CollectionReasonEnum::EnumerationItem value) {
  enableSceneSource().setValue(value);
  return *this;
}

bool FileHeaderType::hasSceneSource() const noexcept {
  return static_cast<bool>(sceneSource_Accessor);
}

uci::type::SAR_CollectionReasonEnum& FileHeaderType::enableSceneSource(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::sAR_CollectionReasonEnum : type};
  if ((!sceneSource_Accessor) || (sceneSource_Accessor->getAccessorType() != requestedType)) {
    sceneSource_Accessor = SAR_CollectionReasonEnum::create(requestedType);
    if (!sceneSource_Accessor) {
      throw uci::base::UCIException("Error in enableSceneSource(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *sceneSource_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearSceneSource() noexcept {
  sceneSource_Accessor.reset();
  return *this;
}

uci::type::AlphanumericPunctuatedString11Type& FileHeaderType::getOriginatingStationIdentifier_() const {
  if (originatingStationIdentifier_Accessor) {
    return *originatingStationIdentifier_Accessor;
  }
  throw uci::base::UCIException("Error in getOriginatingStationIdentifier(): An attempt was made to get an optional field that was not enabled, call hasOriginatingStationIdentifier() to determine if it is safe to call getOriginatingStationIdentifier()");
}

const uci::type::AlphanumericPunctuatedString11Type& FileHeaderType::getOriginatingStationIdentifier() const {
  return getOriginatingStationIdentifier_();
}

uci::type::AlphanumericPunctuatedString11Type& FileHeaderType::getOriginatingStationIdentifier() {
  return getOriginatingStationIdentifier_();
}

uci::type::FileHeaderType& FileHeaderType::setOriginatingStationIdentifier(const uci::type::AlphanumericPunctuatedString11Type& value) {
  return setOriginatingStationIdentifier(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setOriginatingStationIdentifier(const std::string& value) {
  return setOriginatingStationIdentifier(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setOriginatingStationIdentifier(const char* value) {
  enableOriginatingStationIdentifier().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasOriginatingStationIdentifier() const noexcept {
  return static_cast<bool>(originatingStationIdentifier_Accessor);
}

uci::type::AlphanumericPunctuatedString11Type& FileHeaderType::enableOriginatingStationIdentifier(uci::base::accessorType::AccessorType type) {
  if (!originatingStationIdentifier_Accessor) {
    originatingStationIdentifier_Accessor = AlphanumericPunctuatedString11Type::create(type);
  }
  return *originatingStationIdentifier_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearOriginatingStationIdentifier() noexcept {
  originatingStationIdentifier_Accessor.reset();
  return *this;
}

xs::UnsignedInt FileHeaderType::getCollectionIdentifier() const {
  if (collectionIdentifier_Accessor) {
    return *collectionIdentifier_Accessor;
  }
  throw uci::base::UCIException("Error in getCollectionIdentifier(): An attempt was made to get an optional field that was not enabled, call hasCollectionIdentifier() to determine if it is safe to call getCollectionIdentifier()");
}

uci::type::FileHeaderType& FileHeaderType::setCollectionIdentifier(xs::UnsignedInt value) {
  collectionIdentifier_Accessor = value;
  return *this;
}

bool FileHeaderType::hasCollectionIdentifier() const noexcept {
  return collectionIdentifier_Accessor.has_value();
}

uci::type::FileHeaderType& FileHeaderType::clearCollectionIdentifier() noexcept {
  collectionIdentifier_Accessor.reset();
  return *this;
}

uci::type::VisibleString80Type& FileHeaderType::getFileTitle_() const {
  if (fileTitle_Accessor) {
    return *fileTitle_Accessor;
  }
  throw uci::base::UCIException("Error in getFileTitle(): An attempt was made to get an optional field that was not enabled, call hasFileTitle() to determine if it is safe to call getFileTitle()");
}

const uci::type::VisibleString80Type& FileHeaderType::getFileTitle() const {
  return getFileTitle_();
}

uci::type::VisibleString80Type& FileHeaderType::getFileTitle() {
  return getFileTitle_();
}

uci::type::FileHeaderType& FileHeaderType::setFileTitle(const uci::type::VisibleString80Type& value) {
  return setFileTitle(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileTitle(const std::string& value) {
  return setFileTitle(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileTitle(const char* value) {
  enableFileTitle().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasFileTitle() const noexcept {
  return static_cast<bool>(fileTitle_Accessor);
}

uci::type::VisibleString80Type& FileHeaderType::enableFileTitle(uci::base::accessorType::AccessorType type) {
  if (!fileTitle_Accessor) {
    fileTitle_Accessor = VisibleString80Type::create(type);
  }
  return *fileTitle_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearFileTitle() noexcept {
  fileTitle_Accessor.reset();
  return *this;
}

uci::type::AlphanumericSpaceString11Type& FileHeaderType::getOriginatorsName_() const {
  if (originatorsName_Accessor) {
    return *originatorsName_Accessor;
  }
  throw uci::base::UCIException("Error in getOriginatorsName(): An attempt was made to get an optional field that was not enabled, call hasOriginatorsName() to determine if it is safe to call getOriginatorsName()");
}

const uci::type::AlphanumericSpaceString11Type& FileHeaderType::getOriginatorsName() const {
  return getOriginatorsName_();
}

uci::type::AlphanumericSpaceString11Type& FileHeaderType::getOriginatorsName() {
  return getOriginatorsName_();
}

uci::type::FileHeaderType& FileHeaderType::setOriginatorsName(const uci::type::AlphanumericSpaceString11Type& value) {
  return setOriginatorsName(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setOriginatorsName(const std::string& value) {
  return setOriginatorsName(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setOriginatorsName(const char* value) {
  enableOriginatorsName().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasOriginatorsName() const noexcept {
  return static_cast<bool>(originatorsName_Accessor);
}

uci::type::AlphanumericSpaceString11Type& FileHeaderType::enableOriginatorsName(uci::base::accessorType::AccessorType type) {
  if (!originatorsName_Accessor) {
    originatorsName_Accessor = AlphanumericSpaceString11Type::create(type);
  }
  return *originatorsName_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearOriginatorsName() noexcept {
  originatorsName_Accessor.reset();
  return *this;
}

uci::type::NumericSpaceString11Type& FileHeaderType::getOriginatorsPhone_() const {
  if (originatorsPhone_Accessor) {
    return *originatorsPhone_Accessor;
  }
  throw uci::base::UCIException("Error in getOriginatorsPhone(): An attempt was made to get an optional field that was not enabled, call hasOriginatorsPhone() to determine if it is safe to call getOriginatorsPhone()");
}

const uci::type::NumericSpaceString11Type& FileHeaderType::getOriginatorsPhone() const {
  return getOriginatorsPhone_();
}

uci::type::NumericSpaceString11Type& FileHeaderType::getOriginatorsPhone() {
  return getOriginatorsPhone_();
}

uci::type::FileHeaderType& FileHeaderType::setOriginatorsPhone(const uci::type::NumericSpaceString11Type& value) {
  return setOriginatorsPhone(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setOriginatorsPhone(const std::string& value) {
  return setOriginatorsPhone(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setOriginatorsPhone(const char* value) {
  enableOriginatorsPhone().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasOriginatorsPhone() const noexcept {
  return static_cast<bool>(originatorsPhone_Accessor);
}

uci::type::NumericSpaceString11Type& FileHeaderType::enableOriginatorsPhone(uci::base::accessorType::AccessorType type) {
  if (!originatorsPhone_Accessor) {
    originatorsPhone_Accessor = NumericSpaceString11Type::create(type);
  }
  return *originatorsPhone_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearOriginatorsPhone() noexcept {
  originatorsPhone_Accessor.reset();
  return *this;
}

uci::type::FIPS_ClassificationSystemType& FileHeaderType::getFileClassificationSystem_() const {
  if (fileClassificationSystem_Accessor) {
    return *fileClassificationSystem_Accessor;
  }
  throw uci::base::UCIException("Error in getFileClassificationSystem(): An attempt was made to get an optional field that was not enabled, call hasFileClassificationSystem() to determine if it is safe to call getFileClassificationSystem()");
}

const uci::type::FIPS_ClassificationSystemType& FileHeaderType::getFileClassificationSystem() const {
  return getFileClassificationSystem_();
}

uci::type::FIPS_ClassificationSystemType& FileHeaderType::getFileClassificationSystem() {
  return getFileClassificationSystem_();
}

uci::type::FileHeaderType& FileHeaderType::setFileClassificationSystem(const uci::type::FIPS_ClassificationSystemType& value) {
  return setFileClassificationSystem(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileClassificationSystem(const std::string& value) {
  return setFileClassificationSystem(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileClassificationSystem(const char* value) {
  enableFileClassificationSystem().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasFileClassificationSystem() const noexcept {
  return static_cast<bool>(fileClassificationSystem_Accessor);
}

uci::type::FIPS_ClassificationSystemType& FileHeaderType::enableFileClassificationSystem(uci::base::accessorType::AccessorType type) {
  if (!fileClassificationSystem_Accessor) {
    fileClassificationSystem_Accessor = FIPS_ClassificationSystemType::create(type);
  }
  return *fileClassificationSystem_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearFileClassificationSystem() noexcept {
  fileClassificationSystem_Accessor.reset();
  return *this;
}

uci::type::VisibleString16Type& FileHeaderType::getFileSecurityControlNumber_() const {
  if (fileSecurityControlNumber_Accessor) {
    return *fileSecurityControlNumber_Accessor;
  }
  throw uci::base::UCIException("Error in getFileSecurityControlNumber(): An attempt was made to get an optional field that was not enabled, call hasFileSecurityControlNumber() to determine if it is safe to call getFileSecurityControlNumber()");
}

const uci::type::VisibleString16Type& FileHeaderType::getFileSecurityControlNumber() const {
  return getFileSecurityControlNumber_();
}

uci::type::VisibleString16Type& FileHeaderType::getFileSecurityControlNumber() {
  return getFileSecurityControlNumber_();
}

uci::type::FileHeaderType& FileHeaderType::setFileSecurityControlNumber(const uci::type::VisibleString16Type& value) {
  return setFileSecurityControlNumber(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileSecurityControlNumber(const std::string& value) {
  return setFileSecurityControlNumber(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileSecurityControlNumber(const char* value) {
  enableFileSecurityControlNumber().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasFileSecurityControlNumber() const noexcept {
  return static_cast<bool>(fileSecurityControlNumber_Accessor);
}

uci::type::VisibleString16Type& FileHeaderType::enableFileSecurityControlNumber(uci::base::accessorType::AccessorType type) {
  if (!fileSecurityControlNumber_Accessor) {
    fileSecurityControlNumber_Accessor = VisibleString16Type::create(type);
  }
  return *fileSecurityControlNumber_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearFileSecurityControlNumber() noexcept {
  fileSecurityControlNumber_Accessor.reset();
  return *this;
}

uci::type::VisibleString3Type& FileHeaderType::getFileControlAndHandling_() const {
  if (fileControlAndHandling_Accessor) {
    return *fileControlAndHandling_Accessor;
  }
  throw uci::base::UCIException("Error in getFileControlAndHandling(): An attempt was made to get an optional field that was not enabled, call hasFileControlAndHandling() to determine if it is safe to call getFileControlAndHandling()");
}

const uci::type::VisibleString3Type& FileHeaderType::getFileControlAndHandling() const {
  return getFileControlAndHandling_();
}

uci::type::VisibleString3Type& FileHeaderType::getFileControlAndHandling() {
  return getFileControlAndHandling_();
}

uci::type::FileHeaderType& FileHeaderType::setFileControlAndHandling(const uci::type::VisibleString3Type& value) {
  return setFileControlAndHandling(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileControlAndHandling(const std::string& value) {
  return setFileControlAndHandling(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileControlAndHandling(const char* value) {
  enableFileControlAndHandling().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasFileControlAndHandling() const noexcept {
  return static_cast<bool>(fileControlAndHandling_Accessor);
}

uci::type::VisibleString3Type& FileHeaderType::enableFileControlAndHandling(uci::base::accessorType::AccessorType type) {
  if (!fileControlAndHandling_Accessor) {
    fileControlAndHandling_Accessor = VisibleString3Type::create(type);
  }
  return *fileControlAndHandling_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearFileControlAndHandling() noexcept {
  fileControlAndHandling_Accessor.reset();
  return *this;
}

uci::type::FileDeclassificationEnum& FileHeaderType::getFileDeclassificationType_() const {
  if (fileDeclassificationType_Accessor) {
    return *fileDeclassificationType_Accessor;
  }
  throw uci::base::UCIException("Error in getFileDeclassificationType(): An attempt was made to get an optional field that was not enabled, call hasFileDeclassificationType() to determine if it is safe to call getFileDeclassificationType()");
}

const uci::type::FileDeclassificationEnum& FileHeaderType::getFileDeclassificationType() const {
  return getFileDeclassificationType_();
}

uci::type::FileDeclassificationEnum& FileHeaderType::getFileDeclassificationType() {
  return getFileDeclassificationType_();
}

uci::type::FileHeaderType& FileHeaderType::setFileDeclassificationType(const uci::type::FileDeclassificationEnum& accessor) {
  enableFileDeclassificationType();
  if (&accessor != fileDeclassificationType_Accessor.get()) {
    fileDeclassificationType_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::FileHeaderType& FileHeaderType::setFileDeclassificationType(const uci::type::FileDeclassificationEnum::EnumerationItem value) {
  enableFileDeclassificationType().setValue(value);
  return *this;
}

bool FileHeaderType::hasFileDeclassificationType() const noexcept {
  return static_cast<bool>(fileDeclassificationType_Accessor);
}

uci::type::FileDeclassificationEnum& FileHeaderType::enableFileDeclassificationType(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::fileDeclassificationEnum : type};
  if ((!fileDeclassificationType_Accessor) || (fileDeclassificationType_Accessor->getAccessorType() != requestedType)) {
    fileDeclassificationType_Accessor = FileDeclassificationEnum::create(requestedType);
    if (!fileDeclassificationType_Accessor) {
      throw uci::base::UCIException("Error in enableFileDeclassificationType(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *fileDeclassificationType_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearFileDeclassificationType() noexcept {
  fileDeclassificationType_Accessor.reset();
  return *this;
}

uci::type::FileHeaderClassificationAuthorityType& FileHeaderType::getFileClassificationAuthorityType_() const {
  if (fileClassificationAuthorityType_Accessor) {
    return *fileClassificationAuthorityType_Accessor;
  }
  throw uci::base::UCIException("Error in getFileClassificationAuthorityType(): An attempt was made to get an optional field that was not enabled, call hasFileClassificationAuthorityType() to determine if it is safe to call getFileClassificationAuthorityType()");
}

const uci::type::FileHeaderClassificationAuthorityType& FileHeaderType::getFileClassificationAuthorityType() const {
  return getFileClassificationAuthorityType_();
}

uci::type::FileHeaderClassificationAuthorityType& FileHeaderType::getFileClassificationAuthorityType() {
  return getFileClassificationAuthorityType_();
}

uci::type::FileHeaderType& FileHeaderType::setFileClassificationAuthorityType(const uci::type::FileHeaderClassificationAuthorityType& value) {
  return setFileClassificationAuthorityType(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileClassificationAuthorityType(const std::string& value) {
  return setFileClassificationAuthorityType(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileClassificationAuthorityType(const char* value) {
  enableFileClassificationAuthorityType().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasFileClassificationAuthorityType() const noexcept {
  return static_cast<bool>(fileClassificationAuthorityType_Accessor);
}

uci::type::FileHeaderClassificationAuthorityType& FileHeaderType::enableFileClassificationAuthorityType(uci::base::accessorType::AccessorType type) {
  if (!fileClassificationAuthorityType_Accessor) {
    fileClassificationAuthorityType_Accessor = FileHeaderClassificationAuthorityType::create(type);
  }
  return *fileClassificationAuthorityType_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearFileClassificationAuthorityType() noexcept {
  fileClassificationAuthorityType_Accessor.reset();
  return *this;
}

uci::type::FileHeaderDowngradeStringType& FileHeaderType::getFileDowngrade_() const {
  if (fileDowngrade_Accessor) {
    return *fileDowngrade_Accessor;
  }
  throw uci::base::UCIException("Error in getFileDowngrade(): An attempt was made to get an optional field that was not enabled, call hasFileDowngrade() to determine if it is safe to call getFileDowngrade()");
}

const uci::type::FileHeaderDowngradeStringType& FileHeaderType::getFileDowngrade() const {
  return getFileDowngrade_();
}

uci::type::FileHeaderDowngradeStringType& FileHeaderType::getFileDowngrade() {
  return getFileDowngrade_();
}

uci::type::FileHeaderType& FileHeaderType::setFileDowngrade(const uci::type::FileHeaderDowngradeStringType& value) {
  return setFileDowngrade(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileDowngrade(const std::string& value) {
  return setFileDowngrade(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileDowngrade(const char* value) {
  enableFileDowngrade().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasFileDowngrade() const noexcept {
  return static_cast<bool>(fileDowngrade_Accessor);
}

uci::type::FileHeaderDowngradeStringType& FileHeaderType::enableFileDowngrade(uci::base::accessorType::AccessorType type) {
  if (!fileDowngrade_Accessor) {
    fileDowngrade_Accessor = FileHeaderDowngradeStringType::create(type);
  }
  return *fileDowngrade_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearFileDowngrade() noexcept {
  fileDowngrade_Accessor.reset();
  return *this;
}

uci::type::VisibleString9Type& FileHeaderType::getFileSecuritySourceDate_() const {
  if (fileSecuritySourceDate_Accessor) {
    return *fileSecuritySourceDate_Accessor;
  }
  throw uci::base::UCIException("Error in getFileSecuritySourceDate(): An attempt was made to get an optional field that was not enabled, call hasFileSecuritySourceDate() to determine if it is safe to call getFileSecuritySourceDate()");
}

const uci::type::VisibleString9Type& FileHeaderType::getFileSecuritySourceDate() const {
  return getFileSecuritySourceDate_();
}

uci::type::VisibleString9Type& FileHeaderType::getFileSecuritySourceDate() {
  return getFileSecuritySourceDate_();
}

uci::type::FileHeaderType& FileHeaderType::setFileSecuritySourceDate(const uci::type::VisibleString9Type& value) {
  return setFileSecuritySourceDate(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileSecuritySourceDate(const std::string& value) {
  return setFileSecuritySourceDate(value.c_str());
}

uci::type::FileHeaderType& FileHeaderType::setFileSecuritySourceDate(const char* value) {
  enableFileSecuritySourceDate().setStringValue(value);
  return *this;
}

bool FileHeaderType::hasFileSecuritySourceDate() const noexcept {
  return static_cast<bool>(fileSecuritySourceDate_Accessor);
}

uci::type::VisibleString9Type& FileHeaderType::enableFileSecuritySourceDate(uci::base::accessorType::AccessorType type) {
  if (!fileSecuritySourceDate_Accessor) {
    fileSecuritySourceDate_Accessor = VisibleString9Type::create(type);
  }
  return *fileSecuritySourceDate_Accessor;
}

uci::type::FileHeaderType& FileHeaderType::clearFileSecuritySourceDate() noexcept {
  fileSecuritySourceDate_Accessor.reset();
  return *this;
}

std::unique_ptr<FileHeaderType> FileHeaderType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::fileHeaderType : type};
  return (requestedType == uci::type::accessorType::fileHeaderType) ? boost::make_unique<FileHeaderType>() : nullptr;
}

/**  */
namespace FileHeaderType_Names {

constexpr const char* Extern_Type_Name{"FileHeaderType"};
constexpr const char* CountryCode_Name{"CountryCode"};
constexpr const char* SceneSource_Name{"SceneSource"};
constexpr const char* OriginatingStationIdentifier_Name{"OriginatingStationIdentifier"};
constexpr const char* CollectionIdentifier_Name{"CollectionIdentifier"};
constexpr const char* FileTitle_Name{"FileTitle"};
constexpr const char* OriginatorsName_Name{"OriginatorsName"};
constexpr const char* OriginatorsPhone_Name{"OriginatorsPhone"};
constexpr const char* FileClassificationSystem_Name{"FileClassificationSystem"};
constexpr const char* FileSecurityControlNumber_Name{"FileSecurityControlNumber"};
constexpr const char* FileControlAndHandling_Name{"FileControlAndHandling"};
constexpr const char* FileDeclassificationType_Name{"FileDeclassificationType"};
constexpr const char* FileClassificationAuthorityType_Name{"FileClassificationAuthorityType"};
constexpr const char* FileDowngrade_Name{"FileDowngrade"};
constexpr const char* FileSecuritySourceDate_Name{"FileSecuritySourceDate"};

} // namespace FileHeaderType_Names

void FileHeaderType::deserialize(const boost::property_tree::ptree& propTree, uci::type::FileHeaderType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = FileHeaderType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::CountryCode_Name) {
      CountryCodeType::deserialize(valueType.second, accessor.enableCountryCode(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::SceneSource_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableSceneSource().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::OriginatingStationIdentifier_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setOriginatingStationIdentifier(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::CollectionIdentifier_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setCollectionIdentifier(asb_uci::util::SerializationHelpers::deserializeUnsignedInt(*value));
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::FileTitle_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileTitle(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::OriginatorsName_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setOriginatorsName(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::OriginatorsPhone_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setOriginatorsPhone(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::FileClassificationSystem_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileClassificationSystem(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::FileSecurityControlNumber_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileSecurityControlNumber(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::FileControlAndHandling_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileControlAndHandling(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::FileDeclassificationType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableFileDeclassificationType().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::FileClassificationAuthorityType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileClassificationAuthorityType(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::FileDowngrade_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileDowngrade(*value);
      }
    } else if (valueType.first == nsPrefix + FileHeaderType_Names::FileSecuritySourceDate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFileSecuritySourceDate(*value);
      }
    }
  }
}

std::string FileHeaderType::serialize(const uci::type::FileHeaderType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? FileHeaderType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, FileHeaderType_Names::Extern_Type_Name);
  }
  if (accessor.hasCountryCode()) {
    CountryCodeType::serialize(accessor.getCountryCode(), node, FileHeaderType_Names::CountryCode_Name);
  }
  if (accessor.hasSceneSource()) {
    SAR_CollectionReasonEnum::serialize(accessor.getSceneSource(), node, FileHeaderType_Names::SceneSource_Name, false);
  }
  if (accessor.hasOriginatingStationIdentifier()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getOriginatingStationIdentifier(), node, FileHeaderType_Names::OriginatingStationIdentifier_Name);
  }
  if (accessor.hasCollectionIdentifier()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedInt(accessor.getCollectionIdentifier(), node, FileHeaderType_Names::CollectionIdentifier_Name);
  }
  if (accessor.hasFileTitle()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileTitle(), node, FileHeaderType_Names::FileTitle_Name);
  }
  if (accessor.hasOriginatorsName()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getOriginatorsName(), node, FileHeaderType_Names::OriginatorsName_Name);
  }
  if (accessor.hasOriginatorsPhone()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getOriginatorsPhone(), node, FileHeaderType_Names::OriginatorsPhone_Name);
  }
  if (accessor.hasFileClassificationSystem()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileClassificationSystem(), node, FileHeaderType_Names::FileClassificationSystem_Name);
  }
  if (accessor.hasFileSecurityControlNumber()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileSecurityControlNumber(), node, FileHeaderType_Names::FileSecurityControlNumber_Name);
  }
  if (accessor.hasFileControlAndHandling()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileControlAndHandling(), node, FileHeaderType_Names::FileControlAndHandling_Name);
  }
  if (accessor.hasFileDeclassificationType()) {
    FileDeclassificationEnum::serialize(accessor.getFileDeclassificationType(), node, FileHeaderType_Names::FileDeclassificationType_Name, false);
  }
  if (accessor.hasFileClassificationAuthorityType()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileClassificationAuthorityType(), node, FileHeaderType_Names::FileClassificationAuthorityType_Name);
  }
  if (accessor.hasFileDowngrade()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileDowngrade(), node, FileHeaderType_Names::FileDowngrade_Name);
  }
  if (accessor.hasFileSecuritySourceDate()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFileSecuritySourceDate(), node, FileHeaderType_Names::FileSecuritySourceDate_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::FileHeaderType& FileHeaderType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::FileHeaderType>().release());
}

uci::type::FileHeaderType& FileHeaderType::create(const uci::type::FileHeaderType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::FileHeaderType> newAccessor{boost::make_unique<asb_uci::type::FileHeaderType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void FileHeaderType::destroy(uci::type::FileHeaderType& accessor) {
  delete dynamic_cast<asb_uci::type::FileHeaderType*>(&accessor);
}

} // namespace type

} // namespace uci

