/** @file CommMADL_LinkStatusType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:12 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/CommMADL_LinkStatusType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/CommMADL_DataRateTypeEnum.h"
#include "../../../include/asb_uci/type/CommMADL_LinkStateEnum.h"
#include "../../../include/asb_uci/type/CommMADL_PeerNodeDataType.h"
#include "../../../include/asb_uci/type/CommMADL_SearchTypeEnum.h"
#include "../../../include/asb_uci/type/CommMADL_TimeSlotOE_PhaseTypeEnum.h"
#include "../../../include/asb_uci/type/CommMADL_TimeSlotTxPhaseTypeEnum.h"
#include "../../../include/asb_uci/type/CommMADL_TopologyEntryType.h"
#include "../../../include/asb_uci/type/CommMADL_VoiceRxIndicatorTypeEnum.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_DataRateTypeEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_LinkStateEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_LinkStatusType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_PeerNodeDataType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_SearchTypeEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_TimeSlotOE_PhaseTypeEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_TimeSlotTxPhaseTypeEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_TopologyEntryType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CommMADL_VoiceRxIndicatorTypeEnum.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

CommMADL_LinkStatusType::CommMADL_LinkStatusType()
  : linkState_Accessor{boost::make_unique<CommMADL_LinkStateEnum>()},
    memberTopology_Accessor{boost::make_unique<MemberTopology>(0, 64)} {
}

CommMADL_LinkStatusType::~CommMADL_LinkStatusType() = default;

void CommMADL_LinkStatusType::copy(const uci::type::CommMADL_LinkStatusType& accessor) {
  copyImpl(accessor, false);
}

void CommMADL_LinkStatusType::copyImpl(const uci::type::CommMADL_LinkStatusType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const CommMADL_LinkStatusType&>(accessor);
    setLinkState(*(accessorImpl.linkState_Accessor));
    if (accessorImpl.receivedDataRate_Accessor) {
      setReceivedDataRate(*(accessorImpl.receivedDataRate_Accessor));
    } else {
      receivedDataRate_Accessor.reset();
    }
    if (accessorImpl.actualTxDataRate_Accessor) {
      setActualTxDataRate(*(accessorImpl.actualTxDataRate_Accessor));
    } else {
      actualTxDataRate_Accessor.reset();
    }
    if (accessorImpl.hasHigherDataRateCapable()) {
      setHigherDataRateCapable(accessorImpl.getHigherDataRateCapable());
    } else {
      clearHigherDataRateCapable();
    }
    if (accessorImpl.voiceReceiptIndicator_Accessor) {
      setVoiceReceiptIndicator(*(accessorImpl.voiceReceiptIndicator_Accessor));
    } else {
      voiceReceiptIndicator_Accessor.reset();
    }
    if (accessorImpl.hasVoiceSource()) {
      setVoiceSource(accessorImpl.getVoiceSource());
    } else {
      clearVoiceSource();
    }
    if (accessorImpl.peerNodeData_Accessor) {
      setPeerNodeData(*(accessorImpl.peerNodeData_Accessor));
    } else {
      peerNodeData_Accessor.reset();
    }
    setMemberTopology(*(accessorImpl.memberTopology_Accessor));
    if (accessorImpl.searchPattern_Accessor) {
      setSearchPattern(*(accessorImpl.searchPattern_Accessor));
    } else {
      searchPattern_Accessor.reset();
    }
    if (accessorImpl.hasSearchVector()) {
      setSearchVector(accessorImpl.getSearchVector());
    } else {
      clearSearchVector();
    }
    if (accessorImpl.evenOddPhase_Accessor) {
      setEvenOddPhase(*(accessorImpl.evenOddPhase_Accessor));
    } else {
      evenOddPhase_Accessor.reset();
    }
    if (accessorImpl.earlyLatePhase_Accessor) {
      setEarlyLatePhase(*(accessorImpl.earlyLatePhase_Accessor));
    } else {
      earlyLatePhase_Accessor.reset();
    }
    if (accessorImpl.hasHopOffset()) {
      setHopOffset(accessorImpl.getHopOffset());
    } else {
      clearHopOffset();
    }
  }
}

void CommMADL_LinkStatusType::reset() noexcept {
  linkState_Accessor->reset();
  receivedDataRate_Accessor.reset();
  actualTxDataRate_Accessor.reset();
  clearHigherDataRateCapable();
  voiceReceiptIndicator_Accessor.reset();
  clearVoiceSource();
  peerNodeData_Accessor.reset();
  memberTopology_Accessor->reset();
  searchPattern_Accessor.reset();
  clearSearchVector();
  evenOddPhase_Accessor.reset();
  earlyLatePhase_Accessor.reset();
  clearHopOffset();
}

const uci::type::CommMADL_LinkStateEnum& CommMADL_LinkStatusType::getLinkState() const {
  return *linkState_Accessor;
}

uci::type::CommMADL_LinkStateEnum& CommMADL_LinkStatusType::getLinkState() {
  return *linkState_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setLinkState(const uci::type::CommMADL_LinkStateEnum& accessor) {
  if (&accessor != linkState_Accessor.get()) {
    linkState_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setLinkState(uci::type::CommMADL_LinkStateEnum::EnumerationItem value) {
  linkState_Accessor->setValue(value);
  return *this;
}


uci::type::CommMADL_DataRateTypeEnum& CommMADL_LinkStatusType::getReceivedDataRate_() const {
  if (receivedDataRate_Accessor) {
    return *receivedDataRate_Accessor;
  }
  throw uci::base::UCIException("Error in getReceivedDataRate(): An attempt was made to get an optional field that was not enabled, call hasReceivedDataRate() to determine if it is safe to call getReceivedDataRate()");
}

const uci::type::CommMADL_DataRateTypeEnum& CommMADL_LinkStatusType::getReceivedDataRate() const {
  return getReceivedDataRate_();
}

uci::type::CommMADL_DataRateTypeEnum& CommMADL_LinkStatusType::getReceivedDataRate() {
  return getReceivedDataRate_();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setReceivedDataRate(const uci::type::CommMADL_DataRateTypeEnum& accessor) {
  enableReceivedDataRate();
  if (&accessor != receivedDataRate_Accessor.get()) {
    receivedDataRate_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setReceivedDataRate(const uci::type::CommMADL_DataRateTypeEnum::EnumerationItem value) {
  enableReceivedDataRate().setValue(value);
  return *this;
}

bool CommMADL_LinkStatusType::hasReceivedDataRate() const noexcept {
  return static_cast<bool>(receivedDataRate_Accessor);
}

uci::type::CommMADL_DataRateTypeEnum& CommMADL_LinkStatusType::enableReceivedDataRate(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commMADL_DataRateTypeEnum : type};
  if ((!receivedDataRate_Accessor) || (receivedDataRate_Accessor->getAccessorType() != requestedType)) {
    receivedDataRate_Accessor = CommMADL_DataRateTypeEnum::create(requestedType);
    if (!receivedDataRate_Accessor) {
      throw uci::base::UCIException("Error in enableReceivedDataRate(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *receivedDataRate_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearReceivedDataRate() noexcept {
  receivedDataRate_Accessor.reset();
  return *this;
}

uci::type::CommMADL_DataRateTypeEnum& CommMADL_LinkStatusType::getActualTxDataRate_() const {
  if (actualTxDataRate_Accessor) {
    return *actualTxDataRate_Accessor;
  }
  throw uci::base::UCIException("Error in getActualTxDataRate(): An attempt was made to get an optional field that was not enabled, call hasActualTxDataRate() to determine if it is safe to call getActualTxDataRate()");
}

const uci::type::CommMADL_DataRateTypeEnum& CommMADL_LinkStatusType::getActualTxDataRate() const {
  return getActualTxDataRate_();
}

uci::type::CommMADL_DataRateTypeEnum& CommMADL_LinkStatusType::getActualTxDataRate() {
  return getActualTxDataRate_();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setActualTxDataRate(const uci::type::CommMADL_DataRateTypeEnum& accessor) {
  enableActualTxDataRate();
  if (&accessor != actualTxDataRate_Accessor.get()) {
    actualTxDataRate_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setActualTxDataRate(const uci::type::CommMADL_DataRateTypeEnum::EnumerationItem value) {
  enableActualTxDataRate().setValue(value);
  return *this;
}

bool CommMADL_LinkStatusType::hasActualTxDataRate() const noexcept {
  return static_cast<bool>(actualTxDataRate_Accessor);
}

uci::type::CommMADL_DataRateTypeEnum& CommMADL_LinkStatusType::enableActualTxDataRate(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commMADL_DataRateTypeEnum : type};
  if ((!actualTxDataRate_Accessor) || (actualTxDataRate_Accessor->getAccessorType() != requestedType)) {
    actualTxDataRate_Accessor = CommMADL_DataRateTypeEnum::create(requestedType);
    if (!actualTxDataRate_Accessor) {
      throw uci::base::UCIException("Error in enableActualTxDataRate(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *actualTxDataRate_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearActualTxDataRate() noexcept {
  actualTxDataRate_Accessor.reset();
  return *this;
}

xs::Boolean CommMADL_LinkStatusType::getHigherDataRateCapable() const {
  if (higherDataRateCapable_Accessor) {
    return *higherDataRateCapable_Accessor;
  }
  throw uci::base::UCIException("Error in getHigherDataRateCapable(): An attempt was made to get an optional field that was not enabled, call hasHigherDataRateCapable() to determine if it is safe to call getHigherDataRateCapable()");
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setHigherDataRateCapable(xs::Boolean value) {
  higherDataRateCapable_Accessor = value;
  return *this;
}

bool CommMADL_LinkStatusType::hasHigherDataRateCapable() const noexcept {
  return higherDataRateCapable_Accessor.has_value();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearHigherDataRateCapable() noexcept {
  higherDataRateCapable_Accessor.reset();
  return *this;
}

uci::type::CommMADL_VoiceRxIndicatorTypeEnum& CommMADL_LinkStatusType::getVoiceReceiptIndicator_() const {
  if (voiceReceiptIndicator_Accessor) {
    return *voiceReceiptIndicator_Accessor;
  }
  throw uci::base::UCIException("Error in getVoiceReceiptIndicator(): An attempt was made to get an optional field that was not enabled, call hasVoiceReceiptIndicator() to determine if it is safe to call getVoiceReceiptIndicator()");
}

const uci::type::CommMADL_VoiceRxIndicatorTypeEnum& CommMADL_LinkStatusType::getVoiceReceiptIndicator() const {
  return getVoiceReceiptIndicator_();
}

uci::type::CommMADL_VoiceRxIndicatorTypeEnum& CommMADL_LinkStatusType::getVoiceReceiptIndicator() {
  return getVoiceReceiptIndicator_();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setVoiceReceiptIndicator(const uci::type::CommMADL_VoiceRxIndicatorTypeEnum& accessor) {
  enableVoiceReceiptIndicator();
  if (&accessor != voiceReceiptIndicator_Accessor.get()) {
    voiceReceiptIndicator_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setVoiceReceiptIndicator(const uci::type::CommMADL_VoiceRxIndicatorTypeEnum::EnumerationItem value) {
  enableVoiceReceiptIndicator().setValue(value);
  return *this;
}

bool CommMADL_LinkStatusType::hasVoiceReceiptIndicator() const noexcept {
  return static_cast<bool>(voiceReceiptIndicator_Accessor);
}

uci::type::CommMADL_VoiceRxIndicatorTypeEnum& CommMADL_LinkStatusType::enableVoiceReceiptIndicator(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commMADL_VoiceRxIndicatorTypeEnum : type};
  if ((!voiceReceiptIndicator_Accessor) || (voiceReceiptIndicator_Accessor->getAccessorType() != requestedType)) {
    voiceReceiptIndicator_Accessor = CommMADL_VoiceRxIndicatorTypeEnum::create(requestedType);
    if (!voiceReceiptIndicator_Accessor) {
      throw uci::base::UCIException("Error in enableVoiceReceiptIndicator(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *voiceReceiptIndicator_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearVoiceReceiptIndicator() noexcept {
  voiceReceiptIndicator_Accessor.reset();
  return *this;
}

xs::UnsignedShort CommMADL_LinkStatusType::getVoiceSource() const {
  if (voiceSource_Accessor) {
    return *voiceSource_Accessor;
  }
  throw uci::base::UCIException("Error in getVoiceSource(): An attempt was made to get an optional field that was not enabled, call hasVoiceSource() to determine if it is safe to call getVoiceSource()");
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setVoiceSource(xs::UnsignedShort value) {
  voiceSource_Accessor = value;
  return *this;
}

bool CommMADL_LinkStatusType::hasVoiceSource() const noexcept {
  return voiceSource_Accessor.has_value();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearVoiceSource() noexcept {
  voiceSource_Accessor.reset();
  return *this;
}

uci::type::CommMADL_PeerNodeDataType& CommMADL_LinkStatusType::getPeerNodeData_() const {
  if (peerNodeData_Accessor) {
    return *peerNodeData_Accessor;
  }
  throw uci::base::UCIException("Error in getPeerNodeData(): An attempt was made to get an optional field that was not enabled, call hasPeerNodeData() to determine if it is safe to call getPeerNodeData()");
}

const uci::type::CommMADL_PeerNodeDataType& CommMADL_LinkStatusType::getPeerNodeData() const {
  return getPeerNodeData_();
}

uci::type::CommMADL_PeerNodeDataType& CommMADL_LinkStatusType::getPeerNodeData() {
  return getPeerNodeData_();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setPeerNodeData(const uci::type::CommMADL_PeerNodeDataType& accessor) {
  enablePeerNodeData();
  if (&accessor != peerNodeData_Accessor.get()) {
    peerNodeData_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CommMADL_LinkStatusType::hasPeerNodeData() const noexcept {
  return static_cast<bool>(peerNodeData_Accessor);
}

uci::type::CommMADL_PeerNodeDataType& CommMADL_LinkStatusType::enablePeerNodeData(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commMADL_PeerNodeDataType : type};
  if ((!peerNodeData_Accessor) || (peerNodeData_Accessor->getAccessorType() != requestedType)) {
    peerNodeData_Accessor = CommMADL_PeerNodeDataType::create(requestedType);
    if (!peerNodeData_Accessor) {
      throw uci::base::UCIException("Error in enablePeerNodeData(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *peerNodeData_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearPeerNodeData() noexcept {
  peerNodeData_Accessor.reset();
  return *this;
}

const uci::type::CommMADL_LinkStatusType::MemberTopology& CommMADL_LinkStatusType::getMemberTopology() const {
  return *memberTopology_Accessor;
}

uci::type::CommMADL_LinkStatusType::MemberTopology& CommMADL_LinkStatusType::getMemberTopology() {
  return *memberTopology_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setMemberTopology(const uci::type::CommMADL_LinkStatusType::MemberTopology& accessor) {
  if (&accessor != memberTopology_Accessor.get()) {
    memberTopology_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommMADL_SearchTypeEnum& CommMADL_LinkStatusType::getSearchPattern_() const {
  if (searchPattern_Accessor) {
    return *searchPattern_Accessor;
  }
  throw uci::base::UCIException("Error in getSearchPattern(): An attempt was made to get an optional field that was not enabled, call hasSearchPattern() to determine if it is safe to call getSearchPattern()");
}

const uci::type::CommMADL_SearchTypeEnum& CommMADL_LinkStatusType::getSearchPattern() const {
  return getSearchPattern_();
}

uci::type::CommMADL_SearchTypeEnum& CommMADL_LinkStatusType::getSearchPattern() {
  return getSearchPattern_();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setSearchPattern(const uci::type::CommMADL_SearchTypeEnum& accessor) {
  enableSearchPattern();
  if (&accessor != searchPattern_Accessor.get()) {
    searchPattern_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setSearchPattern(const uci::type::CommMADL_SearchTypeEnum::EnumerationItem value) {
  enableSearchPattern().setValue(value);
  return *this;
}

bool CommMADL_LinkStatusType::hasSearchPattern() const noexcept {
  return static_cast<bool>(searchPattern_Accessor);
}

uci::type::CommMADL_SearchTypeEnum& CommMADL_LinkStatusType::enableSearchPattern(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commMADL_SearchTypeEnum : type};
  if ((!searchPattern_Accessor) || (searchPattern_Accessor->getAccessorType() != requestedType)) {
    searchPattern_Accessor = CommMADL_SearchTypeEnum::create(requestedType);
    if (!searchPattern_Accessor) {
      throw uci::base::UCIException("Error in enableSearchPattern(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *searchPattern_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearSearchPattern() noexcept {
  searchPattern_Accessor.reset();
  return *this;
}

xs::Boolean CommMADL_LinkStatusType::getSearchVector() const {
  if (searchVector_Accessor) {
    return *searchVector_Accessor;
  }
  throw uci::base::UCIException("Error in getSearchVector(): An attempt was made to get an optional field that was not enabled, call hasSearchVector() to determine if it is safe to call getSearchVector()");
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setSearchVector(xs::Boolean value) {
  searchVector_Accessor = value;
  return *this;
}

bool CommMADL_LinkStatusType::hasSearchVector() const noexcept {
  return searchVector_Accessor.has_value();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearSearchVector() noexcept {
  searchVector_Accessor.reset();
  return *this;
}

uci::type::CommMADL_TimeSlotOE_PhaseTypeEnum& CommMADL_LinkStatusType::getEvenOddPhase_() const {
  if (evenOddPhase_Accessor) {
    return *evenOddPhase_Accessor;
  }
  throw uci::base::UCIException("Error in getEvenOddPhase(): An attempt was made to get an optional field that was not enabled, call hasEvenOddPhase() to determine if it is safe to call getEvenOddPhase()");
}

const uci::type::CommMADL_TimeSlotOE_PhaseTypeEnum& CommMADL_LinkStatusType::getEvenOddPhase() const {
  return getEvenOddPhase_();
}

uci::type::CommMADL_TimeSlotOE_PhaseTypeEnum& CommMADL_LinkStatusType::getEvenOddPhase() {
  return getEvenOddPhase_();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setEvenOddPhase(const uci::type::CommMADL_TimeSlotOE_PhaseTypeEnum& accessor) {
  enableEvenOddPhase();
  if (&accessor != evenOddPhase_Accessor.get()) {
    evenOddPhase_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setEvenOddPhase(const uci::type::CommMADL_TimeSlotOE_PhaseTypeEnum::EnumerationItem value) {
  enableEvenOddPhase().setValue(value);
  return *this;
}

bool CommMADL_LinkStatusType::hasEvenOddPhase() const noexcept {
  return static_cast<bool>(evenOddPhase_Accessor);
}

uci::type::CommMADL_TimeSlotOE_PhaseTypeEnum& CommMADL_LinkStatusType::enableEvenOddPhase(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commMADL_TimeSlotOE_PhaseTypeEnum : type};
  if ((!evenOddPhase_Accessor) || (evenOddPhase_Accessor->getAccessorType() != requestedType)) {
    evenOddPhase_Accessor = CommMADL_TimeSlotOE_PhaseTypeEnum::create(requestedType);
    if (!evenOddPhase_Accessor) {
      throw uci::base::UCIException("Error in enableEvenOddPhase(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *evenOddPhase_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearEvenOddPhase() noexcept {
  evenOddPhase_Accessor.reset();
  return *this;
}

uci::type::CommMADL_TimeSlotTxPhaseTypeEnum& CommMADL_LinkStatusType::getEarlyLatePhase_() const {
  if (earlyLatePhase_Accessor) {
    return *earlyLatePhase_Accessor;
  }
  throw uci::base::UCIException("Error in getEarlyLatePhase(): An attempt was made to get an optional field that was not enabled, call hasEarlyLatePhase() to determine if it is safe to call getEarlyLatePhase()");
}

const uci::type::CommMADL_TimeSlotTxPhaseTypeEnum& CommMADL_LinkStatusType::getEarlyLatePhase() const {
  return getEarlyLatePhase_();
}

uci::type::CommMADL_TimeSlotTxPhaseTypeEnum& CommMADL_LinkStatusType::getEarlyLatePhase() {
  return getEarlyLatePhase_();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setEarlyLatePhase(const uci::type::CommMADL_TimeSlotTxPhaseTypeEnum& accessor) {
  enableEarlyLatePhase();
  if (&accessor != earlyLatePhase_Accessor.get()) {
    earlyLatePhase_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setEarlyLatePhase(const uci::type::CommMADL_TimeSlotTxPhaseTypeEnum::EnumerationItem value) {
  enableEarlyLatePhase().setValue(value);
  return *this;
}

bool CommMADL_LinkStatusType::hasEarlyLatePhase() const noexcept {
  return static_cast<bool>(earlyLatePhase_Accessor);
}

uci::type::CommMADL_TimeSlotTxPhaseTypeEnum& CommMADL_LinkStatusType::enableEarlyLatePhase(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commMADL_TimeSlotTxPhaseTypeEnum : type};
  if ((!earlyLatePhase_Accessor) || (earlyLatePhase_Accessor->getAccessorType() != requestedType)) {
    earlyLatePhase_Accessor = CommMADL_TimeSlotTxPhaseTypeEnum::create(requestedType);
    if (!earlyLatePhase_Accessor) {
      throw uci::base::UCIException("Error in enableEarlyLatePhase(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *earlyLatePhase_Accessor;
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearEarlyLatePhase() noexcept {
  earlyLatePhase_Accessor.reset();
  return *this;
}

xs::UnsignedShort CommMADL_LinkStatusType::getHopOffset() const {
  if (hopOffset_Accessor) {
    return *hopOffset_Accessor;
  }
  throw uci::base::UCIException("Error in getHopOffset(): An attempt was made to get an optional field that was not enabled, call hasHopOffset() to determine if it is safe to call getHopOffset()");
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::setHopOffset(xs::UnsignedShort value) {
  hopOffset_Accessor = value;
  return *this;
}

bool CommMADL_LinkStatusType::hasHopOffset() const noexcept {
  return hopOffset_Accessor.has_value();
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::clearHopOffset() noexcept {
  hopOffset_Accessor.reset();
  return *this;
}

std::unique_ptr<CommMADL_LinkStatusType> CommMADL_LinkStatusType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::commMADL_LinkStatusType : type};
  return (requestedType == uci::type::accessorType::commMADL_LinkStatusType) ? boost::make_unique<CommMADL_LinkStatusType>() : nullptr;
}

/**  */
namespace CommMADL_LinkStatusType_Names {

constexpr const char* Extern_Type_Name{"CommMADL_LinkStatusType"};
constexpr const char* LinkState_Name{"LinkState"};
constexpr const char* ReceivedDataRate_Name{"ReceivedDataRate"};
constexpr const char* ActualTxDataRate_Name{"ActualTxDataRate"};
constexpr const char* HigherDataRateCapable_Name{"HigherDataRateCapable"};
constexpr const char* VoiceReceiptIndicator_Name{"VoiceReceiptIndicator"};
constexpr const char* VoiceSource_Name{"VoiceSource"};
constexpr const char* PeerNodeData_Name{"PeerNodeData"};
constexpr const char* MemberTopology_Name{"MemberTopology"};
constexpr const char* SearchPattern_Name{"SearchPattern"};
constexpr const char* SearchVector_Name{"SearchVector"};
constexpr const char* EvenOddPhase_Name{"EvenOddPhase"};
constexpr const char* EarlyLatePhase_Name{"EarlyLatePhase"};
constexpr const char* HopOffset_Name{"HopOffset"};

} // namespace CommMADL_LinkStatusType_Names

void CommMADL_LinkStatusType::deserialize(const boost::property_tree::ptree& propTree, uci::type::CommMADL_LinkStatusType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = CommMADL_LinkStatusType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::LinkState_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.getLinkState().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::ReceivedDataRate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableReceivedDataRate().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::ActualTxDataRate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableActualTxDataRate().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::HigherDataRateCapable_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setHigherDataRateCapable(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::VoiceReceiptIndicator_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableVoiceReceiptIndicator().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::VoiceSource_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setVoiceSource(asb_uci::util::SerializationHelpers::deserializeUnsignedShort(*value));
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::PeerNodeData_Name) {
      CommMADL_PeerNodeDataType::deserialize(valueType.second, accessor.enablePeerNodeData(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::MemberTopology_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::CommMADL_LinkStatusType::MemberTopology& boundedList = accessor.getMemberTopology();
        const uci::type::CommMADL_LinkStatusType::MemberTopology::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::CommMADL_TopologyEntryType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::SearchPattern_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableSearchPattern().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::SearchVector_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setSearchVector(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::EvenOddPhase_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableEvenOddPhase().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::EarlyLatePhase_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableEarlyLatePhase().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + CommMADL_LinkStatusType_Names::HopOffset_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setHopOffset(asb_uci::util::SerializationHelpers::deserializeUnsignedShort(*value));
      }
    }
  }
}

std::string CommMADL_LinkStatusType::serialize(const uci::type::CommMADL_LinkStatusType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? CommMADL_LinkStatusType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, CommMADL_LinkStatusType_Names::Extern_Type_Name);
  }
  CommMADL_LinkStateEnum::serialize(accessor.getLinkState(), node, CommMADL_LinkStatusType_Names::LinkState_Name, false);
  if (accessor.hasReceivedDataRate()) {
    CommMADL_DataRateTypeEnum::serialize(accessor.getReceivedDataRate(), node, CommMADL_LinkStatusType_Names::ReceivedDataRate_Name, false);
  }
  if (accessor.hasActualTxDataRate()) {
    CommMADL_DataRateTypeEnum::serialize(accessor.getActualTxDataRate(), node, CommMADL_LinkStatusType_Names::ActualTxDataRate_Name, false);
  }
  if (accessor.hasHigherDataRateCapable()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getHigherDataRateCapable(), node, CommMADL_LinkStatusType_Names::HigherDataRateCapable_Name);
  }
  if (accessor.hasVoiceReceiptIndicator()) {
    CommMADL_VoiceRxIndicatorTypeEnum::serialize(accessor.getVoiceReceiptIndicator(), node, CommMADL_LinkStatusType_Names::VoiceReceiptIndicator_Name, false);
  }
  if (accessor.hasVoiceSource()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedShort(accessor.getVoiceSource(), node, CommMADL_LinkStatusType_Names::VoiceSource_Name);
  }
  if (accessor.hasPeerNodeData()) {
    CommMADL_PeerNodeDataType::serialize(accessor.getPeerNodeData(), node, CommMADL_LinkStatusType_Names::PeerNodeData_Name);
  }
  {
    const uci::type::CommMADL_LinkStatusType::MemberTopology& boundedList = accessor.getMemberTopology();
    for (uci::type::CommMADL_LinkStatusType::MemberTopology::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::CommMADL_TopologyEntryType::serialize(boundedList.at(i), node, CommMADL_LinkStatusType_Names::MemberTopology_Name);
    }
  }
  if (accessor.hasSearchPattern()) {
    CommMADL_SearchTypeEnum::serialize(accessor.getSearchPattern(), node, CommMADL_LinkStatusType_Names::SearchPattern_Name, false);
  }
  if (accessor.hasSearchVector()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getSearchVector(), node, CommMADL_LinkStatusType_Names::SearchVector_Name);
  }
  if (accessor.hasEvenOddPhase()) {
    CommMADL_TimeSlotOE_PhaseTypeEnum::serialize(accessor.getEvenOddPhase(), node, CommMADL_LinkStatusType_Names::EvenOddPhase_Name, false);
  }
  if (accessor.hasEarlyLatePhase()) {
    CommMADL_TimeSlotTxPhaseTypeEnum::serialize(accessor.getEarlyLatePhase(), node, CommMADL_LinkStatusType_Names::EarlyLatePhase_Name, false);
  }
  if (accessor.hasHopOffset()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedShort(accessor.getHopOffset(), node, CommMADL_LinkStatusType_Names::HopOffset_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::CommMADL_LinkStatusType>().release());
}

uci::type::CommMADL_LinkStatusType& CommMADL_LinkStatusType::create(const uci::type::CommMADL_LinkStatusType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::CommMADL_LinkStatusType> newAccessor{boost::make_unique<asb_uci::type::CommMADL_LinkStatusType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void CommMADL_LinkStatusType::destroy(uci::type::CommMADL_LinkStatusType& accessor) {
  delete dynamic_cast<asb_uci::type::CommMADL_LinkStatusType*>(&accessor);
}

} // namespace type

} // namespace uci

