/** @file SecurityInformationType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:11 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/SecurityInformationType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/AtomicEnergyMarkingsChoiceType.h"
#include "asb_uci/type/ClassificationEnum.h"
#include "asb_uci/type/DeclassExceptionEnum.h"
#include "asb_uci/type/DisseminationControlsEnum.h"
#include "asb_uci/type/FGI_SourceOpenChoiceType.h"
#include "asb_uci/type/NonIC_MarkingsChoiceType.h"
#include "asb_uci/type/NonUS_ControlsEnum.h"
#include "asb_uci/type/OwnerProducerChoiceType.h"
#include "asb_uci/type/ReleasableToChoiceType.h"
#include "asb_uci/type/SAR_IdentifierType.h"
#include "asb_uci/type/SCI_ControlsChoiceType.h"
#include "asb_uci/type/WhitespaceVisibleString1024Type.h"
#include "asb_uci/type/WhitespaceVisibleString4096Type.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/AtomicEnergyMarkingsChoiceType.h"
#include "uci/type/ClassificationEnum.h"
#include "uci/type/DeclassExceptionEnum.h"
#include "uci/type/DisseminationControlsEnum.h"
#include "uci/type/FGI_SourceOpenChoiceType.h"
#include "uci/type/NonIC_MarkingsChoiceType.h"
#include "uci/type/NonUS_ControlsEnum.h"
#include "uci/type/OwnerProducerChoiceType.h"
#include "uci/type/ReleasableToChoiceType.h"
#include "uci/type/SAR_IdentifierType.h"
#include "uci/type/SCI_ControlsChoiceType.h"
#include "uci/type/SecurityInformationType.h"
#include "uci/type/WhitespaceVisibleString1024Type.h"
#include "uci/type/WhitespaceVisibleString4096Type.h"
#include "xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

SecurityInformationType::SecurityInformationType()
  : classification_Accessor{boost::make_unique<ClassificationEnum>()},
    ownerProducer_Accessor{boost::make_unique<OwnerProducer>(1, 358)},
    sCI_Controls_Accessor{boost::make_unique<SCI_Controls>(0, SIZE_MAX)},
    sAR_Identifier_Accessor{boost::make_unique<SAR_Identifier>(0, SIZE_MAX)},
    atomicEnergyMarkings_Accessor{boost::make_unique<AtomicEnergyMarkings>(0, 14)},
    disseminationControls_Accessor{boost::make_unique<DisseminationControls>(0, 13)},
    displayOnlyTo_Accessor{boost::make_unique<DisplayOnlyTo>(0, 357)},
    fGI_SourceOpen_Accessor{boost::make_unique<FGI_SourceOpen>(0, 357)},
    releasableTo_Accessor{boost::make_unique<ReleasableTo>(0, 357)},
    nonIC_Markings_Accessor{boost::make_unique<NonIC_Markings>(0, SIZE_MAX)},
    nonUS_Controls_Accessor{boost::make_unique<NonUS_Controls>(0, 3)},
    declassException_Accessor{boost::make_unique<DeclassException>(0, 17)} {
}

SecurityInformationType::~SecurityInformationType() = default;

void SecurityInformationType::copy(const uci::type::SecurityInformationType& accessor) {
  copyImpl(accessor, false);
}

void SecurityInformationType::copyImpl(const uci::type::SecurityInformationType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const SecurityInformationType&>(accessor);
    setClassification(*(accessorImpl.classification_Accessor));
    setOwnerProducer(*(accessorImpl.ownerProducer_Accessor));
    if (accessorImpl.hasJoint()) {
      setJoint(accessorImpl.getJoint());
    } else {
      clearJoint();
    }
    setSCI_Controls(*(accessorImpl.sCI_Controls_Accessor));
    setSAR_Identifier(*(accessorImpl.sAR_Identifier_Accessor));
    setAtomicEnergyMarkings(*(accessorImpl.atomicEnergyMarkings_Accessor));
    setDisseminationControls(*(accessorImpl.disseminationControls_Accessor));
    setDisplayOnlyTo(*(accessorImpl.displayOnlyTo_Accessor));
    setFGI_SourceOpen(*(accessorImpl.fGI_SourceOpen_Accessor));
    setReleasableTo(*(accessorImpl.releasableTo_Accessor));
    setNonIC_Markings(*(accessorImpl.nonIC_Markings_Accessor));
    if (accessorImpl.classifiedBy_Accessor) {
      setClassifiedBy(*(accessorImpl.classifiedBy_Accessor));
    } else {
      classifiedBy_Accessor.reset();
    }
    if (accessorImpl.compilationReason_Accessor) {
      setCompilationReason(*(accessorImpl.compilationReason_Accessor));
    } else {
      compilationReason_Accessor.reset();
    }
    if (accessorImpl.derivativelyClassifiedBy_Accessor) {
      setDerivativelyClassifiedBy(*(accessorImpl.derivativelyClassifiedBy_Accessor));
    } else {
      derivativelyClassifiedBy_Accessor.reset();
    }
    if (accessorImpl.classificationReason_Accessor) {
      setClassificationReason(*(accessorImpl.classificationReason_Accessor));
    } else {
      classificationReason_Accessor.reset();
    }
    setNonUS_Controls(*(accessorImpl.nonUS_Controls_Accessor));
    if (accessorImpl.derivedFrom_Accessor) {
      setDerivedFrom(*(accessorImpl.derivedFrom_Accessor));
    } else {
      derivedFrom_Accessor.reset();
    }
    if (accessorImpl.hasDeclassDate()) {
      setDeclassDate(accessorImpl.getDeclassDate());
    } else {
      clearDeclassDate();
    }
    if (accessorImpl.declassEvent_Accessor) {
      setDeclassEvent(*(accessorImpl.declassEvent_Accessor));
    } else {
      declassEvent_Accessor.reset();
    }
    setDeclassException(*(accessorImpl.declassException_Accessor));
  }
}

void SecurityInformationType::reset() noexcept {
  classification_Accessor->reset();
  ownerProducer_Accessor->reset();
  clearJoint();
  sCI_Controls_Accessor->reset();
  sAR_Identifier_Accessor->reset();
  atomicEnergyMarkings_Accessor->reset();
  disseminationControls_Accessor->reset();
  displayOnlyTo_Accessor->reset();
  fGI_SourceOpen_Accessor->reset();
  releasableTo_Accessor->reset();
  nonIC_Markings_Accessor->reset();
  classifiedBy_Accessor.reset();
  compilationReason_Accessor.reset();
  derivativelyClassifiedBy_Accessor.reset();
  classificationReason_Accessor.reset();
  nonUS_Controls_Accessor->reset();
  derivedFrom_Accessor.reset();
  clearDeclassDate();
  declassEvent_Accessor.reset();
  declassException_Accessor->reset();
}

const uci::type::ClassificationEnum& SecurityInformationType::getClassification() const {
  return *classification_Accessor;
}

uci::type::ClassificationEnum& SecurityInformationType::getClassification() {
  return *classification_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setClassification(const uci::type::ClassificationEnum& accessor) {
  if (&accessor != classification_Accessor.get()) {
    classification_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SecurityInformationType& SecurityInformationType::setClassification(uci::type::ClassificationEnum::EnumerationItem value) {
  classification_Accessor->setValue(value);
  return *this;
}


const uci::type::SecurityInformationType::OwnerProducer& SecurityInformationType::getOwnerProducer() const {
  return *ownerProducer_Accessor;
}

uci::type::SecurityInformationType::OwnerProducer& SecurityInformationType::getOwnerProducer() {
  return *ownerProducer_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setOwnerProducer(const uci::type::SecurityInformationType::OwnerProducer& accessor) {
  if (&accessor != ownerProducer_Accessor.get()) {
    ownerProducer_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

xs::Boolean SecurityInformationType::getJoint() const {
  if (joint_Accessor) {
    return *joint_Accessor;
  }
  throw uci::base::UCIException("Error in getJoint(): An attempt was made to get an optional field that was not enabled, call hasJoint() to determine if it is safe to call getJoint()");
}

uci::type::SecurityInformationType& SecurityInformationType::setJoint(xs::Boolean value) {
  joint_Accessor = value;
  return *this;
}

bool SecurityInformationType::hasJoint() const noexcept {
  return joint_Accessor.has_value();
}

uci::type::SecurityInformationType& SecurityInformationType::clearJoint() noexcept {
  joint_Accessor.reset();
  return *this;
}

const uci::type::SecurityInformationType::SCI_Controls& SecurityInformationType::getSCI_Controls() const {
  return *sCI_Controls_Accessor;
}

uci::type::SecurityInformationType::SCI_Controls& SecurityInformationType::getSCI_Controls() {
  return *sCI_Controls_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setSCI_Controls(const uci::type::SecurityInformationType::SCI_Controls& accessor) {
  if (&accessor != sCI_Controls_Accessor.get()) {
    sCI_Controls_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SecurityInformationType::SAR_Identifier& SecurityInformationType::getSAR_Identifier() const {
  return *sAR_Identifier_Accessor;
}

uci::type::SecurityInformationType::SAR_Identifier& SecurityInformationType::getSAR_Identifier() {
  return *sAR_Identifier_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setSAR_Identifier(const uci::type::SecurityInformationType::SAR_Identifier& accessor) {
  if (&accessor != sAR_Identifier_Accessor.get()) {
    sAR_Identifier_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SecurityInformationType::AtomicEnergyMarkings& SecurityInformationType::getAtomicEnergyMarkings() const {
  return *atomicEnergyMarkings_Accessor;
}

uci::type::SecurityInformationType::AtomicEnergyMarkings& SecurityInformationType::getAtomicEnergyMarkings() {
  return *atomicEnergyMarkings_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setAtomicEnergyMarkings(const uci::type::SecurityInformationType::AtomicEnergyMarkings& accessor) {
  if (&accessor != atomicEnergyMarkings_Accessor.get()) {
    atomicEnergyMarkings_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SecurityInformationType::DisseminationControls& SecurityInformationType::getDisseminationControls() const {
  return *disseminationControls_Accessor;
}

uci::type::SecurityInformationType::DisseminationControls& SecurityInformationType::getDisseminationControls() {
  return *disseminationControls_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setDisseminationControls(const uci::type::SecurityInformationType::DisseminationControls& accessor) {
  if (&accessor != disseminationControls_Accessor.get()) {
    disseminationControls_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SecurityInformationType::DisplayOnlyTo& SecurityInformationType::getDisplayOnlyTo() const {
  return *displayOnlyTo_Accessor;
}

uci::type::SecurityInformationType::DisplayOnlyTo& SecurityInformationType::getDisplayOnlyTo() {
  return *displayOnlyTo_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setDisplayOnlyTo(const uci::type::SecurityInformationType::DisplayOnlyTo& accessor) {
  if (&accessor != displayOnlyTo_Accessor.get()) {
    displayOnlyTo_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SecurityInformationType::FGI_SourceOpen& SecurityInformationType::getFGI_SourceOpen() const {
  return *fGI_SourceOpen_Accessor;
}

uci::type::SecurityInformationType::FGI_SourceOpen& SecurityInformationType::getFGI_SourceOpen() {
  return *fGI_SourceOpen_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setFGI_SourceOpen(const uci::type::SecurityInformationType::FGI_SourceOpen& accessor) {
  if (&accessor != fGI_SourceOpen_Accessor.get()) {
    fGI_SourceOpen_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SecurityInformationType::ReleasableTo& SecurityInformationType::getReleasableTo() const {
  return *releasableTo_Accessor;
}

uci::type::SecurityInformationType::ReleasableTo& SecurityInformationType::getReleasableTo() {
  return *releasableTo_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setReleasableTo(const uci::type::SecurityInformationType::ReleasableTo& accessor) {
  if (&accessor != releasableTo_Accessor.get()) {
    releasableTo_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SecurityInformationType::NonIC_Markings& SecurityInformationType::getNonIC_Markings() const {
  return *nonIC_Markings_Accessor;
}

uci::type::SecurityInformationType::NonIC_Markings& SecurityInformationType::getNonIC_Markings() {
  return *nonIC_Markings_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setNonIC_Markings(const uci::type::SecurityInformationType::NonIC_Markings& accessor) {
  if (&accessor != nonIC_Markings_Accessor.get()) {
    nonIC_Markings_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getClassifiedBy_() const {
  if (classifiedBy_Accessor) {
    return *classifiedBy_Accessor;
  }
  throw uci::base::UCIException("Error in getClassifiedBy(): An attempt was made to get an optional field that was not enabled, call hasClassifiedBy() to determine if it is safe to call getClassifiedBy()");
}

const uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getClassifiedBy() const {
  return getClassifiedBy_();
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getClassifiedBy() {
  return getClassifiedBy_();
}

uci::type::SecurityInformationType& SecurityInformationType::setClassifiedBy(const uci::type::WhitespaceVisibleString1024Type& value) {
  return setClassifiedBy(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setClassifiedBy(const std::string& value) {
  return setClassifiedBy(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setClassifiedBy(const char* value) {
  enableClassifiedBy().setStringValue(value);
  return *this;
}

bool SecurityInformationType::hasClassifiedBy() const noexcept {
  return static_cast<bool>(classifiedBy_Accessor);
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::enableClassifiedBy(uci::base::accessorType::AccessorType type) {
  if (!classifiedBy_Accessor) {
    classifiedBy_Accessor = WhitespaceVisibleString1024Type::create(type);
  }
  return *classifiedBy_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::clearClassifiedBy() noexcept {
  classifiedBy_Accessor.reset();
  return *this;
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getCompilationReason_() const {
  if (compilationReason_Accessor) {
    return *compilationReason_Accessor;
  }
  throw uci::base::UCIException("Error in getCompilationReason(): An attempt was made to get an optional field that was not enabled, call hasCompilationReason() to determine if it is safe to call getCompilationReason()");
}

const uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getCompilationReason() const {
  return getCompilationReason_();
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getCompilationReason() {
  return getCompilationReason_();
}

uci::type::SecurityInformationType& SecurityInformationType::setCompilationReason(const uci::type::WhitespaceVisibleString1024Type& value) {
  return setCompilationReason(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setCompilationReason(const std::string& value) {
  return setCompilationReason(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setCompilationReason(const char* value) {
  enableCompilationReason().setStringValue(value);
  return *this;
}

bool SecurityInformationType::hasCompilationReason() const noexcept {
  return static_cast<bool>(compilationReason_Accessor);
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::enableCompilationReason(uci::base::accessorType::AccessorType type) {
  if (!compilationReason_Accessor) {
    compilationReason_Accessor = WhitespaceVisibleString1024Type::create(type);
  }
  return *compilationReason_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::clearCompilationReason() noexcept {
  compilationReason_Accessor.reset();
  return *this;
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDerivativelyClassifiedBy_() const {
  if (derivativelyClassifiedBy_Accessor) {
    return *derivativelyClassifiedBy_Accessor;
  }
  throw uci::base::UCIException("Error in getDerivativelyClassifiedBy(): An attempt was made to get an optional field that was not enabled, call hasDerivativelyClassifiedBy() to determine if it is safe to call getDerivativelyClassifiedBy()");
}

const uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDerivativelyClassifiedBy() const {
  return getDerivativelyClassifiedBy_();
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDerivativelyClassifiedBy() {
  return getDerivativelyClassifiedBy_();
}

uci::type::SecurityInformationType& SecurityInformationType::setDerivativelyClassifiedBy(const uci::type::WhitespaceVisibleString1024Type& value) {
  return setDerivativelyClassifiedBy(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setDerivativelyClassifiedBy(const std::string& value) {
  return setDerivativelyClassifiedBy(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setDerivativelyClassifiedBy(const char* value) {
  enableDerivativelyClassifiedBy().setStringValue(value);
  return *this;
}

bool SecurityInformationType::hasDerivativelyClassifiedBy() const noexcept {
  return static_cast<bool>(derivativelyClassifiedBy_Accessor);
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::enableDerivativelyClassifiedBy(uci::base::accessorType::AccessorType type) {
  if (!derivativelyClassifiedBy_Accessor) {
    derivativelyClassifiedBy_Accessor = WhitespaceVisibleString1024Type::create(type);
  }
  return *derivativelyClassifiedBy_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::clearDerivativelyClassifiedBy() noexcept {
  derivativelyClassifiedBy_Accessor.reset();
  return *this;
}

uci::type::WhitespaceVisibleString4096Type& SecurityInformationType::getClassificationReason_() const {
  if (classificationReason_Accessor) {
    return *classificationReason_Accessor;
  }
  throw uci::base::UCIException("Error in getClassificationReason(): An attempt was made to get an optional field that was not enabled, call hasClassificationReason() to determine if it is safe to call getClassificationReason()");
}

const uci::type::WhitespaceVisibleString4096Type& SecurityInformationType::getClassificationReason() const {
  return getClassificationReason_();
}

uci::type::WhitespaceVisibleString4096Type& SecurityInformationType::getClassificationReason() {
  return getClassificationReason_();
}

uci::type::SecurityInformationType& SecurityInformationType::setClassificationReason(const uci::type::WhitespaceVisibleString4096Type& value) {
  return setClassificationReason(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setClassificationReason(const std::string& value) {
  return setClassificationReason(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setClassificationReason(const char* value) {
  enableClassificationReason().setStringValue(value);
  return *this;
}

bool SecurityInformationType::hasClassificationReason() const noexcept {
  return static_cast<bool>(classificationReason_Accessor);
}

uci::type::WhitespaceVisibleString4096Type& SecurityInformationType::enableClassificationReason(uci::base::accessorType::AccessorType type) {
  if (!classificationReason_Accessor) {
    classificationReason_Accessor = WhitespaceVisibleString4096Type::create(type);
  }
  return *classificationReason_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::clearClassificationReason() noexcept {
  classificationReason_Accessor.reset();
  return *this;
}

const uci::type::SecurityInformationType::NonUS_Controls& SecurityInformationType::getNonUS_Controls() const {
  return *nonUS_Controls_Accessor;
}

uci::type::SecurityInformationType::NonUS_Controls& SecurityInformationType::getNonUS_Controls() {
  return *nonUS_Controls_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setNonUS_Controls(const uci::type::SecurityInformationType::NonUS_Controls& accessor) {
  if (&accessor != nonUS_Controls_Accessor.get()) {
    nonUS_Controls_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDerivedFrom_() const {
  if (derivedFrom_Accessor) {
    return *derivedFrom_Accessor;
  }
  throw uci::base::UCIException("Error in getDerivedFrom(): An attempt was made to get an optional field that was not enabled, call hasDerivedFrom() to determine if it is safe to call getDerivedFrom()");
}

const uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDerivedFrom() const {
  return getDerivedFrom_();
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDerivedFrom() {
  return getDerivedFrom_();
}

uci::type::SecurityInformationType& SecurityInformationType::setDerivedFrom(const uci::type::WhitespaceVisibleString1024Type& value) {
  return setDerivedFrom(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setDerivedFrom(const std::string& value) {
  return setDerivedFrom(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setDerivedFrom(const char* value) {
  enableDerivedFrom().setStringValue(value);
  return *this;
}

bool SecurityInformationType::hasDerivedFrom() const noexcept {
  return static_cast<bool>(derivedFrom_Accessor);
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::enableDerivedFrom(uci::base::accessorType::AccessorType type) {
  if (!derivedFrom_Accessor) {
    derivedFrom_Accessor = WhitespaceVisibleString1024Type::create(type);
  }
  return *derivedFrom_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::clearDerivedFrom() noexcept {
  derivedFrom_Accessor.reset();
  return *this;
}

xs::DateTime SecurityInformationType::getDeclassDate() const {
  if (declassDate_Accessor) {
    return *declassDate_Accessor;
  }
  throw uci::base::UCIException("Error in getDeclassDate(): An attempt was made to get an optional field that was not enabled, call hasDeclassDate() to determine if it is safe to call getDeclassDate()");
}

uci::type::SecurityInformationType& SecurityInformationType::setDeclassDate(xs::DateTime value) {
  declassDate_Accessor = value;
  return *this;
}

bool SecurityInformationType::hasDeclassDate() const noexcept {
  return declassDate_Accessor.has_value();
}

uci::type::SecurityInformationType& SecurityInformationType::clearDeclassDate() noexcept {
  declassDate_Accessor.reset();
  return *this;
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDeclassEvent_() const {
  if (declassEvent_Accessor) {
    return *declassEvent_Accessor;
  }
  throw uci::base::UCIException("Error in getDeclassEvent(): An attempt was made to get an optional field that was not enabled, call hasDeclassEvent() to determine if it is safe to call getDeclassEvent()");
}

const uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDeclassEvent() const {
  return getDeclassEvent_();
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::getDeclassEvent() {
  return getDeclassEvent_();
}

uci::type::SecurityInformationType& SecurityInformationType::setDeclassEvent(const uci::type::WhitespaceVisibleString1024Type& value) {
  return setDeclassEvent(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setDeclassEvent(const std::string& value) {
  return setDeclassEvent(value.c_str());
}

uci::type::SecurityInformationType& SecurityInformationType::setDeclassEvent(const char* value) {
  enableDeclassEvent().setStringValue(value);
  return *this;
}

bool SecurityInformationType::hasDeclassEvent() const noexcept {
  return static_cast<bool>(declassEvent_Accessor);
}

uci::type::WhitespaceVisibleString1024Type& SecurityInformationType::enableDeclassEvent(uci::base::accessorType::AccessorType type) {
  if (!declassEvent_Accessor) {
    declassEvent_Accessor = WhitespaceVisibleString1024Type::create(type);
  }
  return *declassEvent_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::clearDeclassEvent() noexcept {
  declassEvent_Accessor.reset();
  return *this;
}

const uci::type::SecurityInformationType::DeclassException& SecurityInformationType::getDeclassException() const {
  return *declassException_Accessor;
}

uci::type::SecurityInformationType::DeclassException& SecurityInformationType::getDeclassException() {
  return *declassException_Accessor;
}

uci::type::SecurityInformationType& SecurityInformationType::setDeclassException(const uci::type::SecurityInformationType::DeclassException& accessor) {
  if (&accessor != declassException_Accessor.get()) {
    declassException_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

std::unique_ptr<SecurityInformationType> SecurityInformationType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::securityInformationType : type};
  return (requestedType == uci::type::accessorType::securityInformationType) ? boost::make_unique<SecurityInformationType>() : nullptr;
}

/**  */
namespace SecurityInformationType_Names {

constexpr const char* Extern_Type_Name{"SecurityInformationType"};
constexpr const char* Classification_Name{"Classification"};
constexpr const char* OwnerProducer_Name{"OwnerProducer"};
constexpr const char* Joint_Name{"Joint"};
constexpr const char* SCI_Controls_Name{"SCI_Controls"};
constexpr const char* SAR_Identifier_Name{"SAR_Identifier"};
constexpr const char* AtomicEnergyMarkings_Name{"AtomicEnergyMarkings"};
constexpr const char* DisseminationControls_Name{"DisseminationControls"};
constexpr const char* DisplayOnlyTo_Name{"DisplayOnlyTo"};
constexpr const char* FGI_SourceOpen_Name{"FGI_SourceOpen"};
constexpr const char* ReleasableTo_Name{"ReleasableTo"};
constexpr const char* NonIC_Markings_Name{"NonIC_Markings"};
constexpr const char* ClassifiedBy_Name{"ClassifiedBy"};
constexpr const char* CompilationReason_Name{"CompilationReason"};
constexpr const char* DerivativelyClassifiedBy_Name{"DerivativelyClassifiedBy"};
constexpr const char* ClassificationReason_Name{"ClassificationReason"};
constexpr const char* NonUS_Controls_Name{"NonUS_Controls"};
constexpr const char* DerivedFrom_Name{"DerivedFrom"};
constexpr const char* DeclassDate_Name{"DeclassDate"};
constexpr const char* DeclassEvent_Name{"DeclassEvent"};
constexpr const char* DeclassException_Name{"DeclassException"};

} // namespace SecurityInformationType_Names

void SecurityInformationType::deserialize(const boost::property_tree::ptree& propTree, uci::type::SecurityInformationType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = SecurityInformationType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::Classification_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.getClassification().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::OwnerProducer_Name) {
      uci::type::SecurityInformationType::OwnerProducer& boundedList = accessor.getOwnerProducer();
      const uci::type::SecurityInformationType::OwnerProducer::size_type boundedListSize{boundedList.size()};
      boundedList.resize(boundedListSize + 1);
      asb_uci::type::OwnerProducerChoiceType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::Joint_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setJoint(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::SCI_Controls_Name) {
      uci::type::SecurityInformationType::SCI_Controls& boundedList = accessor.getSCI_Controls();
      const uci::type::SecurityInformationType::SCI_Controls::size_type boundedListSize{boundedList.size()};
      boundedList.resize(boundedListSize + 1);
      asb_uci::type::SCI_ControlsChoiceType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::SAR_Identifier_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SecurityInformationType::SAR_Identifier& boundedList = accessor.getSAR_Identifier();
        const uci::type::SecurityInformationType::SAR_Identifier::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::AtomicEnergyMarkings_Name) {
      uci::type::SecurityInformationType::AtomicEnergyMarkings& boundedList = accessor.getAtomicEnergyMarkings();
      const uci::type::SecurityInformationType::AtomicEnergyMarkings::size_type boundedListSize{boundedList.size()};
      boundedList.resize(boundedListSize + 1);
      asb_uci::type::AtomicEnergyMarkingsChoiceType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::DisseminationControls_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SecurityInformationType::DisseminationControls& boundedList = accessor.getDisseminationControls();
        const uci::type::SecurityInformationType::DisseminationControls::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::DisplayOnlyTo_Name) {
      uci::type::SecurityInformationType::DisplayOnlyTo& boundedList = accessor.getDisplayOnlyTo();
      const uci::type::SecurityInformationType::DisplayOnlyTo::size_type boundedListSize{boundedList.size()};
      boundedList.resize(boundedListSize + 1);
      asb_uci::type::ReleasableToChoiceType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::FGI_SourceOpen_Name) {
      uci::type::SecurityInformationType::FGI_SourceOpen& boundedList = accessor.getFGI_SourceOpen();
      const uci::type::SecurityInformationType::FGI_SourceOpen::size_type boundedListSize{boundedList.size()};
      boundedList.resize(boundedListSize + 1);
      asb_uci::type::FGI_SourceOpenChoiceType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::ReleasableTo_Name) {
      uci::type::SecurityInformationType::ReleasableTo& boundedList = accessor.getReleasableTo();
      const uci::type::SecurityInformationType::ReleasableTo::size_type boundedListSize{boundedList.size()};
      boundedList.resize(boundedListSize + 1);
      asb_uci::type::ReleasableToChoiceType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::NonIC_Markings_Name) {
      uci::type::SecurityInformationType::NonIC_Markings& boundedList = accessor.getNonIC_Markings();
      const uci::type::SecurityInformationType::NonIC_Markings::size_type boundedListSize{boundedList.size()};
      boundedList.resize(boundedListSize + 1);
      asb_uci::type::NonIC_MarkingsChoiceType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::ClassifiedBy_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setClassifiedBy(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::CompilationReason_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setCompilationReason(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::DerivativelyClassifiedBy_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setDerivativelyClassifiedBy(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::ClassificationReason_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setClassificationReason(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::NonUS_Controls_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SecurityInformationType::NonUS_Controls& boundedList = accessor.getNonUS_Controls();
        const uci::type::SecurityInformationType::NonUS_Controls::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::DerivedFrom_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setDerivedFrom(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::DeclassDate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setDeclassDate(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::DeclassEvent_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setDeclassEvent(*value);
      }
    } else if (valueType.first == nsPrefix + SecurityInformationType_Names::DeclassException_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SecurityInformationType::DeclassException& boundedList = accessor.getDeclassException();
        const uci::type::SecurityInformationType::DeclassException::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setValueFromName(*value);
      }
    }
  }
}

std::string SecurityInformationType::serialize(const uci::type::SecurityInformationType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? SecurityInformationType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, SecurityInformationType_Names::Extern_Type_Name);
  }
  ClassificationEnum::serialize(accessor.getClassification(), node, SecurityInformationType_Names::Classification_Name, false);
  {
    const uci::type::SecurityInformationType::OwnerProducer& boundedList = accessor.getOwnerProducer();
    for (uci::type::SecurityInformationType::OwnerProducer::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::OwnerProducerChoiceType::serialize(boundedList.at(i), node, SecurityInformationType_Names::OwnerProducer_Name);
    }
  }
  if (accessor.hasJoint()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getJoint(), node, SecurityInformationType_Names::Joint_Name);
  }
  {
    const uci::type::SecurityInformationType::SCI_Controls& boundedList = accessor.getSCI_Controls();
    for (uci::type::SecurityInformationType::SCI_Controls::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::SCI_ControlsChoiceType::serialize(boundedList.at(i), node, SecurityInformationType_Names::SCI_Controls_Name);
    }
  }
  {
    const uci::type::SecurityInformationType::SAR_Identifier& boundedList = accessor.getSAR_Identifier();
    for (uci::type::SecurityInformationType::SAR_Identifier::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::util::SerializationHelpers::serializeString(boundedList.at(i), node, SecurityInformationType_Names::SAR_Identifier_Name);
    }
  }
  {
    const uci::type::SecurityInformationType::AtomicEnergyMarkings& boundedList = accessor.getAtomicEnergyMarkings();
    for (uci::type::SecurityInformationType::AtomicEnergyMarkings::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::AtomicEnergyMarkingsChoiceType::serialize(boundedList.at(i), node, SecurityInformationType_Names::AtomicEnergyMarkings_Name);
    }
  }
  {
    const uci::type::SecurityInformationType::DisseminationControls& boundedList = accessor.getDisseminationControls();
    for (uci::type::SecurityInformationType::DisseminationControls::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      DisseminationControlsEnum::serialize(boundedList.at(i), node, SecurityInformationType_Names::DisseminationControls_Name, false);
    }
  }
  {
    const uci::type::SecurityInformationType::DisplayOnlyTo& boundedList = accessor.getDisplayOnlyTo();
    for (uci::type::SecurityInformationType::DisplayOnlyTo::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::ReleasableToChoiceType::serialize(boundedList.at(i), node, SecurityInformationType_Names::DisplayOnlyTo_Name);
    }
  }
  {
    const uci::type::SecurityInformationType::FGI_SourceOpen& boundedList = accessor.getFGI_SourceOpen();
    for (uci::type::SecurityInformationType::FGI_SourceOpen::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::FGI_SourceOpenChoiceType::serialize(boundedList.at(i), node, SecurityInformationType_Names::FGI_SourceOpen_Name);
    }
  }
  {
    const uci::type::SecurityInformationType::ReleasableTo& boundedList = accessor.getReleasableTo();
    for (uci::type::SecurityInformationType::ReleasableTo::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::ReleasableToChoiceType::serialize(boundedList.at(i), node, SecurityInformationType_Names::ReleasableTo_Name);
    }
  }
  {
    const uci::type::SecurityInformationType::NonIC_Markings& boundedList = accessor.getNonIC_Markings();
    for (uci::type::SecurityInformationType::NonIC_Markings::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::NonIC_MarkingsChoiceType::serialize(boundedList.at(i), node, SecurityInformationType_Names::NonIC_Markings_Name);
    }
  }
  if (accessor.hasClassifiedBy()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getClassifiedBy(), node, SecurityInformationType_Names::ClassifiedBy_Name);
  }
  if (accessor.hasCompilationReason()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getCompilationReason(), node, SecurityInformationType_Names::CompilationReason_Name);
  }
  if (accessor.hasDerivativelyClassifiedBy()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getDerivativelyClassifiedBy(), node, SecurityInformationType_Names::DerivativelyClassifiedBy_Name);
  }
  if (accessor.hasClassificationReason()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getClassificationReason(), node, SecurityInformationType_Names::ClassificationReason_Name);
  }
  {
    const uci::type::SecurityInformationType::NonUS_Controls& boundedList = accessor.getNonUS_Controls();
    for (uci::type::SecurityInformationType::NonUS_Controls::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      NonUS_ControlsEnum::serialize(boundedList.at(i), node, SecurityInformationType_Names::NonUS_Controls_Name, false);
    }
  }
  if (accessor.hasDerivedFrom()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getDerivedFrom(), node, SecurityInformationType_Names::DerivedFrom_Name);
  }
  if (accessor.hasDeclassDate()) {
    asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getDeclassDate(), node, SecurityInformationType_Names::DeclassDate_Name);
  }
  if (accessor.hasDeclassEvent()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getDeclassEvent(), node, SecurityInformationType_Names::DeclassEvent_Name);
  }
  {
    const uci::type::SecurityInformationType::DeclassException& boundedList = accessor.getDeclassException();
    for (uci::type::SecurityInformationType::DeclassException::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      DeclassExceptionEnum::serialize(boundedList.at(i), node, SecurityInformationType_Names::DeclassException_Name, false);
    }
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::SecurityInformationType& SecurityInformationType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::SecurityInformationType>().release());
}

uci::type::SecurityInformationType& SecurityInformationType::create(const uci::type::SecurityInformationType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::SecurityInformationType> newAccessor{boost::make_unique<asb_uci::type::SecurityInformationType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void SecurityInformationType::destroy(uci::type::SecurityInformationType& accessor) {
  delete dynamic_cast<asb_uci::type::SecurityInformationType*>(&accessor);
}

} // namespace type

} // namespace uci

