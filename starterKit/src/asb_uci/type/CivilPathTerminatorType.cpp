/** @file CivilPathTerminatorType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:12 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/CivilPathTerminatorType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/CF_CourseToFixType.h"
#include "asb_uci/type/EmptyType.h"
#include "asb_uci/type/RF_RadiusToFixType.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/CF_CourseToFixType.h"
#include "uci/type/CivilPathTerminatorType.h"
#include "uci/type/EmptyType.h"
#include "uci/type/RF_RadiusToFixType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

CivilPathTerminatorType::CivilPathTerminatorType() = default;

CivilPathTerminatorType::~CivilPathTerminatorType() = default;

void CivilPathTerminatorType::copy(const uci::type::CivilPathTerminatorType& accessor) {
  copyImpl(accessor, false);
}

void CivilPathTerminatorType::copyImpl(const uci::type::CivilPathTerminatorType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const CivilPathTerminatorType&>(accessor);
    if (accessorImpl.aF_ArcToFix_Accessor) {
      setAF_ArcToFix(*(accessorImpl.aF_ArcToFix_Accessor));
    } else {
      aF_ArcToFix_Accessor.reset();
    }
    if (accessorImpl.cA_CourseToAltitude_Accessor) {
      setCA_CourseToAltitude(*(accessorImpl.cA_CourseToAltitude_Accessor));
    } else {
      cA_CourseToAltitude_Accessor.reset();
    }
    if (accessorImpl.cD_CourseToDMEDistance_Accessor) {
      setCD_CourseToDMEDistance(*(accessorImpl.cD_CourseToDMEDistance_Accessor));
    } else {
      cD_CourseToDMEDistance_Accessor.reset();
    }
    if (accessorImpl.cF_CourseToFix_Accessor) {
      setCF_CourseToFix(*(accessorImpl.cF_CourseToFix_Accessor));
    } else {
      cF_CourseToFix_Accessor.reset();
    }
    if (accessorImpl.cI_CourseToIntercept_Accessor) {
      setCI_CourseToIntercept(*(accessorImpl.cI_CourseToIntercept_Accessor));
    } else {
      cI_CourseToIntercept_Accessor.reset();
    }
    if (accessorImpl.cR_CourseToRadial_Accessor) {
      setCR_CourseToRadial(*(accessorImpl.cR_CourseToRadial_Accessor));
    } else {
      cR_CourseToRadial_Accessor.reset();
    }
    if (accessorImpl.dF_DirectToFix_Accessor) {
      setDF_DirectToFix(*(accessorImpl.dF_DirectToFix_Accessor));
    } else {
      dF_DirectToFix_Accessor.reset();
    }
    if (accessorImpl.fA_TrackToAltitude_Accessor) {
      setFA_TrackToAltitude(*(accessorImpl.fA_TrackToAltitude_Accessor));
    } else {
      fA_TrackToAltitude_Accessor.reset();
    }
    if (accessorImpl.fC_TrackFromFixToDistanceAlongTrack_Accessor) {
      setFC_TrackFromFixToDistanceAlongTrack(*(accessorImpl.fC_TrackFromFixToDistanceAlongTrack_Accessor));
    } else {
      fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
    }
    if (accessorImpl.fD_TrackFromFixToDMEDistance_Accessor) {
      setFD_TrackFromFixToDMEDistance(*(accessorImpl.fD_TrackFromFixToDMEDistance_Accessor));
    } else {
      fD_TrackFromFixToDMEDistance_Accessor.reset();
    }
    if (accessorImpl.fM_FixToManualTermination_Accessor) {
      setFM_FixToManualTermination(*(accessorImpl.fM_FixToManualTermination_Accessor));
    } else {
      fM_FixToManualTermination_Accessor.reset();
    }
    if (accessorImpl.hA_HoldingWithAltitudeTermination_Accessor) {
      setHA_HoldingWithAltitudeTermination(*(accessorImpl.hA_HoldingWithAltitudeTermination_Accessor));
    } else {
      hA_HoldingWithAltitudeTermination_Accessor.reset();
    }
    if (accessorImpl.hF_HoldingWithFixTermination_Accessor) {
      setHF_HoldingWithFixTermination(*(accessorImpl.hF_HoldingWithFixTermination_Accessor));
    } else {
      hF_HoldingWithFixTermination_Accessor.reset();
    }
    if (accessorImpl.hM_HoldingWithManualTermination_Accessor) {
      setHM_HoldingWithManualTermination(*(accessorImpl.hM_HoldingWithManualTermination_Accessor));
    } else {
      hM_HoldingWithManualTermination_Accessor.reset();
    }
    if (accessorImpl.iF_InitialFix_Accessor) {
      setIF_InitialFix(*(accessorImpl.iF_InitialFix_Accessor));
    } else {
      iF_InitialFix_Accessor.reset();
    }
    if (accessorImpl.pI_ProcedureTurnToIntercept_Accessor) {
      setPI_ProcedureTurnToIntercept(*(accessorImpl.pI_ProcedureTurnToIntercept_Accessor));
    } else {
      pI_ProcedureTurnToIntercept_Accessor.reset();
    }
    if (accessorImpl.rF_RadiusToFix_Accessor) {
      setRF_RadiusToFix(*(accessorImpl.rF_RadiusToFix_Accessor));
    } else {
      rF_RadiusToFix_Accessor.reset();
    }
    if (accessorImpl.tF_TrackToFix_Accessor) {
      setTF_TrackToFix(*(accessorImpl.tF_TrackToFix_Accessor));
    } else {
      tF_TrackToFix_Accessor.reset();
    }
    if (accessorImpl.vA_HeadingToAltitude_Accessor) {
      setVA_HeadingToAltitude(*(accessorImpl.vA_HeadingToAltitude_Accessor));
    } else {
      vA_HeadingToAltitude_Accessor.reset();
    }
    if (accessorImpl.vD_HeadingToDMEDistanceTermination_Accessor) {
      setVD_HeadingToDMEDistanceTermination(*(accessorImpl.vD_HeadingToDMEDistanceTermination_Accessor));
    } else {
      vD_HeadingToDMEDistanceTermination_Accessor.reset();
    }
    if (accessorImpl.vI_HeadingToIntercept_Accessor) {
      setVI_HeadingToIntercept(*(accessorImpl.vI_HeadingToIntercept_Accessor));
    } else {
      vI_HeadingToIntercept_Accessor.reset();
    }
    if (accessorImpl.vM_HeadingToManual_Accessor) {
      setVM_HeadingToManual(*(accessorImpl.vM_HeadingToManual_Accessor));
    } else {
      vM_HeadingToManual_Accessor.reset();
    }
    if (accessorImpl.vR_HeadingToRadialTermination_Accessor) {
      setVR_HeadingToRadialTermination(*(accessorImpl.vR_HeadingToRadialTermination_Accessor));
    } else {
      vR_HeadingToRadialTermination_Accessor.reset();
    }
  }
}

void CivilPathTerminatorType::reset() noexcept {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
}

uci::type::CivilPathTerminatorType::CivilPathTerminatorTypeChoice CivilPathTerminatorType::getCivilPathTerminatorTypeChoiceOrdinal() const noexcept {
  if (aF_ArcToFix_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_AF_ARCTOFIX;
  }
  if (cA_CourseToAltitude_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_CA_COURSETOALTITUDE;
  }
  if (cD_CourseToDMEDistance_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_CD_COURSETODMEDISTANCE;
  }
  if (cF_CourseToFix_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_CF_COURSETOFIX;
  }
  if (cI_CourseToIntercept_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_CI_COURSETOINTERCEPT;
  }
  if (cR_CourseToRadial_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_CR_COURSETORADIAL;
  }
  if (dF_DirectToFix_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_DF_DIRECTTOFIX;
  }
  if (fA_TrackToAltitude_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_FA_TRACKTOALTITUDE;
  }
  if (fC_TrackFromFixToDistanceAlongTrack_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_FC_TRACKFROMFIXTODISTANCEALONGTRACK;
  }
  if (fD_TrackFromFixToDMEDistance_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_FD_TRACKFROMFIXTODMEDISTANCE;
  }
  if (fM_FixToManualTermination_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_FM_FIXTOMANUALTERMINATION;
  }
  if (hA_HoldingWithAltitudeTermination_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_HA_HOLDINGWITHALTITUDETERMINATION;
  }
  if (hF_HoldingWithFixTermination_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_HF_HOLDINGWITHFIXTERMINATION;
  }
  if (hM_HoldingWithManualTermination_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_HM_HOLDINGWITHMANUALTERMINATION;
  }
  if (iF_InitialFix_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_IF_INITIALFIX;
  }
  if (pI_ProcedureTurnToIntercept_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_PI_PROCEDURETURNTOINTERCEPT;
  }
  if (rF_RadiusToFix_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_RF_RADIUSTOFIX;
  }
  if (tF_TrackToFix_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_TF_TRACKTOFIX;
  }
  if (vA_HeadingToAltitude_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_VA_HEADINGTOALTITUDE;
  }
  if (vD_HeadingToDMEDistanceTermination_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_VD_HEADINGTODMEDISTANCETERMINATION;
  }
  if (vI_HeadingToIntercept_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_VI_HEADINGTOINTERCEPT;
  }
  if (vM_HeadingToManual_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_VM_HEADINGTOMANUAL;
  }
  if (vR_HeadingToRadialTermination_Accessor) {
    return CIVILPATHTERMINATORTYPE_CHOICE_VR_HEADINGTORADIALTERMINATION;
  }
  return CIVILPATHTERMINATORTYPE_CHOICE_NONE;
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCivilPathTerminatorTypeChoiceOrdinal(uci::type::CivilPathTerminatorType::CivilPathTerminatorTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case CIVILPATHTERMINATORTYPE_CHOICE_AF_ARCTOFIX:
      chooseAF_ArcToFix("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_CA_COURSETOALTITUDE:
      chooseCA_CourseToAltitude("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_CD_COURSETODMEDISTANCE:
      chooseCD_CourseToDMEDistance("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_CF_COURSETOFIX:
      chooseCF_CourseToFix("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_CI_COURSETOINTERCEPT:
      chooseCI_CourseToIntercept("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_CR_COURSETORADIAL:
      chooseCR_CourseToRadial("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_DF_DIRECTTOFIX:
      chooseDF_DirectToFix("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_FA_TRACKTOALTITUDE:
      chooseFA_TrackToAltitude("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_FC_TRACKFROMFIXTODISTANCEALONGTRACK:
      chooseFC_TrackFromFixToDistanceAlongTrack("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_FD_TRACKFROMFIXTODMEDISTANCE:
      chooseFD_TrackFromFixToDMEDistance("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_FM_FIXTOMANUALTERMINATION:
      chooseFM_FixToManualTermination("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_HA_HOLDINGWITHALTITUDETERMINATION:
      chooseHA_HoldingWithAltitudeTermination("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_HF_HOLDINGWITHFIXTERMINATION:
      chooseHF_HoldingWithFixTermination("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_HM_HOLDINGWITHMANUALTERMINATION:
      chooseHM_HoldingWithManualTermination("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_IF_INITIALFIX:
      chooseIF_InitialFix("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_PI_PROCEDURETURNTOINTERCEPT:
      choosePI_ProcedureTurnToIntercept("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_RF_RADIUSTOFIX:
      chooseRF_RadiusToFix("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_TF_TRACKTOFIX:
      chooseTF_TrackToFix("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_VA_HEADINGTOALTITUDE:
      chooseVA_HeadingToAltitude("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_VD_HEADINGTODMEDISTANCETERMINATION:
      chooseVD_HeadingToDMEDistanceTermination("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_VI_HEADINGTOINTERCEPT:
      chooseVI_HeadingToIntercept("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_VM_HEADINGTOMANUAL:
      chooseVM_HeadingToManual("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    case CIVILPATHTERMINATORTYPE_CHOICE_VR_HEADINGTORADIALTERMINATION:
      chooseVR_HeadingToRadialTermination("setCivilPathTerminatorTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setCivilPathTerminatorTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::EmptyType& CivilPathTerminatorType::getAF_ArcToFix_() const {
  if (aF_ArcToFix_Accessor) {
    return *aF_ArcToFix_Accessor;
  }
  throw uci::base::UCIException("Error in getAF_ArcToFix(): An attempt was made to get an optional field that was not enabled, call hasAF_ArcToFix() to determine if it is safe to call getAF_ArcToFix()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getAF_ArcToFix() const {
  return getAF_ArcToFix_();
}

uci::type::EmptyType& CivilPathTerminatorType::getAF_ArcToFix() {
  return getAF_ArcToFix_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setAF_ArcToFix(const uci::type::EmptyType& value) {
  return setAF_ArcToFix(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setAF_ArcToFix(const std::string& value) {
  return setAF_ArcToFix(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setAF_ArcToFix(const char * value) {
  chooseAF_ArcToFix().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isAF_ArcToFix() const noexcept {
  return static_cast<bool>(aF_ArcToFix_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseAF_ArcToFix(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!aF_ArcToFix_Accessor) {
    aF_ArcToFix_Accessor = EmptyType::create(type);
  }
  return *aF_ArcToFix_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseAF_ArcToFix(uci::base::accessorType::AccessorType type) {
  return chooseAF_ArcToFix("chooseAF_ArcToFix", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getCA_CourseToAltitude_() const {
  if (cA_CourseToAltitude_Accessor) {
    return *cA_CourseToAltitude_Accessor;
  }
  throw uci::base::UCIException("Error in getCA_CourseToAltitude(): An attempt was made to get an optional field that was not enabled, call hasCA_CourseToAltitude() to determine if it is safe to call getCA_CourseToAltitude()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getCA_CourseToAltitude() const {
  return getCA_CourseToAltitude_();
}

uci::type::EmptyType& CivilPathTerminatorType::getCA_CourseToAltitude() {
  return getCA_CourseToAltitude_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCA_CourseToAltitude(const uci::type::EmptyType& value) {
  return setCA_CourseToAltitude(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCA_CourseToAltitude(const std::string& value) {
  return setCA_CourseToAltitude(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCA_CourseToAltitude(const char * value) {
  chooseCA_CourseToAltitude().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isCA_CourseToAltitude() const noexcept {
  return static_cast<bool>(cA_CourseToAltitude_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseCA_CourseToAltitude(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!cA_CourseToAltitude_Accessor) {
    cA_CourseToAltitude_Accessor = EmptyType::create(type);
  }
  return *cA_CourseToAltitude_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseCA_CourseToAltitude(uci::base::accessorType::AccessorType type) {
  return chooseCA_CourseToAltitude("chooseCA_CourseToAltitude", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getCD_CourseToDMEDistance_() const {
  if (cD_CourseToDMEDistance_Accessor) {
    return *cD_CourseToDMEDistance_Accessor;
  }
  throw uci::base::UCIException("Error in getCD_CourseToDMEDistance(): An attempt was made to get an optional field that was not enabled, call hasCD_CourseToDMEDistance() to determine if it is safe to call getCD_CourseToDMEDistance()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getCD_CourseToDMEDistance() const {
  return getCD_CourseToDMEDistance_();
}

uci::type::EmptyType& CivilPathTerminatorType::getCD_CourseToDMEDistance() {
  return getCD_CourseToDMEDistance_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCD_CourseToDMEDistance(const uci::type::EmptyType& value) {
  return setCD_CourseToDMEDistance(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCD_CourseToDMEDistance(const std::string& value) {
  return setCD_CourseToDMEDistance(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCD_CourseToDMEDistance(const char * value) {
  chooseCD_CourseToDMEDistance().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isCD_CourseToDMEDistance() const noexcept {
  return static_cast<bool>(cD_CourseToDMEDistance_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseCD_CourseToDMEDistance(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!cD_CourseToDMEDistance_Accessor) {
    cD_CourseToDMEDistance_Accessor = EmptyType::create(type);
  }
  return *cD_CourseToDMEDistance_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseCD_CourseToDMEDistance(uci::base::accessorType::AccessorType type) {
  return chooseCD_CourseToDMEDistance("chooseCD_CourseToDMEDistance", type);
}

uci::type::CF_CourseToFixType& CivilPathTerminatorType::getCF_CourseToFix_() const {
  if (cF_CourseToFix_Accessor) {
    return *cF_CourseToFix_Accessor;
  }
  throw uci::base::UCIException("Error in getCF_CourseToFix(): Unable to get CF_CourseToFix, field not selected");
}

const uci::type::CF_CourseToFixType& CivilPathTerminatorType::getCF_CourseToFix() const {
  return getCF_CourseToFix_();
}

uci::type::CF_CourseToFixType& CivilPathTerminatorType::getCF_CourseToFix() {
  return getCF_CourseToFix_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCF_CourseToFix(const uci::type::CF_CourseToFixType& accessor) {
  chooseCF_CourseToFix();
  if (&accessor != cF_CourseToFix_Accessor.get()) {
    cF_CourseToFix_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CivilPathTerminatorType::isCF_CourseToFix() const noexcept {
  return static_cast<bool>(cF_CourseToFix_Accessor);
}

uci::type::CF_CourseToFixType& CivilPathTerminatorType::chooseCF_CourseToFix(const std::string& method, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::cF_CourseToFixType : type};
  if ((!cF_CourseToFix_Accessor) || (cF_CourseToFix_Accessor->getAccessorType() != requestedType)) {
    cF_CourseToFix_Accessor = CF_CourseToFixType::create(type);
    if (!cF_CourseToFix_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *cF_CourseToFix_Accessor;
}

uci::type::CF_CourseToFixType& CivilPathTerminatorType::chooseCF_CourseToFix(uci::base::accessorType::AccessorType type) {
  return chooseCF_CourseToFix("chooseCF_CourseToFix", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getCI_CourseToIntercept_() const {
  if (cI_CourseToIntercept_Accessor) {
    return *cI_CourseToIntercept_Accessor;
  }
  throw uci::base::UCIException("Error in getCI_CourseToIntercept(): An attempt was made to get an optional field that was not enabled, call hasCI_CourseToIntercept() to determine if it is safe to call getCI_CourseToIntercept()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getCI_CourseToIntercept() const {
  return getCI_CourseToIntercept_();
}

uci::type::EmptyType& CivilPathTerminatorType::getCI_CourseToIntercept() {
  return getCI_CourseToIntercept_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCI_CourseToIntercept(const uci::type::EmptyType& value) {
  return setCI_CourseToIntercept(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCI_CourseToIntercept(const std::string& value) {
  return setCI_CourseToIntercept(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCI_CourseToIntercept(const char * value) {
  chooseCI_CourseToIntercept().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isCI_CourseToIntercept() const noexcept {
  return static_cast<bool>(cI_CourseToIntercept_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseCI_CourseToIntercept(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!cI_CourseToIntercept_Accessor) {
    cI_CourseToIntercept_Accessor = EmptyType::create(type);
  }
  return *cI_CourseToIntercept_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseCI_CourseToIntercept(uci::base::accessorType::AccessorType type) {
  return chooseCI_CourseToIntercept("chooseCI_CourseToIntercept", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getCR_CourseToRadial_() const {
  if (cR_CourseToRadial_Accessor) {
    return *cR_CourseToRadial_Accessor;
  }
  throw uci::base::UCIException("Error in getCR_CourseToRadial(): An attempt was made to get an optional field that was not enabled, call hasCR_CourseToRadial() to determine if it is safe to call getCR_CourseToRadial()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getCR_CourseToRadial() const {
  return getCR_CourseToRadial_();
}

uci::type::EmptyType& CivilPathTerminatorType::getCR_CourseToRadial() {
  return getCR_CourseToRadial_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCR_CourseToRadial(const uci::type::EmptyType& value) {
  return setCR_CourseToRadial(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCR_CourseToRadial(const std::string& value) {
  return setCR_CourseToRadial(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setCR_CourseToRadial(const char * value) {
  chooseCR_CourseToRadial().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isCR_CourseToRadial() const noexcept {
  return static_cast<bool>(cR_CourseToRadial_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseCR_CourseToRadial(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!cR_CourseToRadial_Accessor) {
    cR_CourseToRadial_Accessor = EmptyType::create(type);
  }
  return *cR_CourseToRadial_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseCR_CourseToRadial(uci::base::accessorType::AccessorType type) {
  return chooseCR_CourseToRadial("chooseCR_CourseToRadial", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getDF_DirectToFix_() const {
  if (dF_DirectToFix_Accessor) {
    return *dF_DirectToFix_Accessor;
  }
  throw uci::base::UCIException("Error in getDF_DirectToFix(): An attempt was made to get an optional field that was not enabled, call hasDF_DirectToFix() to determine if it is safe to call getDF_DirectToFix()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getDF_DirectToFix() const {
  return getDF_DirectToFix_();
}

uci::type::EmptyType& CivilPathTerminatorType::getDF_DirectToFix() {
  return getDF_DirectToFix_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setDF_DirectToFix(const uci::type::EmptyType& value) {
  return setDF_DirectToFix(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setDF_DirectToFix(const std::string& value) {
  return setDF_DirectToFix(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setDF_DirectToFix(const char * value) {
  chooseDF_DirectToFix().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isDF_DirectToFix() const noexcept {
  return static_cast<bool>(dF_DirectToFix_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseDF_DirectToFix(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!dF_DirectToFix_Accessor) {
    dF_DirectToFix_Accessor = EmptyType::create(type);
  }
  return *dF_DirectToFix_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseDF_DirectToFix(uci::base::accessorType::AccessorType type) {
  return chooseDF_DirectToFix("chooseDF_DirectToFix", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getFA_TrackToAltitude_() const {
  if (fA_TrackToAltitude_Accessor) {
    return *fA_TrackToAltitude_Accessor;
  }
  throw uci::base::UCIException("Error in getFA_TrackToAltitude(): An attempt was made to get an optional field that was not enabled, call hasFA_TrackToAltitude() to determine if it is safe to call getFA_TrackToAltitude()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getFA_TrackToAltitude() const {
  return getFA_TrackToAltitude_();
}

uci::type::EmptyType& CivilPathTerminatorType::getFA_TrackToAltitude() {
  return getFA_TrackToAltitude_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFA_TrackToAltitude(const uci::type::EmptyType& value) {
  return setFA_TrackToAltitude(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFA_TrackToAltitude(const std::string& value) {
  return setFA_TrackToAltitude(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFA_TrackToAltitude(const char * value) {
  chooseFA_TrackToAltitude().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isFA_TrackToAltitude() const noexcept {
  return static_cast<bool>(fA_TrackToAltitude_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseFA_TrackToAltitude(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!fA_TrackToAltitude_Accessor) {
    fA_TrackToAltitude_Accessor = EmptyType::create(type);
  }
  return *fA_TrackToAltitude_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseFA_TrackToAltitude(uci::base::accessorType::AccessorType type) {
  return chooseFA_TrackToAltitude("chooseFA_TrackToAltitude", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getFC_TrackFromFixToDistanceAlongTrack_() const {
  if (fC_TrackFromFixToDistanceAlongTrack_Accessor) {
    return *fC_TrackFromFixToDistanceAlongTrack_Accessor;
  }
  throw uci::base::UCIException("Error in getFC_TrackFromFixToDistanceAlongTrack(): An attempt was made to get an optional field that was not enabled, call hasFC_TrackFromFixToDistanceAlongTrack() to determine if it is safe to call getFC_TrackFromFixToDistanceAlongTrack()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getFC_TrackFromFixToDistanceAlongTrack() const {
  return getFC_TrackFromFixToDistanceAlongTrack_();
}

uci::type::EmptyType& CivilPathTerminatorType::getFC_TrackFromFixToDistanceAlongTrack() {
  return getFC_TrackFromFixToDistanceAlongTrack_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFC_TrackFromFixToDistanceAlongTrack(const uci::type::EmptyType& value) {
  return setFC_TrackFromFixToDistanceAlongTrack(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFC_TrackFromFixToDistanceAlongTrack(const std::string& value) {
  return setFC_TrackFromFixToDistanceAlongTrack(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFC_TrackFromFixToDistanceAlongTrack(const char * value) {
  chooseFC_TrackFromFixToDistanceAlongTrack().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isFC_TrackFromFixToDistanceAlongTrack() const noexcept {
  return static_cast<bool>(fC_TrackFromFixToDistanceAlongTrack_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseFC_TrackFromFixToDistanceAlongTrack(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!fC_TrackFromFixToDistanceAlongTrack_Accessor) {
    fC_TrackFromFixToDistanceAlongTrack_Accessor = EmptyType::create(type);
  }
  return *fC_TrackFromFixToDistanceAlongTrack_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseFC_TrackFromFixToDistanceAlongTrack(uci::base::accessorType::AccessorType type) {
  return chooseFC_TrackFromFixToDistanceAlongTrack("chooseFC_TrackFromFixToDistanceAlongTrack", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getFD_TrackFromFixToDMEDistance_() const {
  if (fD_TrackFromFixToDMEDistance_Accessor) {
    return *fD_TrackFromFixToDMEDistance_Accessor;
  }
  throw uci::base::UCIException("Error in getFD_TrackFromFixToDMEDistance(): An attempt was made to get an optional field that was not enabled, call hasFD_TrackFromFixToDMEDistance() to determine if it is safe to call getFD_TrackFromFixToDMEDistance()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getFD_TrackFromFixToDMEDistance() const {
  return getFD_TrackFromFixToDMEDistance_();
}

uci::type::EmptyType& CivilPathTerminatorType::getFD_TrackFromFixToDMEDistance() {
  return getFD_TrackFromFixToDMEDistance_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFD_TrackFromFixToDMEDistance(const uci::type::EmptyType& value) {
  return setFD_TrackFromFixToDMEDistance(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFD_TrackFromFixToDMEDistance(const std::string& value) {
  return setFD_TrackFromFixToDMEDistance(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFD_TrackFromFixToDMEDistance(const char * value) {
  chooseFD_TrackFromFixToDMEDistance().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isFD_TrackFromFixToDMEDistance() const noexcept {
  return static_cast<bool>(fD_TrackFromFixToDMEDistance_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseFD_TrackFromFixToDMEDistance(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!fD_TrackFromFixToDMEDistance_Accessor) {
    fD_TrackFromFixToDMEDistance_Accessor = EmptyType::create(type);
  }
  return *fD_TrackFromFixToDMEDistance_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseFD_TrackFromFixToDMEDistance(uci::base::accessorType::AccessorType type) {
  return chooseFD_TrackFromFixToDMEDistance("chooseFD_TrackFromFixToDMEDistance", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getFM_FixToManualTermination_() const {
  if (fM_FixToManualTermination_Accessor) {
    return *fM_FixToManualTermination_Accessor;
  }
  throw uci::base::UCIException("Error in getFM_FixToManualTermination(): An attempt was made to get an optional field that was not enabled, call hasFM_FixToManualTermination() to determine if it is safe to call getFM_FixToManualTermination()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getFM_FixToManualTermination() const {
  return getFM_FixToManualTermination_();
}

uci::type::EmptyType& CivilPathTerminatorType::getFM_FixToManualTermination() {
  return getFM_FixToManualTermination_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFM_FixToManualTermination(const uci::type::EmptyType& value) {
  return setFM_FixToManualTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFM_FixToManualTermination(const std::string& value) {
  return setFM_FixToManualTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setFM_FixToManualTermination(const char * value) {
  chooseFM_FixToManualTermination().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isFM_FixToManualTermination() const noexcept {
  return static_cast<bool>(fM_FixToManualTermination_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseFM_FixToManualTermination(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!fM_FixToManualTermination_Accessor) {
    fM_FixToManualTermination_Accessor = EmptyType::create(type);
  }
  return *fM_FixToManualTermination_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseFM_FixToManualTermination(uci::base::accessorType::AccessorType type) {
  return chooseFM_FixToManualTermination("chooseFM_FixToManualTermination", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getHA_HoldingWithAltitudeTermination_() const {
  if (hA_HoldingWithAltitudeTermination_Accessor) {
    return *hA_HoldingWithAltitudeTermination_Accessor;
  }
  throw uci::base::UCIException("Error in getHA_HoldingWithAltitudeTermination(): An attempt was made to get an optional field that was not enabled, call hasHA_HoldingWithAltitudeTermination() to determine if it is safe to call getHA_HoldingWithAltitudeTermination()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getHA_HoldingWithAltitudeTermination() const {
  return getHA_HoldingWithAltitudeTermination_();
}

uci::type::EmptyType& CivilPathTerminatorType::getHA_HoldingWithAltitudeTermination() {
  return getHA_HoldingWithAltitudeTermination_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHA_HoldingWithAltitudeTermination(const uci::type::EmptyType& value) {
  return setHA_HoldingWithAltitudeTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHA_HoldingWithAltitudeTermination(const std::string& value) {
  return setHA_HoldingWithAltitudeTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHA_HoldingWithAltitudeTermination(const char * value) {
  chooseHA_HoldingWithAltitudeTermination().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isHA_HoldingWithAltitudeTermination() const noexcept {
  return static_cast<bool>(hA_HoldingWithAltitudeTermination_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseHA_HoldingWithAltitudeTermination(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!hA_HoldingWithAltitudeTermination_Accessor) {
    hA_HoldingWithAltitudeTermination_Accessor = EmptyType::create(type);
  }
  return *hA_HoldingWithAltitudeTermination_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseHA_HoldingWithAltitudeTermination(uci::base::accessorType::AccessorType type) {
  return chooseHA_HoldingWithAltitudeTermination("chooseHA_HoldingWithAltitudeTermination", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getHF_HoldingWithFixTermination_() const {
  if (hF_HoldingWithFixTermination_Accessor) {
    return *hF_HoldingWithFixTermination_Accessor;
  }
  throw uci::base::UCIException("Error in getHF_HoldingWithFixTermination(): An attempt was made to get an optional field that was not enabled, call hasHF_HoldingWithFixTermination() to determine if it is safe to call getHF_HoldingWithFixTermination()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getHF_HoldingWithFixTermination() const {
  return getHF_HoldingWithFixTermination_();
}

uci::type::EmptyType& CivilPathTerminatorType::getHF_HoldingWithFixTermination() {
  return getHF_HoldingWithFixTermination_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHF_HoldingWithFixTermination(const uci::type::EmptyType& value) {
  return setHF_HoldingWithFixTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHF_HoldingWithFixTermination(const std::string& value) {
  return setHF_HoldingWithFixTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHF_HoldingWithFixTermination(const char * value) {
  chooseHF_HoldingWithFixTermination().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isHF_HoldingWithFixTermination() const noexcept {
  return static_cast<bool>(hF_HoldingWithFixTermination_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseHF_HoldingWithFixTermination(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!hF_HoldingWithFixTermination_Accessor) {
    hF_HoldingWithFixTermination_Accessor = EmptyType::create(type);
  }
  return *hF_HoldingWithFixTermination_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseHF_HoldingWithFixTermination(uci::base::accessorType::AccessorType type) {
  return chooseHF_HoldingWithFixTermination("chooseHF_HoldingWithFixTermination", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getHM_HoldingWithManualTermination_() const {
  if (hM_HoldingWithManualTermination_Accessor) {
    return *hM_HoldingWithManualTermination_Accessor;
  }
  throw uci::base::UCIException("Error in getHM_HoldingWithManualTermination(): An attempt was made to get an optional field that was not enabled, call hasHM_HoldingWithManualTermination() to determine if it is safe to call getHM_HoldingWithManualTermination()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getHM_HoldingWithManualTermination() const {
  return getHM_HoldingWithManualTermination_();
}

uci::type::EmptyType& CivilPathTerminatorType::getHM_HoldingWithManualTermination() {
  return getHM_HoldingWithManualTermination_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHM_HoldingWithManualTermination(const uci::type::EmptyType& value) {
  return setHM_HoldingWithManualTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHM_HoldingWithManualTermination(const std::string& value) {
  return setHM_HoldingWithManualTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setHM_HoldingWithManualTermination(const char * value) {
  chooseHM_HoldingWithManualTermination().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isHM_HoldingWithManualTermination() const noexcept {
  return static_cast<bool>(hM_HoldingWithManualTermination_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseHM_HoldingWithManualTermination(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!hM_HoldingWithManualTermination_Accessor) {
    hM_HoldingWithManualTermination_Accessor = EmptyType::create(type);
  }
  return *hM_HoldingWithManualTermination_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseHM_HoldingWithManualTermination(uci::base::accessorType::AccessorType type) {
  return chooseHM_HoldingWithManualTermination("chooseHM_HoldingWithManualTermination", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getIF_InitialFix_() const {
  if (iF_InitialFix_Accessor) {
    return *iF_InitialFix_Accessor;
  }
  throw uci::base::UCIException("Error in getIF_InitialFix(): An attempt was made to get an optional field that was not enabled, call hasIF_InitialFix() to determine if it is safe to call getIF_InitialFix()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getIF_InitialFix() const {
  return getIF_InitialFix_();
}

uci::type::EmptyType& CivilPathTerminatorType::getIF_InitialFix() {
  return getIF_InitialFix_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setIF_InitialFix(const uci::type::EmptyType& value) {
  return setIF_InitialFix(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setIF_InitialFix(const std::string& value) {
  return setIF_InitialFix(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setIF_InitialFix(const char * value) {
  chooseIF_InitialFix().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isIF_InitialFix() const noexcept {
  return static_cast<bool>(iF_InitialFix_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseIF_InitialFix(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!iF_InitialFix_Accessor) {
    iF_InitialFix_Accessor = EmptyType::create(type);
  }
  return *iF_InitialFix_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseIF_InitialFix(uci::base::accessorType::AccessorType type) {
  return chooseIF_InitialFix("chooseIF_InitialFix", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getPI_ProcedureTurnToIntercept_() const {
  if (pI_ProcedureTurnToIntercept_Accessor) {
    return *pI_ProcedureTurnToIntercept_Accessor;
  }
  throw uci::base::UCIException("Error in getPI_ProcedureTurnToIntercept(): An attempt was made to get an optional field that was not enabled, call hasPI_ProcedureTurnToIntercept() to determine if it is safe to call getPI_ProcedureTurnToIntercept()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getPI_ProcedureTurnToIntercept() const {
  return getPI_ProcedureTurnToIntercept_();
}

uci::type::EmptyType& CivilPathTerminatorType::getPI_ProcedureTurnToIntercept() {
  return getPI_ProcedureTurnToIntercept_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setPI_ProcedureTurnToIntercept(const uci::type::EmptyType& value) {
  return setPI_ProcedureTurnToIntercept(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setPI_ProcedureTurnToIntercept(const std::string& value) {
  return setPI_ProcedureTurnToIntercept(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setPI_ProcedureTurnToIntercept(const char * value) {
  choosePI_ProcedureTurnToIntercept().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isPI_ProcedureTurnToIntercept() const noexcept {
  return static_cast<bool>(pI_ProcedureTurnToIntercept_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::choosePI_ProcedureTurnToIntercept(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!pI_ProcedureTurnToIntercept_Accessor) {
    pI_ProcedureTurnToIntercept_Accessor = EmptyType::create(type);
  }
  return *pI_ProcedureTurnToIntercept_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::choosePI_ProcedureTurnToIntercept(uci::base::accessorType::AccessorType type) {
  return choosePI_ProcedureTurnToIntercept("choosePI_ProcedureTurnToIntercept", type);
}

uci::type::RF_RadiusToFixType& CivilPathTerminatorType::getRF_RadiusToFix_() const {
  if (rF_RadiusToFix_Accessor) {
    return *rF_RadiusToFix_Accessor;
  }
  throw uci::base::UCIException("Error in getRF_RadiusToFix(): Unable to get RF_RadiusToFix, field not selected");
}

const uci::type::RF_RadiusToFixType& CivilPathTerminatorType::getRF_RadiusToFix() const {
  return getRF_RadiusToFix_();
}

uci::type::RF_RadiusToFixType& CivilPathTerminatorType::getRF_RadiusToFix() {
  return getRF_RadiusToFix_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setRF_RadiusToFix(const uci::type::RF_RadiusToFixType& accessor) {
  chooseRF_RadiusToFix();
  if (&accessor != rF_RadiusToFix_Accessor.get()) {
    rF_RadiusToFix_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CivilPathTerminatorType::isRF_RadiusToFix() const noexcept {
  return static_cast<bool>(rF_RadiusToFix_Accessor);
}

uci::type::RF_RadiusToFixType& CivilPathTerminatorType::chooseRF_RadiusToFix(const std::string& method, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::rF_RadiusToFixType : type};
  if ((!rF_RadiusToFix_Accessor) || (rF_RadiusToFix_Accessor->getAccessorType() != requestedType)) {
    rF_RadiusToFix_Accessor = RF_RadiusToFixType::create(type);
    if (!rF_RadiusToFix_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *rF_RadiusToFix_Accessor;
}

uci::type::RF_RadiusToFixType& CivilPathTerminatorType::chooseRF_RadiusToFix(uci::base::accessorType::AccessorType type) {
  return chooseRF_RadiusToFix("chooseRF_RadiusToFix", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getTF_TrackToFix_() const {
  if (tF_TrackToFix_Accessor) {
    return *tF_TrackToFix_Accessor;
  }
  throw uci::base::UCIException("Error in getTF_TrackToFix(): An attempt was made to get an optional field that was not enabled, call hasTF_TrackToFix() to determine if it is safe to call getTF_TrackToFix()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getTF_TrackToFix() const {
  return getTF_TrackToFix_();
}

uci::type::EmptyType& CivilPathTerminatorType::getTF_TrackToFix() {
  return getTF_TrackToFix_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setTF_TrackToFix(const uci::type::EmptyType& value) {
  return setTF_TrackToFix(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setTF_TrackToFix(const std::string& value) {
  return setTF_TrackToFix(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setTF_TrackToFix(const char * value) {
  chooseTF_TrackToFix().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isTF_TrackToFix() const noexcept {
  return static_cast<bool>(tF_TrackToFix_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseTF_TrackToFix(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!tF_TrackToFix_Accessor) {
    tF_TrackToFix_Accessor = EmptyType::create(type);
  }
  return *tF_TrackToFix_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseTF_TrackToFix(uci::base::accessorType::AccessorType type) {
  return chooseTF_TrackToFix("chooseTF_TrackToFix", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getVA_HeadingToAltitude_() const {
  if (vA_HeadingToAltitude_Accessor) {
    return *vA_HeadingToAltitude_Accessor;
  }
  throw uci::base::UCIException("Error in getVA_HeadingToAltitude(): An attempt was made to get an optional field that was not enabled, call hasVA_HeadingToAltitude() to determine if it is safe to call getVA_HeadingToAltitude()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getVA_HeadingToAltitude() const {
  return getVA_HeadingToAltitude_();
}

uci::type::EmptyType& CivilPathTerminatorType::getVA_HeadingToAltitude() {
  return getVA_HeadingToAltitude_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVA_HeadingToAltitude(const uci::type::EmptyType& value) {
  return setVA_HeadingToAltitude(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVA_HeadingToAltitude(const std::string& value) {
  return setVA_HeadingToAltitude(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVA_HeadingToAltitude(const char * value) {
  chooseVA_HeadingToAltitude().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isVA_HeadingToAltitude() const noexcept {
  return static_cast<bool>(vA_HeadingToAltitude_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVA_HeadingToAltitude(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!vA_HeadingToAltitude_Accessor) {
    vA_HeadingToAltitude_Accessor = EmptyType::create(type);
  }
  return *vA_HeadingToAltitude_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVA_HeadingToAltitude(uci::base::accessorType::AccessorType type) {
  return chooseVA_HeadingToAltitude("chooseVA_HeadingToAltitude", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getVD_HeadingToDMEDistanceTermination_() const {
  if (vD_HeadingToDMEDistanceTermination_Accessor) {
    return *vD_HeadingToDMEDistanceTermination_Accessor;
  }
  throw uci::base::UCIException("Error in getVD_HeadingToDMEDistanceTermination(): An attempt was made to get an optional field that was not enabled, call hasVD_HeadingToDMEDistanceTermination() to determine if it is safe to call getVD_HeadingToDMEDistanceTermination()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getVD_HeadingToDMEDistanceTermination() const {
  return getVD_HeadingToDMEDistanceTermination_();
}

uci::type::EmptyType& CivilPathTerminatorType::getVD_HeadingToDMEDistanceTermination() {
  return getVD_HeadingToDMEDistanceTermination_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVD_HeadingToDMEDistanceTermination(const uci::type::EmptyType& value) {
  return setVD_HeadingToDMEDistanceTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVD_HeadingToDMEDistanceTermination(const std::string& value) {
  return setVD_HeadingToDMEDistanceTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVD_HeadingToDMEDistanceTermination(const char * value) {
  chooseVD_HeadingToDMEDistanceTermination().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isVD_HeadingToDMEDistanceTermination() const noexcept {
  return static_cast<bool>(vD_HeadingToDMEDistanceTermination_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVD_HeadingToDMEDistanceTermination(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!vD_HeadingToDMEDistanceTermination_Accessor) {
    vD_HeadingToDMEDistanceTermination_Accessor = EmptyType::create(type);
  }
  return *vD_HeadingToDMEDistanceTermination_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVD_HeadingToDMEDistanceTermination(uci::base::accessorType::AccessorType type) {
  return chooseVD_HeadingToDMEDistanceTermination("chooseVD_HeadingToDMEDistanceTermination", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getVI_HeadingToIntercept_() const {
  if (vI_HeadingToIntercept_Accessor) {
    return *vI_HeadingToIntercept_Accessor;
  }
  throw uci::base::UCIException("Error in getVI_HeadingToIntercept(): An attempt was made to get an optional field that was not enabled, call hasVI_HeadingToIntercept() to determine if it is safe to call getVI_HeadingToIntercept()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getVI_HeadingToIntercept() const {
  return getVI_HeadingToIntercept_();
}

uci::type::EmptyType& CivilPathTerminatorType::getVI_HeadingToIntercept() {
  return getVI_HeadingToIntercept_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVI_HeadingToIntercept(const uci::type::EmptyType& value) {
  return setVI_HeadingToIntercept(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVI_HeadingToIntercept(const std::string& value) {
  return setVI_HeadingToIntercept(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVI_HeadingToIntercept(const char * value) {
  chooseVI_HeadingToIntercept().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isVI_HeadingToIntercept() const noexcept {
  return static_cast<bool>(vI_HeadingToIntercept_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVI_HeadingToIntercept(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!vI_HeadingToIntercept_Accessor) {
    vI_HeadingToIntercept_Accessor = EmptyType::create(type);
  }
  return *vI_HeadingToIntercept_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVI_HeadingToIntercept(uci::base::accessorType::AccessorType type) {
  return chooseVI_HeadingToIntercept("chooseVI_HeadingToIntercept", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getVM_HeadingToManual_() const {
  if (vM_HeadingToManual_Accessor) {
    return *vM_HeadingToManual_Accessor;
  }
  throw uci::base::UCIException("Error in getVM_HeadingToManual(): An attempt was made to get an optional field that was not enabled, call hasVM_HeadingToManual() to determine if it is safe to call getVM_HeadingToManual()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getVM_HeadingToManual() const {
  return getVM_HeadingToManual_();
}

uci::type::EmptyType& CivilPathTerminatorType::getVM_HeadingToManual() {
  return getVM_HeadingToManual_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVM_HeadingToManual(const uci::type::EmptyType& value) {
  return setVM_HeadingToManual(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVM_HeadingToManual(const std::string& value) {
  return setVM_HeadingToManual(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVM_HeadingToManual(const char * value) {
  chooseVM_HeadingToManual().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isVM_HeadingToManual() const noexcept {
  return static_cast<bool>(vM_HeadingToManual_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVM_HeadingToManual(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vR_HeadingToRadialTermination_Accessor.reset();
  if (!vM_HeadingToManual_Accessor) {
    vM_HeadingToManual_Accessor = EmptyType::create(type);
  }
  return *vM_HeadingToManual_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVM_HeadingToManual(uci::base::accessorType::AccessorType type) {
  return chooseVM_HeadingToManual("chooseVM_HeadingToManual", type);
}

uci::type::EmptyType& CivilPathTerminatorType::getVR_HeadingToRadialTermination_() const {
  if (vR_HeadingToRadialTermination_Accessor) {
    return *vR_HeadingToRadialTermination_Accessor;
  }
  throw uci::base::UCIException("Error in getVR_HeadingToRadialTermination(): An attempt was made to get an optional field that was not enabled, call hasVR_HeadingToRadialTermination() to determine if it is safe to call getVR_HeadingToRadialTermination()");
}

const uci::type::EmptyType& CivilPathTerminatorType::getVR_HeadingToRadialTermination() const {
  return getVR_HeadingToRadialTermination_();
}

uci::type::EmptyType& CivilPathTerminatorType::getVR_HeadingToRadialTermination() {
  return getVR_HeadingToRadialTermination_();
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVR_HeadingToRadialTermination(const uci::type::EmptyType& value) {
  return setVR_HeadingToRadialTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVR_HeadingToRadialTermination(const std::string& value) {
  return setVR_HeadingToRadialTermination(value.c_str());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::setVR_HeadingToRadialTermination(const char * value) {
  chooseVR_HeadingToRadialTermination().setStringValue(value);
  return *this;
}

bool CivilPathTerminatorType::isVR_HeadingToRadialTermination() const noexcept {
  return static_cast<bool>(vR_HeadingToRadialTermination_Accessor);
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVR_HeadingToRadialTermination(const std::string& /*method*/, uci::base::accessorType::AccessorType type) {
  aF_ArcToFix_Accessor.reset();
  cA_CourseToAltitude_Accessor.reset();
  cD_CourseToDMEDistance_Accessor.reset();
  cF_CourseToFix_Accessor.reset();
  cI_CourseToIntercept_Accessor.reset();
  cR_CourseToRadial_Accessor.reset();
  dF_DirectToFix_Accessor.reset();
  fA_TrackToAltitude_Accessor.reset();
  fC_TrackFromFixToDistanceAlongTrack_Accessor.reset();
  fD_TrackFromFixToDMEDistance_Accessor.reset();
  fM_FixToManualTermination_Accessor.reset();
  hA_HoldingWithAltitudeTermination_Accessor.reset();
  hF_HoldingWithFixTermination_Accessor.reset();
  hM_HoldingWithManualTermination_Accessor.reset();
  iF_InitialFix_Accessor.reset();
  pI_ProcedureTurnToIntercept_Accessor.reset();
  rF_RadiusToFix_Accessor.reset();
  tF_TrackToFix_Accessor.reset();
  vA_HeadingToAltitude_Accessor.reset();
  vD_HeadingToDMEDistanceTermination_Accessor.reset();
  vI_HeadingToIntercept_Accessor.reset();
  vM_HeadingToManual_Accessor.reset();
  if (!vR_HeadingToRadialTermination_Accessor) {
    vR_HeadingToRadialTermination_Accessor = EmptyType::create(type);
  }
  return *vR_HeadingToRadialTermination_Accessor;
}

uci::type::EmptyType& CivilPathTerminatorType::chooseVR_HeadingToRadialTermination(uci::base::accessorType::AccessorType type) {
  return chooseVR_HeadingToRadialTermination("chooseVR_HeadingToRadialTermination", type);
}

std::unique_ptr<CivilPathTerminatorType> CivilPathTerminatorType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::civilPathTerminatorType : type};
  return (requestedType == uci::type::accessorType::civilPathTerminatorType) ? boost::make_unique<CivilPathTerminatorType>() : nullptr;
}

/**  */
namespace CivilPathTerminatorType_Names {

constexpr const char* Extern_Type_Name{"CivilPathTerminatorType"};
constexpr const char* AF_ArcToFix_Name{"AF_ArcToFix"};
constexpr const char* CA_CourseToAltitude_Name{"CA_CourseToAltitude"};
constexpr const char* CD_CourseToDMEDistance_Name{"CD_CourseToDMEDistance"};
constexpr const char* CF_CourseToFix_Name{"CF_CourseToFix"};
constexpr const char* CI_CourseToIntercept_Name{"CI_CourseToIntercept"};
constexpr const char* CR_CourseToRadial_Name{"CR_CourseToRadial"};
constexpr const char* DF_DirectToFix_Name{"DF_DirectToFix"};
constexpr const char* FA_TrackToAltitude_Name{"FA_TrackToAltitude"};
constexpr const char* FC_TrackFromFixToDistanceAlongTrack_Name{"FC_TrackFromFixToDistanceAlongTrack"};
constexpr const char* FD_TrackFromFixToDMEDistance_Name{"FD_TrackFromFixToDMEDistance"};
constexpr const char* FM_FixToManualTermination_Name{"FM_FixToManualTermination"};
constexpr const char* HA_HoldingWithAltitudeTermination_Name{"HA_HoldingWithAltitudeTermination"};
constexpr const char* HF_HoldingWithFixTermination_Name{"HF_HoldingWithFixTermination"};
constexpr const char* HM_HoldingWithManualTermination_Name{"HM_HoldingWithManualTermination"};
constexpr const char* IF_InitialFix_Name{"IF_InitialFix"};
constexpr const char* PI_ProcedureTurnToIntercept_Name{"PI_ProcedureTurnToIntercept"};
constexpr const char* RF_RadiusToFix_Name{"RF_RadiusToFix"};
constexpr const char* TF_TrackToFix_Name{"TF_TrackToFix"};
constexpr const char* VA_HeadingToAltitude_Name{"VA_HeadingToAltitude"};
constexpr const char* VD_HeadingToDMEDistanceTermination_Name{"VD_HeadingToDMEDistanceTermination"};
constexpr const char* VI_HeadingToIntercept_Name{"VI_HeadingToIntercept"};
constexpr const char* VM_HeadingToManual_Name{"VM_HeadingToManual"};
constexpr const char* VR_HeadingToRadialTermination_Name{"VR_HeadingToRadialTermination"};

} // namespace CivilPathTerminatorType_Names

void CivilPathTerminatorType::deserialize(const boost::property_tree::ptree& propTree, uci::type::CivilPathTerminatorType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = CivilPathTerminatorType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::AF_ArcToFix_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseAF_ArcToFix().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::CA_CourseToAltitude_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseCA_CourseToAltitude().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::CD_CourseToDMEDistance_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseCD_CourseToDMEDistance().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::CF_CourseToFix_Name) {
      CF_CourseToFixType::deserialize(valueType.second, accessor.chooseCF_CourseToFix(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::CI_CourseToIntercept_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseCI_CourseToIntercept().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::CR_CourseToRadial_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseCR_CourseToRadial().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::DF_DirectToFix_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseDF_DirectToFix().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::FA_TrackToAltitude_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseFA_TrackToAltitude().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::FC_TrackFromFixToDistanceAlongTrack_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseFC_TrackFromFixToDistanceAlongTrack().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::FD_TrackFromFixToDMEDistance_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseFD_TrackFromFixToDMEDistance().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::FM_FixToManualTermination_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseFM_FixToManualTermination().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::HA_HoldingWithAltitudeTermination_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseHA_HoldingWithAltitudeTermination().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::HF_HoldingWithFixTermination_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseHF_HoldingWithFixTermination().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::HM_HoldingWithManualTermination_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseHM_HoldingWithManualTermination().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::IF_InitialFix_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseIF_InitialFix().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::PI_ProcedureTurnToIntercept_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.choosePI_ProcedureTurnToIntercept().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::RF_RadiusToFix_Name) {
      RF_RadiusToFixType::deserialize(valueType.second, accessor.chooseRF_RadiusToFix(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::TF_TrackToFix_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseTF_TrackToFix().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::VA_HeadingToAltitude_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseVA_HeadingToAltitude().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::VD_HeadingToDMEDistanceTermination_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseVD_HeadingToDMEDistanceTermination().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::VI_HeadingToIntercept_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseVI_HeadingToIntercept().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::VM_HeadingToManual_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseVM_HeadingToManual().setStringValue(*value);
      }
    } else if (valueType.first == nsPrefix + CivilPathTerminatorType_Names::VR_HeadingToRadialTermination_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.chooseVR_HeadingToRadialTermination().setStringValue(*value);
      }
    }
  }
}

std::string CivilPathTerminatorType::serialize(const uci::type::CivilPathTerminatorType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? CivilPathTerminatorType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, CivilPathTerminatorType_Names::Extern_Type_Name);
  }
  if (accessor.isAF_ArcToFix()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getAF_ArcToFix(), node, CivilPathTerminatorType_Names::AF_ArcToFix_Name);
  } else if (accessor.isCA_CourseToAltitude()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getCA_CourseToAltitude(), node, CivilPathTerminatorType_Names::CA_CourseToAltitude_Name);
  } else if (accessor.isCD_CourseToDMEDistance()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getCD_CourseToDMEDistance(), node, CivilPathTerminatorType_Names::CD_CourseToDMEDistance_Name);
  } else if (accessor.isCF_CourseToFix()) {
    CF_CourseToFixType::serialize(accessor.getCF_CourseToFix(), node, CivilPathTerminatorType_Names::CF_CourseToFix_Name);
  } else if (accessor.isCI_CourseToIntercept()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getCI_CourseToIntercept(), node, CivilPathTerminatorType_Names::CI_CourseToIntercept_Name);
  } else if (accessor.isCR_CourseToRadial()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getCR_CourseToRadial(), node, CivilPathTerminatorType_Names::CR_CourseToRadial_Name);
  } else if (accessor.isDF_DirectToFix()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getDF_DirectToFix(), node, CivilPathTerminatorType_Names::DF_DirectToFix_Name);
  } else if (accessor.isFA_TrackToAltitude()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFA_TrackToAltitude(), node, CivilPathTerminatorType_Names::FA_TrackToAltitude_Name);
  } else if (accessor.isFC_TrackFromFixToDistanceAlongTrack()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFC_TrackFromFixToDistanceAlongTrack(), node, CivilPathTerminatorType_Names::FC_TrackFromFixToDistanceAlongTrack_Name);
  } else if (accessor.isFD_TrackFromFixToDMEDistance()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFD_TrackFromFixToDMEDistance(), node, CivilPathTerminatorType_Names::FD_TrackFromFixToDMEDistance_Name);
  } else if (accessor.isFM_FixToManualTermination()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getFM_FixToManualTermination(), node, CivilPathTerminatorType_Names::FM_FixToManualTermination_Name);
  } else if (accessor.isHA_HoldingWithAltitudeTermination()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getHA_HoldingWithAltitudeTermination(), node, CivilPathTerminatorType_Names::HA_HoldingWithAltitudeTermination_Name);
  } else if (accessor.isHF_HoldingWithFixTermination()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getHF_HoldingWithFixTermination(), node, CivilPathTerminatorType_Names::HF_HoldingWithFixTermination_Name);
  } else if (accessor.isHM_HoldingWithManualTermination()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getHM_HoldingWithManualTermination(), node, CivilPathTerminatorType_Names::HM_HoldingWithManualTermination_Name);
  } else if (accessor.isIF_InitialFix()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getIF_InitialFix(), node, CivilPathTerminatorType_Names::IF_InitialFix_Name);
  } else if (accessor.isPI_ProcedureTurnToIntercept()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getPI_ProcedureTurnToIntercept(), node, CivilPathTerminatorType_Names::PI_ProcedureTurnToIntercept_Name);
  } else if (accessor.isRF_RadiusToFix()) {
    RF_RadiusToFixType::serialize(accessor.getRF_RadiusToFix(), node, CivilPathTerminatorType_Names::RF_RadiusToFix_Name);
  } else if (accessor.isTF_TrackToFix()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getTF_TrackToFix(), node, CivilPathTerminatorType_Names::TF_TrackToFix_Name);
  } else if (accessor.isVA_HeadingToAltitude()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getVA_HeadingToAltitude(), node, CivilPathTerminatorType_Names::VA_HeadingToAltitude_Name);
  } else if (accessor.isVD_HeadingToDMEDistanceTermination()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getVD_HeadingToDMEDistanceTermination(), node, CivilPathTerminatorType_Names::VD_HeadingToDMEDistanceTermination_Name);
  } else if (accessor.isVI_HeadingToIntercept()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getVI_HeadingToIntercept(), node, CivilPathTerminatorType_Names::VI_HeadingToIntercept_Name);
  } else if (accessor.isVM_HeadingToManual()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getVM_HeadingToManual(), node, CivilPathTerminatorType_Names::VM_HeadingToManual_Name);
  } else if (accessor.isVR_HeadingToRadialTermination()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getVR_HeadingToRadialTermination(), node, CivilPathTerminatorType_Names::VR_HeadingToRadialTermination_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::CivilPathTerminatorType>().release());
}

uci::type::CivilPathTerminatorType& CivilPathTerminatorType::create(const uci::type::CivilPathTerminatorType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::CivilPathTerminatorType> newAccessor{boost::make_unique<asb_uci::type::CivilPathTerminatorType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void CivilPathTerminatorType::destroy(uci::type::CivilPathTerminatorType& accessor) {
  delete dynamic_cast<asb_uci::type::CivilPathTerminatorType*>(&accessor);
}

} // namespace type

} // namespace uci

