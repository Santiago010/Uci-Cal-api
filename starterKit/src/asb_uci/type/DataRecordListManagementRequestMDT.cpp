/** @file DataRecordListManagementRequestMDT.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:12 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/DataRecordListManagementRequestMDT.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/DataRecordInstanceID_Type.h"
#include "asb_uci/type/DataRecordListID_Type.h"
#include "asb_uci/type/ManagedListBaseType.h"
#include "asb_uci/type/RequestBaseType.h"
#include "asb_uci/util/DerivedTypesDeserializer.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/DataRecordInstanceID_Type.h"
#include "uci/type/DataRecordListID_Type.h"
#include "uci/type/DataRecordListManagementRequestMDT.h"
#include "uci/type/ManagedListBaseType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

DataRecordListManagementRequestMDT::DataRecordListManagementRequestMDT()
  : dataRecordListID_Accessor{boost::make_unique<DataRecordListID_Type>()} {
}

DataRecordListManagementRequestMDT::~DataRecordListManagementRequestMDT() = default;

void DataRecordListManagementRequestMDT::copy(const uci::type::DataRecordListManagementRequestMDT& accessor) {
  copyImpl(accessor, false);
}

void DataRecordListManagementRequestMDT::copyImpl(const uci::type::DataRecordListManagementRequestMDT& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    RequestBaseType::copyImpl(accessor, false);
    const auto& accessorImpl = dynamic_cast<const DataRecordListManagementRequestMDT&>(accessor);
    setDataRecordListID(*(accessorImpl.dataRecordListID_Accessor));
    if (accessorImpl.dataRecordInstanceID_Accessor) {
      setDataRecordInstanceID(*(accessorImpl.dataRecordInstanceID_Accessor));
    } else {
      dataRecordInstanceID_Accessor.reset();
    }
    if (accessorImpl.addRecord_Accessor) {
      setAddRecord(*(accessorImpl.addRecord_Accessor));
    } else {
      addRecord_Accessor.reset();
    }
    if (accessorImpl.deleteRecord_Accessor) {
      setDeleteRecord(*(accessorImpl.deleteRecord_Accessor));
    } else {
      deleteRecord_Accessor.reset();
    }
  }
}

void DataRecordListManagementRequestMDT::reset() noexcept {
  RequestBaseType::reset();
  if (dataRecordListID_Accessor->getAccessorType() != uci::type::accessorType::dataRecordListID_Type) {
    dataRecordListID_Accessor = boost::make_unique<DataRecordListID_Type>();
  } else {
    dataRecordListID_Accessor->reset();
  }
  dataRecordInstanceID_Accessor.reset();
  addRecord_Accessor.reset();
  deleteRecord_Accessor.reset();
}

const uci::type::DataRecordListID_Type& DataRecordListManagementRequestMDT::getDataRecordListID() const {
  return *dataRecordListID_Accessor;
}

uci::type::DataRecordListID_Type& DataRecordListManagementRequestMDT::getDataRecordListID() {
  return *dataRecordListID_Accessor;
}

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::setDataRecordListID(const uci::type::DataRecordListID_Type& accessor) {
  enableDataRecordListID(accessor.getAccessorType());
  if (&accessor != dataRecordListID_Accessor.get()) {
    dataRecordListID_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

uci::type::DataRecordListID_Type& DataRecordListManagementRequestMDT::enableDataRecordListID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::dataRecordListID_Type : type};
  if ((!dataRecordListID_Accessor) || (dataRecordListID_Accessor->getAccessorType() != requestedType)) {
    dataRecordListID_Accessor = DataRecordListID_Type::create(requestedType);
    if (!dataRecordListID_Accessor) {
      throw uci::base::UCIException("Error in enableDataRecordListID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *dataRecordListID_Accessor;
}

uci::type::DataRecordInstanceID_Type& DataRecordListManagementRequestMDT::getDataRecordInstanceID_() const {
  if (dataRecordInstanceID_Accessor) {
    return *dataRecordInstanceID_Accessor;
  }
  throw uci::base::UCIException("Error in getDataRecordInstanceID(): An attempt was made to get an optional field that was not enabled, call hasDataRecordInstanceID() to determine if it is safe to call getDataRecordInstanceID()");
}

const uci::type::DataRecordInstanceID_Type& DataRecordListManagementRequestMDT::getDataRecordInstanceID() const {
  return getDataRecordInstanceID_();
}

uci::type::DataRecordInstanceID_Type& DataRecordListManagementRequestMDT::getDataRecordInstanceID() {
  return getDataRecordInstanceID_();
}

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::setDataRecordInstanceID(const uci::type::DataRecordInstanceID_Type& accessor) {
  enableDataRecordInstanceID();
  if (&accessor != dataRecordInstanceID_Accessor.get()) {
    dataRecordInstanceID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool DataRecordListManagementRequestMDT::hasDataRecordInstanceID() const noexcept {
  return static_cast<bool>(dataRecordInstanceID_Accessor);
}

uci::type::DataRecordInstanceID_Type& DataRecordListManagementRequestMDT::enableDataRecordInstanceID(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::dataRecordInstanceID_Type : type};
  if ((!dataRecordInstanceID_Accessor) || (dataRecordInstanceID_Accessor->getAccessorType() != requestedType)) {
    dataRecordInstanceID_Accessor = DataRecordInstanceID_Type::create(requestedType);
    if (!dataRecordInstanceID_Accessor) {
      throw uci::base::UCIException("Error in enableDataRecordInstanceID(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *dataRecordInstanceID_Accessor;
}

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::clearDataRecordInstanceID() noexcept {
  dataRecordInstanceID_Accessor.reset();
  return *this;
}

uci::type::ManagedListBaseType& DataRecordListManagementRequestMDT::getAddRecord_() const {
  if (addRecord_Accessor) {
    return *addRecord_Accessor;
  }
  throw uci::base::UCIException("Error in getAddRecord(): An attempt was made to get an optional field that was not enabled, call hasAddRecord() to determine if it is safe to call getAddRecord()");
}

const uci::type::ManagedListBaseType& DataRecordListManagementRequestMDT::getAddRecord() const {
  return getAddRecord_();
}

uci::type::ManagedListBaseType& DataRecordListManagementRequestMDT::getAddRecord() {
  return getAddRecord_();
}

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::setAddRecord(const uci::type::ManagedListBaseType& accessor) {
  enableAddRecord(accessor.getAccessorType());
  if (&accessor != addRecord_Accessor.get()) {
    addRecord_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool DataRecordListManagementRequestMDT::hasAddRecord() const noexcept {
  return static_cast<bool>(addRecord_Accessor);
}

uci::type::ManagedListBaseType& DataRecordListManagementRequestMDT::enableAddRecord(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::managedListBaseType : type};
  if ((!addRecord_Accessor) || (addRecord_Accessor->getAccessorType() != requestedType)) {
    addRecord_Accessor = ManagedListBaseType::create(requestedType);
    if (!addRecord_Accessor) {
      throw uci::base::UCIException("Error in enableAddRecord(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *addRecord_Accessor;
}

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::clearAddRecord() noexcept {
  addRecord_Accessor.reset();
  return *this;
}

uci::type::ManagedListBaseType& DataRecordListManagementRequestMDT::getDeleteRecord_() const {
  if (deleteRecord_Accessor) {
    return *deleteRecord_Accessor;
  }
  throw uci::base::UCIException("Error in getDeleteRecord(): An attempt was made to get an optional field that was not enabled, call hasDeleteRecord() to determine if it is safe to call getDeleteRecord()");
}

const uci::type::ManagedListBaseType& DataRecordListManagementRequestMDT::getDeleteRecord() const {
  return getDeleteRecord_();
}

uci::type::ManagedListBaseType& DataRecordListManagementRequestMDT::getDeleteRecord() {
  return getDeleteRecord_();
}

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::setDeleteRecord(const uci::type::ManagedListBaseType& accessor) {
  enableDeleteRecord(accessor.getAccessorType());
  if (&accessor != deleteRecord_Accessor.get()) {
    deleteRecord_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool DataRecordListManagementRequestMDT::hasDeleteRecord() const noexcept {
  return static_cast<bool>(deleteRecord_Accessor);
}

uci::type::ManagedListBaseType& DataRecordListManagementRequestMDT::enableDeleteRecord(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::managedListBaseType : type};
  if ((!deleteRecord_Accessor) || (deleteRecord_Accessor->getAccessorType() != requestedType)) {
    deleteRecord_Accessor = ManagedListBaseType::create(requestedType);
    if (!deleteRecord_Accessor) {
      throw uci::base::UCIException("Error in enableDeleteRecord(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *deleteRecord_Accessor;
}

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::clearDeleteRecord() noexcept {
  deleteRecord_Accessor.reset();
  return *this;
}

std::unique_ptr<DataRecordListManagementRequestMDT> DataRecordListManagementRequestMDT::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::dataRecordListManagementRequestMDT : type};
  return (requestedType == uci::type::accessorType::dataRecordListManagementRequestMDT) ? boost::make_unique<DataRecordListManagementRequestMDT>() : nullptr;
}

/**  */
namespace DataRecordListManagementRequestMDT_Names {

constexpr const char* Extern_Type_Name{"DataRecordListManagementRequestMDT"};
constexpr const char* DataRecordListID_Name{"DataRecordListID"};
constexpr const char* DataRecordInstanceID_Name{"DataRecordInstanceID"};
constexpr const char* AddRecord_Name{"AddRecord"};
constexpr const char* DeleteRecord_Name{"DeleteRecord"};

} // namespace DataRecordListManagementRequestMDT_Names

void DataRecordListManagementRequestMDT::deserialize(const boost::property_tree::ptree& propTree, uci::type::DataRecordListManagementRequestMDT& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = DataRecordListManagementRequestMDT_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + DataRecordListManagementRequestMDT_Names::DataRecordListID_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableDataRecordListID(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + DataRecordListManagementRequestMDT_Names::DataRecordInstanceID_Name) {
      DataRecordInstanceID_Type::deserialize(valueType.second, accessor.enableDataRecordInstanceID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + DataRecordListManagementRequestMDT_Names::AddRecord_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableAddRecord(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + DataRecordListManagementRequestMDT_Names::DeleteRecord_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableDeleteRecord(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    }
  }
  RequestBaseType::deserialize(node, accessor, nodeName, nsPrefix);
}

std::string DataRecordListManagementRequestMDT::serialize(const uci::type::DataRecordListManagementRequestMDT& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? DataRecordListManagementRequestMDT_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, DataRecordListManagementRequestMDT_Names::Extern_Type_Name);
  }
  RequestBaseType::serialize(accessor, node, "", false, false, false);
  DataRecordListID_Type::serialize(accessor.getDataRecordListID(), node, DataRecordListManagementRequestMDT_Names::DataRecordListID_Name);
  if (accessor.hasDataRecordInstanceID()) {
    DataRecordInstanceID_Type::serialize(accessor.getDataRecordInstanceID(), node, DataRecordListManagementRequestMDT_Names::DataRecordInstanceID_Name);
  }
  if (accessor.hasAddRecord()) {
    ManagedListBaseType::serialize(accessor.getAddRecord(), node, DataRecordListManagementRequestMDT_Names::AddRecord_Name);
  }
  if (accessor.hasDeleteRecord()) {
    ManagedListBaseType::serialize(accessor.getDeleteRecord(), node, DataRecordListManagementRequestMDT_Names::DeleteRecord_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::DataRecordListManagementRequestMDT>().release());
}

uci::type::DataRecordListManagementRequestMDT& DataRecordListManagementRequestMDT::create(const uci::type::DataRecordListManagementRequestMDT& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::DataRecordListManagementRequestMDT> newAccessor{boost::make_unique<asb_uci::type::DataRecordListManagementRequestMDT>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void DataRecordListManagementRequestMDT::destroy(uci::type::DataRecordListManagementRequestMDT& accessor) {
  delete dynamic_cast<asb_uci::type::DataRecordListManagementRequestMDT*>(&accessor);
}

} // namespace type

} // namespace uci

