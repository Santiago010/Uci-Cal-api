/** @file WeatherAreaDataType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/WeatherAreaDataType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/CloudsType.h"
#include "../../../include/asb_uci/type/VisibleString1024Type.h"
#include "../../../include/asb_uci/type/VisibleString32Type.h"
#include "../../../include/asb_uci/type/WeatherDescriptionEnum.h"
#include "../../../include/asb_uci/type/WeatherEffectsType.h"
#include "../../../include/asb_uci/type/WeatherKindEnum.h"
#include "../../../include/asb_uci/type/WeatherPrecipitationAmplificationEnum.h"
#include "../../../include/asb_uci/type/WeatherPrecipitationEnum.h"
#include "../../../include/asb_uci/type/WeatherSeverityEnum.h"
#include "../../../include/asb_uci/type/WeatherSourceEnum.h"
#include "../../../include/asb_uci/type/WeatherVisibilityEnum.h"
#include "../../../include/asb_uci/type/WindDataType.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CloudsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DistanceType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PercentType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PrecipitationAmountType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/TemperatureType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/VisibleString1024Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/VisibleString32Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherAreaDataType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherDescriptionEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherEffectsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherKindEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherPrecipitationAmplificationEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherPrecipitationEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherSeverityEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherSourceEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WeatherVisibilityEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/WindDataType.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

WeatherAreaDataType::WeatherAreaDataType()
  : source_Accessor{boost::make_unique<WeatherSourceEnum>()},
    clouds_Accessor{boost::make_unique<Clouds>(0, SIZE_MAX)} {
}

WeatherAreaDataType::~WeatherAreaDataType() = default;

void WeatherAreaDataType::copy(const uci::type::WeatherAreaDataType& accessor) {
  copyImpl(accessor, false);
}

void WeatherAreaDataType::copyImpl(const uci::type::WeatherAreaDataType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const WeatherAreaDataType&>(accessor);
    setSource(*(accessorImpl.source_Accessor));
    if (accessorImpl.stationCode_Accessor) {
      setStationCode(*(accessorImpl.stationCode_Accessor));
    } else {
      stationCode_Accessor.reset();
    }
    if (accessorImpl.hasTemperature()) {
      setTemperature(accessorImpl.getTemperature());
    } else {
      clearTemperature();
    }
    if (accessorImpl.hasPrecipitationPotential()) {
      setPrecipitationPotential(accessorImpl.getPrecipitationPotential());
    } else {
      clearPrecipitationPotential();
    }
    if (accessorImpl.hasPrecipitationAmount()) {
      setPrecipitationAmount(accessorImpl.getPrecipitationAmount());
    } else {
      clearPrecipitationAmount();
    }
    if (accessorImpl.typeOfPrecipitation_Accessor) {
      setTypeOfPrecipitation(*(accessorImpl.typeOfPrecipitation_Accessor));
    } else {
      typeOfPrecipitation_Accessor.reset();
    }
    if (accessorImpl.precipitationAmplification_Accessor) {
      setPrecipitationAmplification(*(accessorImpl.precipitationAmplification_Accessor));
    } else {
      precipitationAmplification_Accessor.reset();
    }
    if (accessorImpl.hasVisibility()) {
      setVisibility(accessorImpl.getVisibility());
    } else {
      clearVisibility();
    }
    if (accessorImpl.visibilityStatus_Accessor) {
      setVisibilityStatus(*(accessorImpl.visibilityStatus_Accessor));
    } else {
      visibilityStatus_Accessor.reset();
    }
    if (accessorImpl.hasDewPoint()) {
      setDewPoint(accessorImpl.getDewPoint());
    } else {
      clearDewPoint();
    }
    setClouds(*(accessorImpl.clouds_Accessor));
    if (accessorImpl.weatherEffects_Accessor) {
      setWeatherEffects(*(accessorImpl.weatherEffects_Accessor));
    } else {
      weatherEffects_Accessor.reset();
    }
    if (accessorImpl.hasBarometricPressure()) {
      setBarometricPressure(accessorImpl.getBarometricPressure());
    } else {
      clearBarometricPressure();
    }
    if (accessorImpl.hasKollsmanSetting()) {
      setKollsmanSetting(accessorImpl.getKollsmanSetting());
    } else {
      clearKollsmanSetting();
    }
    if (accessorImpl.icing_Accessor) {
      setIcing(*(accessorImpl.icing_Accessor));
    } else {
      icing_Accessor.reset();
    }
    if (accessorImpl.turbulence_Accessor) {
      setTurbulence(*(accessorImpl.turbulence_Accessor));
    } else {
      turbulence_Accessor.reset();
    }
    if (accessorImpl.hasThunderstormPotential()) {
      setThunderstormPotential(accessorImpl.getThunderstormPotential());
    } else {
      clearThunderstormPotential();
    }
    if (accessorImpl.remarks_Accessor) {
      setRemarks(*(accessorImpl.remarks_Accessor));
    } else {
      remarks_Accessor.reset();
    }
    if (accessorImpl.kind_Accessor) {
      setKind(*(accessorImpl.kind_Accessor));
    } else {
      kind_Accessor.reset();
    }
    if (accessorImpl.description_Accessor) {
      setDescription(*(accessorImpl.description_Accessor));
    } else {
      description_Accessor.reset();
    }
    if (accessorImpl.qualifier_Accessor) {
      setQualifier(*(accessorImpl.qualifier_Accessor));
    } else {
      qualifier_Accessor.reset();
    }
    if (accessorImpl.windData_Accessor) {
      setWindData(*(accessorImpl.windData_Accessor));
    } else {
      windData_Accessor.reset();
    }
    if (accessorImpl.hasRelativeHumidity()) {
      setRelativeHumidity(accessorImpl.getRelativeHumidity());
    } else {
      clearRelativeHumidity();
    }
  }
}

void WeatherAreaDataType::reset() noexcept {
  source_Accessor->reset();
  stationCode_Accessor.reset();
  clearTemperature();
  clearPrecipitationPotential();
  clearPrecipitationAmount();
  typeOfPrecipitation_Accessor.reset();
  precipitationAmplification_Accessor.reset();
  clearVisibility();
  visibilityStatus_Accessor.reset();
  clearDewPoint();
  clouds_Accessor->reset();
  weatherEffects_Accessor.reset();
  clearBarometricPressure();
  clearKollsmanSetting();
  icing_Accessor.reset();
  turbulence_Accessor.reset();
  clearThunderstormPotential();
  remarks_Accessor.reset();
  kind_Accessor.reset();
  description_Accessor.reset();
  qualifier_Accessor.reset();
  windData_Accessor.reset();
  clearRelativeHumidity();
}

const uci::type::WeatherSourceEnum& WeatherAreaDataType::getSource() const {
  return *source_Accessor;
}

uci::type::WeatherSourceEnum& WeatherAreaDataType::getSource() {
  return *source_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setSource(const uci::type::WeatherSourceEnum& accessor) {
  if (&accessor != source_Accessor.get()) {
    source_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setSource(uci::type::WeatherSourceEnum::EnumerationItem value) {
  source_Accessor->setValue(value);
  return *this;
}


uci::type::VisibleString32Type& WeatherAreaDataType::getStationCode_() const {
  if (stationCode_Accessor) {
    return *stationCode_Accessor;
  }
  throw uci::base::UCIException("Error in getStationCode(): An attempt was made to get an optional field that was not enabled, call hasStationCode() to determine if it is safe to call getStationCode()");
}

const uci::type::VisibleString32Type& WeatherAreaDataType::getStationCode() const {
  return getStationCode_();
}

uci::type::VisibleString32Type& WeatherAreaDataType::getStationCode() {
  return getStationCode_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setStationCode(const uci::type::VisibleString32Type& value) {
  return setStationCode(value.c_str());
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setStationCode(const std::string& value) {
  return setStationCode(value.c_str());
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setStationCode(const char* value) {
  enableStationCode().setStringValue(value);
  return *this;
}

bool WeatherAreaDataType::hasStationCode() const noexcept {
  return static_cast<bool>(stationCode_Accessor);
}

uci::type::VisibleString32Type& WeatherAreaDataType::enableStationCode(uci::base::accessorType::AccessorType type) {
  if (!stationCode_Accessor) {
    stationCode_Accessor = VisibleString32Type::create(type);
  }
  return *stationCode_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearStationCode() noexcept {
  stationCode_Accessor.reset();
  return *this;
}

uci::type::TemperatureTypeValue WeatherAreaDataType::getTemperature() const {
  if (temperature_Accessor) {
    return *temperature_Accessor;
  }
  throw uci::base::UCIException("Error in getTemperature(): An attempt was made to get an optional field that was not enabled, call hasTemperature() to determine if it is safe to call getTemperature()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setTemperature(uci::type::TemperatureTypeValue value) {
  temperature_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasTemperature() const noexcept {
  return temperature_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearTemperature() noexcept {
  temperature_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue WeatherAreaDataType::getPrecipitationPotential() const {
  if (precipitationPotential_Accessor) {
    return *precipitationPotential_Accessor;
  }
  throw uci::base::UCIException("Error in getPrecipitationPotential(): An attempt was made to get an optional field that was not enabled, call hasPrecipitationPotential() to determine if it is safe to call getPrecipitationPotential()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setPrecipitationPotential(uci::type::PercentTypeValue value) {
  precipitationPotential_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasPrecipitationPotential() const noexcept {
  return precipitationPotential_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearPrecipitationPotential() noexcept {
  precipitationPotential_Accessor.reset();
  return *this;
}

uci::type::PrecipitationAmountTypeValue WeatherAreaDataType::getPrecipitationAmount() const {
  if (precipitationAmount_Accessor) {
    return *precipitationAmount_Accessor;
  }
  throw uci::base::UCIException("Error in getPrecipitationAmount(): An attempt was made to get an optional field that was not enabled, call hasPrecipitationAmount() to determine if it is safe to call getPrecipitationAmount()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setPrecipitationAmount(uci::type::PrecipitationAmountTypeValue value) {
  precipitationAmount_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasPrecipitationAmount() const noexcept {
  return precipitationAmount_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearPrecipitationAmount() noexcept {
  precipitationAmount_Accessor.reset();
  return *this;
}

uci::type::WeatherPrecipitationEnum& WeatherAreaDataType::getTypeOfPrecipitation_() const {
  if (typeOfPrecipitation_Accessor) {
    return *typeOfPrecipitation_Accessor;
  }
  throw uci::base::UCIException("Error in getTypeOfPrecipitation(): An attempt was made to get an optional field that was not enabled, call hasTypeOfPrecipitation() to determine if it is safe to call getTypeOfPrecipitation()");
}

const uci::type::WeatherPrecipitationEnum& WeatherAreaDataType::getTypeOfPrecipitation() const {
  return getTypeOfPrecipitation_();
}

uci::type::WeatherPrecipitationEnum& WeatherAreaDataType::getTypeOfPrecipitation() {
  return getTypeOfPrecipitation_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setTypeOfPrecipitation(const uci::type::WeatherPrecipitationEnum& accessor) {
  enableTypeOfPrecipitation();
  if (&accessor != typeOfPrecipitation_Accessor.get()) {
    typeOfPrecipitation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setTypeOfPrecipitation(const uci::type::WeatherPrecipitationEnum::EnumerationItem value) {
  enableTypeOfPrecipitation().setValue(value);
  return *this;
}

bool WeatherAreaDataType::hasTypeOfPrecipitation() const noexcept {
  return static_cast<bool>(typeOfPrecipitation_Accessor);
}

uci::type::WeatherPrecipitationEnum& WeatherAreaDataType::enableTypeOfPrecipitation(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherPrecipitationEnum : type};
  if ((!typeOfPrecipitation_Accessor) || (typeOfPrecipitation_Accessor->getAccessorType() != requestedType)) {
    typeOfPrecipitation_Accessor = WeatherPrecipitationEnum::create(requestedType);
    if (!typeOfPrecipitation_Accessor) {
      throw uci::base::UCIException("Error in enableTypeOfPrecipitation(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *typeOfPrecipitation_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearTypeOfPrecipitation() noexcept {
  typeOfPrecipitation_Accessor.reset();
  return *this;
}

uci::type::WeatherPrecipitationAmplificationEnum& WeatherAreaDataType::getPrecipitationAmplification_() const {
  if (precipitationAmplification_Accessor) {
    return *precipitationAmplification_Accessor;
  }
  throw uci::base::UCIException("Error in getPrecipitationAmplification(): An attempt was made to get an optional field that was not enabled, call hasPrecipitationAmplification() to determine if it is safe to call getPrecipitationAmplification()");
}

const uci::type::WeatherPrecipitationAmplificationEnum& WeatherAreaDataType::getPrecipitationAmplification() const {
  return getPrecipitationAmplification_();
}

uci::type::WeatherPrecipitationAmplificationEnum& WeatherAreaDataType::getPrecipitationAmplification() {
  return getPrecipitationAmplification_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setPrecipitationAmplification(const uci::type::WeatherPrecipitationAmplificationEnum& accessor) {
  enablePrecipitationAmplification();
  if (&accessor != precipitationAmplification_Accessor.get()) {
    precipitationAmplification_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setPrecipitationAmplification(const uci::type::WeatherPrecipitationAmplificationEnum::EnumerationItem value) {
  enablePrecipitationAmplification().setValue(value);
  return *this;
}

bool WeatherAreaDataType::hasPrecipitationAmplification() const noexcept {
  return static_cast<bool>(precipitationAmplification_Accessor);
}

uci::type::WeatherPrecipitationAmplificationEnum& WeatherAreaDataType::enablePrecipitationAmplification(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherPrecipitationAmplificationEnum : type};
  if ((!precipitationAmplification_Accessor) || (precipitationAmplification_Accessor->getAccessorType() != requestedType)) {
    precipitationAmplification_Accessor = WeatherPrecipitationAmplificationEnum::create(requestedType);
    if (!precipitationAmplification_Accessor) {
      throw uci::base::UCIException("Error in enablePrecipitationAmplification(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *precipitationAmplification_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearPrecipitationAmplification() noexcept {
  precipitationAmplification_Accessor.reset();
  return *this;
}

uci::type::DistanceTypeValue WeatherAreaDataType::getVisibility() const {
  if (visibility_Accessor) {
    return *visibility_Accessor;
  }
  throw uci::base::UCIException("Error in getVisibility(): An attempt was made to get an optional field that was not enabled, call hasVisibility() to determine if it is safe to call getVisibility()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setVisibility(uci::type::DistanceTypeValue value) {
  visibility_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasVisibility() const noexcept {
  return visibility_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearVisibility() noexcept {
  visibility_Accessor.reset();
  return *this;
}

uci::type::WeatherVisibilityEnum& WeatherAreaDataType::getVisibilityStatus_() const {
  if (visibilityStatus_Accessor) {
    return *visibilityStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getVisibilityStatus(): An attempt was made to get an optional field that was not enabled, call hasVisibilityStatus() to determine if it is safe to call getVisibilityStatus()");
}

const uci::type::WeatherVisibilityEnum& WeatherAreaDataType::getVisibilityStatus() const {
  return getVisibilityStatus_();
}

uci::type::WeatherVisibilityEnum& WeatherAreaDataType::getVisibilityStatus() {
  return getVisibilityStatus_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setVisibilityStatus(const uci::type::WeatherVisibilityEnum& accessor) {
  enableVisibilityStatus();
  if (&accessor != visibilityStatus_Accessor.get()) {
    visibilityStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setVisibilityStatus(const uci::type::WeatherVisibilityEnum::EnumerationItem value) {
  enableVisibilityStatus().setValue(value);
  return *this;
}

bool WeatherAreaDataType::hasVisibilityStatus() const noexcept {
  return static_cast<bool>(visibilityStatus_Accessor);
}

uci::type::WeatherVisibilityEnum& WeatherAreaDataType::enableVisibilityStatus(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherVisibilityEnum : type};
  if ((!visibilityStatus_Accessor) || (visibilityStatus_Accessor->getAccessorType() != requestedType)) {
    visibilityStatus_Accessor = WeatherVisibilityEnum::create(requestedType);
    if (!visibilityStatus_Accessor) {
      throw uci::base::UCIException("Error in enableVisibilityStatus(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *visibilityStatus_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearVisibilityStatus() noexcept {
  visibilityStatus_Accessor.reset();
  return *this;
}

uci::type::TemperatureTypeValue WeatherAreaDataType::getDewPoint() const {
  if (dewPoint_Accessor) {
    return *dewPoint_Accessor;
  }
  throw uci::base::UCIException("Error in getDewPoint(): An attempt was made to get an optional field that was not enabled, call hasDewPoint() to determine if it is safe to call getDewPoint()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setDewPoint(uci::type::TemperatureTypeValue value) {
  dewPoint_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasDewPoint() const noexcept {
  return dewPoint_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearDewPoint() noexcept {
  dewPoint_Accessor.reset();
  return *this;
}

const uci::type::WeatherAreaDataType::Clouds& WeatherAreaDataType::getClouds() const {
  return *clouds_Accessor;
}

uci::type::WeatherAreaDataType::Clouds& WeatherAreaDataType::getClouds() {
  return *clouds_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setClouds(const uci::type::WeatherAreaDataType::Clouds& accessor) {
  if (&accessor != clouds_Accessor.get()) {
    clouds_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherEffectsType& WeatherAreaDataType::getWeatherEffects_() const {
  if (weatherEffects_Accessor) {
    return *weatherEffects_Accessor;
  }
  throw uci::base::UCIException("Error in getWeatherEffects(): An attempt was made to get an optional field that was not enabled, call hasWeatherEffects() to determine if it is safe to call getWeatherEffects()");
}

const uci::type::WeatherEffectsType& WeatherAreaDataType::getWeatherEffects() const {
  return getWeatherEffects_();
}

uci::type::WeatherEffectsType& WeatherAreaDataType::getWeatherEffects() {
  return getWeatherEffects_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setWeatherEffects(const uci::type::WeatherEffectsType& accessor) {
  enableWeatherEffects();
  if (&accessor != weatherEffects_Accessor.get()) {
    weatherEffects_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool WeatherAreaDataType::hasWeatherEffects() const noexcept {
  return static_cast<bool>(weatherEffects_Accessor);
}

uci::type::WeatherEffectsType& WeatherAreaDataType::enableWeatherEffects(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherEffectsType : type};
  if ((!weatherEffects_Accessor) || (weatherEffects_Accessor->getAccessorType() != requestedType)) {
    weatherEffects_Accessor = WeatherEffectsType::create(requestedType);
    if (!weatherEffects_Accessor) {
      throw uci::base::UCIException("Error in enableWeatherEffects(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *weatherEffects_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearWeatherEffects() noexcept {
  weatherEffects_Accessor.reset();
  return *this;
}

xs::Float WeatherAreaDataType::getBarometricPressure() const {
  if (barometricPressure_Accessor) {
    return *barometricPressure_Accessor;
  }
  throw uci::base::UCIException("Error in getBarometricPressure(): An attempt was made to get an optional field that was not enabled, call hasBarometricPressure() to determine if it is safe to call getBarometricPressure()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setBarometricPressure(xs::Float value) {
  barometricPressure_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasBarometricPressure() const noexcept {
  return barometricPressure_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearBarometricPressure() noexcept {
  barometricPressure_Accessor.reset();
  return *this;
}

xs::Float WeatherAreaDataType::getKollsmanSetting() const {
  if (kollsmanSetting_Accessor) {
    return *kollsmanSetting_Accessor;
  }
  throw uci::base::UCIException("Error in getKollsmanSetting(): An attempt was made to get an optional field that was not enabled, call hasKollsmanSetting() to determine if it is safe to call getKollsmanSetting()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setKollsmanSetting(xs::Float value) {
  kollsmanSetting_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasKollsmanSetting() const noexcept {
  return kollsmanSetting_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearKollsmanSetting() noexcept {
  kollsmanSetting_Accessor.reset();
  return *this;
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::getIcing_() const {
  if (icing_Accessor) {
    return *icing_Accessor;
  }
  throw uci::base::UCIException("Error in getIcing(): An attempt was made to get an optional field that was not enabled, call hasIcing() to determine if it is safe to call getIcing()");
}

const uci::type::WeatherSeverityEnum& WeatherAreaDataType::getIcing() const {
  return getIcing_();
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::getIcing() {
  return getIcing_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setIcing(const uci::type::WeatherSeverityEnum& accessor) {
  enableIcing();
  if (&accessor != icing_Accessor.get()) {
    icing_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setIcing(const uci::type::WeatherSeverityEnum::EnumerationItem value) {
  enableIcing().setValue(value);
  return *this;
}

bool WeatherAreaDataType::hasIcing() const noexcept {
  return static_cast<bool>(icing_Accessor);
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::enableIcing(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherSeverityEnum : type};
  if ((!icing_Accessor) || (icing_Accessor->getAccessorType() != requestedType)) {
    icing_Accessor = WeatherSeverityEnum::create(requestedType);
    if (!icing_Accessor) {
      throw uci::base::UCIException("Error in enableIcing(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *icing_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearIcing() noexcept {
  icing_Accessor.reset();
  return *this;
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::getTurbulence_() const {
  if (turbulence_Accessor) {
    return *turbulence_Accessor;
  }
  throw uci::base::UCIException("Error in getTurbulence(): An attempt was made to get an optional field that was not enabled, call hasTurbulence() to determine if it is safe to call getTurbulence()");
}

const uci::type::WeatherSeverityEnum& WeatherAreaDataType::getTurbulence() const {
  return getTurbulence_();
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::getTurbulence() {
  return getTurbulence_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setTurbulence(const uci::type::WeatherSeverityEnum& accessor) {
  enableTurbulence();
  if (&accessor != turbulence_Accessor.get()) {
    turbulence_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setTurbulence(const uci::type::WeatherSeverityEnum::EnumerationItem value) {
  enableTurbulence().setValue(value);
  return *this;
}

bool WeatherAreaDataType::hasTurbulence() const noexcept {
  return static_cast<bool>(turbulence_Accessor);
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::enableTurbulence(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherSeverityEnum : type};
  if ((!turbulence_Accessor) || (turbulence_Accessor->getAccessorType() != requestedType)) {
    turbulence_Accessor = WeatherSeverityEnum::create(requestedType);
    if (!turbulence_Accessor) {
      throw uci::base::UCIException("Error in enableTurbulence(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *turbulence_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearTurbulence() noexcept {
  turbulence_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue WeatherAreaDataType::getThunderstormPotential() const {
  if (thunderstormPotential_Accessor) {
    return *thunderstormPotential_Accessor;
  }
  throw uci::base::UCIException("Error in getThunderstormPotential(): An attempt was made to get an optional field that was not enabled, call hasThunderstormPotential() to determine if it is safe to call getThunderstormPotential()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setThunderstormPotential(uci::type::PercentTypeValue value) {
  thunderstormPotential_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasThunderstormPotential() const noexcept {
  return thunderstormPotential_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearThunderstormPotential() noexcept {
  thunderstormPotential_Accessor.reset();
  return *this;
}

uci::type::VisibleString1024Type& WeatherAreaDataType::getRemarks_() const {
  if (remarks_Accessor) {
    return *remarks_Accessor;
  }
  throw uci::base::UCIException("Error in getRemarks(): An attempt was made to get an optional field that was not enabled, call hasRemarks() to determine if it is safe to call getRemarks()");
}

const uci::type::VisibleString1024Type& WeatherAreaDataType::getRemarks() const {
  return getRemarks_();
}

uci::type::VisibleString1024Type& WeatherAreaDataType::getRemarks() {
  return getRemarks_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setRemarks(const uci::type::VisibleString1024Type& value) {
  return setRemarks(value.c_str());
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setRemarks(const std::string& value) {
  return setRemarks(value.c_str());
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setRemarks(const char* value) {
  enableRemarks().setStringValue(value);
  return *this;
}

bool WeatherAreaDataType::hasRemarks() const noexcept {
  return static_cast<bool>(remarks_Accessor);
}

uci::type::VisibleString1024Type& WeatherAreaDataType::enableRemarks(uci::base::accessorType::AccessorType type) {
  if (!remarks_Accessor) {
    remarks_Accessor = VisibleString1024Type::create(type);
  }
  return *remarks_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearRemarks() noexcept {
  remarks_Accessor.reset();
  return *this;
}

uci::type::WeatherKindEnum& WeatherAreaDataType::getKind_() const {
  if (kind_Accessor) {
    return *kind_Accessor;
  }
  throw uci::base::UCIException("Error in getKind(): An attempt was made to get an optional field that was not enabled, call hasKind() to determine if it is safe to call getKind()");
}

const uci::type::WeatherKindEnum& WeatherAreaDataType::getKind() const {
  return getKind_();
}

uci::type::WeatherKindEnum& WeatherAreaDataType::getKind() {
  return getKind_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setKind(const uci::type::WeatherKindEnum& accessor) {
  enableKind();
  if (&accessor != kind_Accessor.get()) {
    kind_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setKind(const uci::type::WeatherKindEnum::EnumerationItem value) {
  enableKind().setValue(value);
  return *this;
}

bool WeatherAreaDataType::hasKind() const noexcept {
  return static_cast<bool>(kind_Accessor);
}

uci::type::WeatherKindEnum& WeatherAreaDataType::enableKind(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherKindEnum : type};
  if ((!kind_Accessor) || (kind_Accessor->getAccessorType() != requestedType)) {
    kind_Accessor = WeatherKindEnum::create(requestedType);
    if (!kind_Accessor) {
      throw uci::base::UCIException("Error in enableKind(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *kind_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearKind() noexcept {
  kind_Accessor.reset();
  return *this;
}

uci::type::WeatherDescriptionEnum& WeatherAreaDataType::getDescription_() const {
  if (description_Accessor) {
    return *description_Accessor;
  }
  throw uci::base::UCIException("Error in getDescription(): An attempt was made to get an optional field that was not enabled, call hasDescription() to determine if it is safe to call getDescription()");
}

const uci::type::WeatherDescriptionEnum& WeatherAreaDataType::getDescription() const {
  return getDescription_();
}

uci::type::WeatherDescriptionEnum& WeatherAreaDataType::getDescription() {
  return getDescription_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setDescription(const uci::type::WeatherDescriptionEnum& accessor) {
  enableDescription();
  if (&accessor != description_Accessor.get()) {
    description_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setDescription(const uci::type::WeatherDescriptionEnum::EnumerationItem value) {
  enableDescription().setValue(value);
  return *this;
}

bool WeatherAreaDataType::hasDescription() const noexcept {
  return static_cast<bool>(description_Accessor);
}

uci::type::WeatherDescriptionEnum& WeatherAreaDataType::enableDescription(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherDescriptionEnum : type};
  if ((!description_Accessor) || (description_Accessor->getAccessorType() != requestedType)) {
    description_Accessor = WeatherDescriptionEnum::create(requestedType);
    if (!description_Accessor) {
      throw uci::base::UCIException("Error in enableDescription(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *description_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearDescription() noexcept {
  description_Accessor.reset();
  return *this;
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::getQualifier_() const {
  if (qualifier_Accessor) {
    return *qualifier_Accessor;
  }
  throw uci::base::UCIException("Error in getQualifier(): An attempt was made to get an optional field that was not enabled, call hasQualifier() to determine if it is safe to call getQualifier()");
}

const uci::type::WeatherSeverityEnum& WeatherAreaDataType::getQualifier() const {
  return getQualifier_();
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::getQualifier() {
  return getQualifier_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setQualifier(const uci::type::WeatherSeverityEnum& accessor) {
  enableQualifier();
  if (&accessor != qualifier_Accessor.get()) {
    qualifier_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setQualifier(const uci::type::WeatherSeverityEnum::EnumerationItem value) {
  enableQualifier().setValue(value);
  return *this;
}

bool WeatherAreaDataType::hasQualifier() const noexcept {
  return static_cast<bool>(qualifier_Accessor);
}

uci::type::WeatherSeverityEnum& WeatherAreaDataType::enableQualifier(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherSeverityEnum : type};
  if ((!qualifier_Accessor) || (qualifier_Accessor->getAccessorType() != requestedType)) {
    qualifier_Accessor = WeatherSeverityEnum::create(requestedType);
    if (!qualifier_Accessor) {
      throw uci::base::UCIException("Error in enableQualifier(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *qualifier_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearQualifier() noexcept {
  qualifier_Accessor.reset();
  return *this;
}

uci::type::WindDataType& WeatherAreaDataType::getWindData_() const {
  if (windData_Accessor) {
    return *windData_Accessor;
  }
  throw uci::base::UCIException("Error in getWindData(): An attempt was made to get an optional field that was not enabled, call hasWindData() to determine if it is safe to call getWindData()");
}

const uci::type::WindDataType& WeatherAreaDataType::getWindData() const {
  return getWindData_();
}

uci::type::WindDataType& WeatherAreaDataType::getWindData() {
  return getWindData_();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setWindData(const uci::type::WindDataType& accessor) {
  enableWindData();
  if (&accessor != windData_Accessor.get()) {
    windData_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool WeatherAreaDataType::hasWindData() const noexcept {
  return static_cast<bool>(windData_Accessor);
}

uci::type::WindDataType& WeatherAreaDataType::enableWindData(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::windDataType : type};
  if ((!windData_Accessor) || (windData_Accessor->getAccessorType() != requestedType)) {
    windData_Accessor = WindDataType::create(requestedType);
    if (!windData_Accessor) {
      throw uci::base::UCIException("Error in enableWindData(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *windData_Accessor;
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearWindData() noexcept {
  windData_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue WeatherAreaDataType::getRelativeHumidity() const {
  if (relativeHumidity_Accessor) {
    return *relativeHumidity_Accessor;
  }
  throw uci::base::UCIException("Error in getRelativeHumidity(): An attempt was made to get an optional field that was not enabled, call hasRelativeHumidity() to determine if it is safe to call getRelativeHumidity()");
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::setRelativeHumidity(uci::type::PercentTypeValue value) {
  relativeHumidity_Accessor = value;
  return *this;
}

bool WeatherAreaDataType::hasRelativeHumidity() const noexcept {
  return relativeHumidity_Accessor.has_value();
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::clearRelativeHumidity() noexcept {
  relativeHumidity_Accessor.reset();
  return *this;
}

std::unique_ptr<WeatherAreaDataType> WeatherAreaDataType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::weatherAreaDataType : type};
  return (requestedType == uci::type::accessorType::weatherAreaDataType) ? boost::make_unique<WeatherAreaDataType>() : nullptr;
}

/**  */
namespace WeatherAreaDataType_Names {

constexpr const char* Extern_Type_Name{"WeatherAreaDataType"};
constexpr const char* Source_Name{"Source"};
constexpr const char* StationCode_Name{"StationCode"};
constexpr const char* Temperature_Name{"Temperature"};
constexpr const char* PrecipitationPotential_Name{"PrecipitationPotential"};
constexpr const char* PrecipitationAmount_Name{"PrecipitationAmount"};
constexpr const char* TypeOfPrecipitation_Name{"TypeOfPrecipitation"};
constexpr const char* PrecipitationAmplification_Name{"PrecipitationAmplification"};
constexpr const char* Visibility_Name{"Visibility"};
constexpr const char* VisibilityStatus_Name{"VisibilityStatus"};
constexpr const char* DewPoint_Name{"DewPoint"};
constexpr const char* Clouds_Name{"Clouds"};
constexpr const char* WeatherEffects_Name{"WeatherEffects"};
constexpr const char* BarometricPressure_Name{"BarometricPressure"};
constexpr const char* KollsmanSetting_Name{"KollsmanSetting"};
constexpr const char* Icing_Name{"Icing"};
constexpr const char* Turbulence_Name{"Turbulence"};
constexpr const char* ThunderstormPotential_Name{"ThunderstormPotential"};
constexpr const char* Remarks_Name{"Remarks"};
constexpr const char* Kind_Name{"Kind"};
constexpr const char* Description_Name{"Description"};
constexpr const char* Qualifier_Name{"Qualifier"};
constexpr const char* WindData_Name{"WindData"};
constexpr const char* RelativeHumidity_Name{"RelativeHumidity"};

} // namespace WeatherAreaDataType_Names

void WeatherAreaDataType::deserialize(const boost::property_tree::ptree& propTree, uci::type::WeatherAreaDataType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = WeatherAreaDataType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Source_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.getSource().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::StationCode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setStationCode(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Temperature_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setTemperature(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::PrecipitationPotential_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPrecipitationPotential(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::PrecipitationAmount_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setPrecipitationAmount(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::TypeOfPrecipitation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableTypeOfPrecipitation().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::PrecipitationAmplification_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enablePrecipitationAmplification().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Visibility_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setVisibility(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::VisibilityStatus_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableVisibilityStatus().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::DewPoint_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setDewPoint(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Clouds_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::WeatherAreaDataType::Clouds& boundedList = accessor.getClouds();
        const uci::type::WeatherAreaDataType::Clouds::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::CloudsType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::WeatherEffects_Name) {
      WeatherEffectsType::deserialize(valueType.second, accessor.enableWeatherEffects(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::BarometricPressure_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setBarometricPressure(asb_uci::util::SerializationHelpers::deserializeFloat(*value));
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::KollsmanSetting_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setKollsmanSetting(asb_uci::util::SerializationHelpers::deserializeFloat(*value));
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Icing_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableIcing().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Turbulence_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableTurbulence().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::ThunderstormPotential_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setThunderstormPotential(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Remarks_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setRemarks(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Kind_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableKind().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Description_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableDescription().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::Qualifier_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableQualifier().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::WindData_Name) {
      WindDataType::deserialize(valueType.second, accessor.enableWindData(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + WeatherAreaDataType_Names::RelativeHumidity_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setRelativeHumidity(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    }
  }
}

std::string WeatherAreaDataType::serialize(const uci::type::WeatherAreaDataType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? WeatherAreaDataType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, WeatherAreaDataType_Names::Extern_Type_Name);
  }
  WeatherSourceEnum::serialize(accessor.getSource(), node, WeatherAreaDataType_Names::Source_Name, false);
  if (accessor.hasStationCode()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getStationCode(), node, WeatherAreaDataType_Names::StationCode_Name);
  }
  if (accessor.hasTemperature()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getTemperature(), node, WeatherAreaDataType_Names::Temperature_Name);
  }
  if (accessor.hasPrecipitationPotential()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getPrecipitationPotential(), node, WeatherAreaDataType_Names::PrecipitationPotential_Name);
  }
  if (accessor.hasPrecipitationAmount()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getPrecipitationAmount(), node, WeatherAreaDataType_Names::PrecipitationAmount_Name);
  }
  if (accessor.hasTypeOfPrecipitation()) {
    WeatherPrecipitationEnum::serialize(accessor.getTypeOfPrecipitation(), node, WeatherAreaDataType_Names::TypeOfPrecipitation_Name, false);
  }
  if (accessor.hasPrecipitationAmplification()) {
    WeatherPrecipitationAmplificationEnum::serialize(accessor.getPrecipitationAmplification(), node, WeatherAreaDataType_Names::PrecipitationAmplification_Name, false);
  }
  if (accessor.hasVisibility()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getVisibility(), node, WeatherAreaDataType_Names::Visibility_Name);
  }
  if (accessor.hasVisibilityStatus()) {
    WeatherVisibilityEnum::serialize(accessor.getVisibilityStatus(), node, WeatherAreaDataType_Names::VisibilityStatus_Name, false);
  }
  if (accessor.hasDewPoint()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getDewPoint(), node, WeatherAreaDataType_Names::DewPoint_Name);
  }
  {
    const uci::type::WeatherAreaDataType::Clouds& boundedList = accessor.getClouds();
    for (uci::type::WeatherAreaDataType::Clouds::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::CloudsType::serialize(boundedList.at(i), node, WeatherAreaDataType_Names::Clouds_Name);
    }
  }
  if (accessor.hasWeatherEffects()) {
    WeatherEffectsType::serialize(accessor.getWeatherEffects(), node, WeatherAreaDataType_Names::WeatherEffects_Name);
  }
  if (accessor.hasBarometricPressure()) {
    asb_uci::util::SerializationHelpers::serializeFloat(accessor.getBarometricPressure(), node, WeatherAreaDataType_Names::BarometricPressure_Name);
  }
  if (accessor.hasKollsmanSetting()) {
    asb_uci::util::SerializationHelpers::serializeFloat(accessor.getKollsmanSetting(), node, WeatherAreaDataType_Names::KollsmanSetting_Name);
  }
  if (accessor.hasIcing()) {
    WeatherSeverityEnum::serialize(accessor.getIcing(), node, WeatherAreaDataType_Names::Icing_Name, false);
  }
  if (accessor.hasTurbulence()) {
    WeatherSeverityEnum::serialize(accessor.getTurbulence(), node, WeatherAreaDataType_Names::Turbulence_Name, false);
  }
  if (accessor.hasThunderstormPotential()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getThunderstormPotential(), node, WeatherAreaDataType_Names::ThunderstormPotential_Name);
  }
  if (accessor.hasRemarks()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getRemarks(), node, WeatherAreaDataType_Names::Remarks_Name);
  }
  if (accessor.hasKind()) {
    WeatherKindEnum::serialize(accessor.getKind(), node, WeatherAreaDataType_Names::Kind_Name, false);
  }
  if (accessor.hasDescription()) {
    WeatherDescriptionEnum::serialize(accessor.getDescription(), node, WeatherAreaDataType_Names::Description_Name, false);
  }
  if (accessor.hasQualifier()) {
    WeatherSeverityEnum::serialize(accessor.getQualifier(), node, WeatherAreaDataType_Names::Qualifier_Name, false);
  }
  if (accessor.hasWindData()) {
    WindDataType::serialize(accessor.getWindData(), node, WeatherAreaDataType_Names::WindData_Name);
  }
  if (accessor.hasRelativeHumidity()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getRelativeHumidity(), node, WeatherAreaDataType_Names::RelativeHumidity_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::WeatherAreaDataType& WeatherAreaDataType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::WeatherAreaDataType>().release());
}

uci::type::WeatherAreaDataType& WeatherAreaDataType::create(const uci::type::WeatherAreaDataType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::WeatherAreaDataType> newAccessor{boost::make_unique<asb_uci::type::WeatherAreaDataType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void WeatherAreaDataType::destroy(uci::type::WeatherAreaDataType& accessor) {
  delete dynamic_cast<asb_uci::type::WeatherAreaDataType*>(&accessor);
}

} // namespace type

} // namespace uci

