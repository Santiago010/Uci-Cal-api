/** @file PO_TrackDetailsType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:14 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/PO_TrackDetailsType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/IdentityBasicType.h"
#include "asb_uci/type/IncreaseDecreaseEnum.h"
#include "asb_uci/type/LOS_VariableB_Type.h"
#include "asb_uci/type/PO_AirTargetVolumeType.h"
#include "asb_uci/type/PO_CoastSettingValueType.h"
#include "asb_uci/type/PO_LockPersistenceEnum.h"
#include "asb_uci/type/PO_TrackCommandEnum.h"
#include "asb_uci/type/TrackOptionsID_Type.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/DistanceType.h"
#include "uci/type/DurationType.h"
#include "uci/type/IdentityBasicType.h"
#include "uci/type/IncreaseDecreaseEnum.h"
#include "uci/type/LOS_VariableB_Type.h"
#include "uci/type/PO_AirTargetVolumeType.h"
#include "uci/type/PO_CoastSettingValueType.h"
#include "uci/type/PO_LockPersistenceEnum.h"
#include "uci/type/PO_TrackCommandEnum.h"
#include "uci/type/PO_TrackDetailsType.h"
#include "uci/type/TrackOptionsID_Type.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

PO_TrackDetailsType::PO_TrackDetailsType()
  : trackOptionID_Accessor{boost::make_unique<TrackOptionsID_Type>()},
    coastSetting_Accessor{boost::make_unique<CoastSetting>(0, 6)} {
}

PO_TrackDetailsType::~PO_TrackDetailsType() = default;

void PO_TrackDetailsType::copy(const uci::type::PO_TrackDetailsType& accessor) {
  copyImpl(accessor, false);
}

void PO_TrackDetailsType::copyImpl(const uci::type::PO_TrackDetailsType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const PO_TrackDetailsType&>(accessor);
    setTrackOptionID(*(accessorImpl.trackOptionID_Accessor));
    if (accessorImpl.mode_Accessor) {
      setMode(*(accessorImpl.mode_Accessor));
    } else {
      mode_Accessor.reset();
    }
    if (accessorImpl.trackArea_Accessor) {
      setTrackArea(*(accessorImpl.trackArea_Accessor));
    } else {
      trackArea_Accessor.reset();
    }
    if (accessorImpl.lockPersistence_Accessor) {
      setLockPersistence(*(accessorImpl.lockPersistence_Accessor));
    } else {
      lockPersistence_Accessor.reset();
    }
    if (accessorImpl.aTR_Filter_Accessor) {
      setATR_Filter(*(accessorImpl.aTR_Filter_Accessor));
    } else {
      aTR_Filter_Accessor.reset();
    }
    if (accessorImpl.offsetTrackSetting_Accessor) {
      setOffsetTrackSetting(*(accessorImpl.offsetTrackSetting_Accessor));
    } else {
      offsetTrackSetting_Accessor.reset();
    }
    if (accessorImpl.hasObservedEntityThreshold()) {
      setObservedEntityThreshold(accessorImpl.getObservedEntityThreshold());
    } else {
      clearObservedEntityThreshold();
    }
    if (accessorImpl.hasTrackingRange()) {
      setTrackingRange(accessorImpl.getTrackingRange());
    } else {
      clearTrackingRange();
    }
    setCoastSetting(*(accessorImpl.coastSetting_Accessor));
    if (accessorImpl.blankingVolume_Accessor) {
      setBlankingVolume(*(accessorImpl.blankingVolume_Accessor));
    } else {
      blankingVolume_Accessor.reset();
    }
  }
}

void PO_TrackDetailsType::reset() noexcept {
  trackOptionID_Accessor->reset();
  mode_Accessor.reset();
  trackArea_Accessor.reset();
  lockPersistence_Accessor.reset();
  aTR_Filter_Accessor.reset();
  offsetTrackSetting_Accessor.reset();
  clearObservedEntityThreshold();
  clearTrackingRange();
  coastSetting_Accessor->reset();
  blankingVolume_Accessor.reset();
}

const uci::type::TrackOptionsID_Type& PO_TrackDetailsType::getTrackOptionID() const {
  return *trackOptionID_Accessor;
}

uci::type::TrackOptionsID_Type& PO_TrackDetailsType::getTrackOptionID() {
  return *trackOptionID_Accessor;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setTrackOptionID(const uci::type::TrackOptionsID_Type& accessor) {
  if (&accessor != trackOptionID_Accessor.get()) {
    trackOptionID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::PO_TrackCommandEnum& PO_TrackDetailsType::getMode_() const {
  if (mode_Accessor) {
    return *mode_Accessor;
  }
  throw uci::base::UCIException("Error in getMode(): An attempt was made to get an optional field that was not enabled, call hasMode() to determine if it is safe to call getMode()");
}

const uci::type::PO_TrackCommandEnum& PO_TrackDetailsType::getMode() const {
  return getMode_();
}

uci::type::PO_TrackCommandEnum& PO_TrackDetailsType::getMode() {
  return getMode_();
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setMode(const uci::type::PO_TrackCommandEnum& accessor) {
  enableMode();
  if (&accessor != mode_Accessor.get()) {
    mode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setMode(const uci::type::PO_TrackCommandEnum::EnumerationItem value) {
  enableMode().setValue(value);
  return *this;
}

bool PO_TrackDetailsType::hasMode() const noexcept {
  return static_cast<bool>(mode_Accessor);
}

uci::type::PO_TrackCommandEnum& PO_TrackDetailsType::enableMode(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::pO_TrackCommandEnum : type};
  if ((!mode_Accessor) || (mode_Accessor->getAccessorType() != requestedType)) {
    mode_Accessor = PO_TrackCommandEnum::create(requestedType);
    if (!mode_Accessor) {
      throw uci::base::UCIException("Error in enableMode(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *mode_Accessor;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::clearMode() noexcept {
  mode_Accessor.reset();
  return *this;
}

uci::type::IncreaseDecreaseEnum& PO_TrackDetailsType::getTrackArea_() const {
  if (trackArea_Accessor) {
    return *trackArea_Accessor;
  }
  throw uci::base::UCIException("Error in getTrackArea(): An attempt was made to get an optional field that was not enabled, call hasTrackArea() to determine if it is safe to call getTrackArea()");
}

const uci::type::IncreaseDecreaseEnum& PO_TrackDetailsType::getTrackArea() const {
  return getTrackArea_();
}

uci::type::IncreaseDecreaseEnum& PO_TrackDetailsType::getTrackArea() {
  return getTrackArea_();
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setTrackArea(const uci::type::IncreaseDecreaseEnum& accessor) {
  enableTrackArea();
  if (&accessor != trackArea_Accessor.get()) {
    trackArea_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setTrackArea(const uci::type::IncreaseDecreaseEnum::EnumerationItem value) {
  enableTrackArea().setValue(value);
  return *this;
}

bool PO_TrackDetailsType::hasTrackArea() const noexcept {
  return static_cast<bool>(trackArea_Accessor);
}

uci::type::IncreaseDecreaseEnum& PO_TrackDetailsType::enableTrackArea(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::increaseDecreaseEnum : type};
  if ((!trackArea_Accessor) || (trackArea_Accessor->getAccessorType() != requestedType)) {
    trackArea_Accessor = IncreaseDecreaseEnum::create(requestedType);
    if (!trackArea_Accessor) {
      throw uci::base::UCIException("Error in enableTrackArea(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *trackArea_Accessor;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::clearTrackArea() noexcept {
  trackArea_Accessor.reset();
  return *this;
}

uci::type::PO_LockPersistenceEnum& PO_TrackDetailsType::getLockPersistence_() const {
  if (lockPersistence_Accessor) {
    return *lockPersistence_Accessor;
  }
  throw uci::base::UCIException("Error in getLockPersistence(): An attempt was made to get an optional field that was not enabled, call hasLockPersistence() to determine if it is safe to call getLockPersistence()");
}

const uci::type::PO_LockPersistenceEnum& PO_TrackDetailsType::getLockPersistence() const {
  return getLockPersistence_();
}

uci::type::PO_LockPersistenceEnum& PO_TrackDetailsType::getLockPersistence() {
  return getLockPersistence_();
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setLockPersistence(const uci::type::PO_LockPersistenceEnum& accessor) {
  enableLockPersistence();
  if (&accessor != lockPersistence_Accessor.get()) {
    lockPersistence_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setLockPersistence(const uci::type::PO_LockPersistenceEnum::EnumerationItem value) {
  enableLockPersistence().setValue(value);
  return *this;
}

bool PO_TrackDetailsType::hasLockPersistence() const noexcept {
  return static_cast<bool>(lockPersistence_Accessor);
}

uci::type::PO_LockPersistenceEnum& PO_TrackDetailsType::enableLockPersistence(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::pO_LockPersistenceEnum : type};
  if ((!lockPersistence_Accessor) || (lockPersistence_Accessor->getAccessorType() != requestedType)) {
    lockPersistence_Accessor = PO_LockPersistenceEnum::create(requestedType);
    if (!lockPersistence_Accessor) {
      throw uci::base::UCIException("Error in enableLockPersistence(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *lockPersistence_Accessor;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::clearLockPersistence() noexcept {
  lockPersistence_Accessor.reset();
  return *this;
}

uci::type::IdentityBasicType& PO_TrackDetailsType::getATR_Filter_() const {
  if (aTR_Filter_Accessor) {
    return *aTR_Filter_Accessor;
  }
  throw uci::base::UCIException("Error in getATR_Filter(): An attempt was made to get an optional field that was not enabled, call hasATR_Filter() to determine if it is safe to call getATR_Filter()");
}

const uci::type::IdentityBasicType& PO_TrackDetailsType::getATR_Filter() const {
  return getATR_Filter_();
}

uci::type::IdentityBasicType& PO_TrackDetailsType::getATR_Filter() {
  return getATR_Filter_();
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setATR_Filter(const uci::type::IdentityBasicType& accessor) {
  enableATR_Filter();
  if (&accessor != aTR_Filter_Accessor.get()) {
    aTR_Filter_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PO_TrackDetailsType::hasATR_Filter() const noexcept {
  return static_cast<bool>(aTR_Filter_Accessor);
}

uci::type::IdentityBasicType& PO_TrackDetailsType::enableATR_Filter(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::identityBasicType : type};
  if ((!aTR_Filter_Accessor) || (aTR_Filter_Accessor->getAccessorType() != requestedType)) {
    aTR_Filter_Accessor = IdentityBasicType::create(requestedType);
    if (!aTR_Filter_Accessor) {
      throw uci::base::UCIException("Error in enableATR_Filter(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *aTR_Filter_Accessor;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::clearATR_Filter() noexcept {
  aTR_Filter_Accessor.reset();
  return *this;
}

uci::type::LOS_VariableB_Type& PO_TrackDetailsType::getOffsetTrackSetting_() const {
  if (offsetTrackSetting_Accessor) {
    return *offsetTrackSetting_Accessor;
  }
  throw uci::base::UCIException("Error in getOffsetTrackSetting(): An attempt was made to get an optional field that was not enabled, call hasOffsetTrackSetting() to determine if it is safe to call getOffsetTrackSetting()");
}

const uci::type::LOS_VariableB_Type& PO_TrackDetailsType::getOffsetTrackSetting() const {
  return getOffsetTrackSetting_();
}

uci::type::LOS_VariableB_Type& PO_TrackDetailsType::getOffsetTrackSetting() {
  return getOffsetTrackSetting_();
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setOffsetTrackSetting(const uci::type::LOS_VariableB_Type& accessor) {
  enableOffsetTrackSetting();
  if (&accessor != offsetTrackSetting_Accessor.get()) {
    offsetTrackSetting_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PO_TrackDetailsType::hasOffsetTrackSetting() const noexcept {
  return static_cast<bool>(offsetTrackSetting_Accessor);
}

uci::type::LOS_VariableB_Type& PO_TrackDetailsType::enableOffsetTrackSetting(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::lOS_VariableB_Type : type};
  if ((!offsetTrackSetting_Accessor) || (offsetTrackSetting_Accessor->getAccessorType() != requestedType)) {
    offsetTrackSetting_Accessor = LOS_VariableB_Type::create(requestedType);
    if (!offsetTrackSetting_Accessor) {
      throw uci::base::UCIException("Error in enableOffsetTrackSetting(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *offsetTrackSetting_Accessor;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::clearOffsetTrackSetting() noexcept {
  offsetTrackSetting_Accessor.reset();
  return *this;
}

uci::type::DurationTypeValue PO_TrackDetailsType::getObservedEntityThreshold() const {
  if (observedEntityThreshold_Accessor) {
    return *observedEntityThreshold_Accessor;
  }
  throw uci::base::UCIException("Error in getObservedEntityThreshold(): An attempt was made to get an optional field that was not enabled, call hasObservedEntityThreshold() to determine if it is safe to call getObservedEntityThreshold()");
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setObservedEntityThreshold(uci::type::DurationTypeValue value) {
  observedEntityThreshold_Accessor = value;
  return *this;
}

bool PO_TrackDetailsType::hasObservedEntityThreshold() const noexcept {
  return observedEntityThreshold_Accessor.has_value();
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::clearObservedEntityThreshold() noexcept {
  observedEntityThreshold_Accessor.reset();
  return *this;
}

uci::type::DistanceTypeValue PO_TrackDetailsType::getTrackingRange() const {
  if (trackingRange_Accessor) {
    return *trackingRange_Accessor;
  }
  throw uci::base::UCIException("Error in getTrackingRange(): An attempt was made to get an optional field that was not enabled, call hasTrackingRange() to determine if it is safe to call getTrackingRange()");
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setTrackingRange(uci::type::DistanceTypeValue value) {
  trackingRange_Accessor = value;
  return *this;
}

bool PO_TrackDetailsType::hasTrackingRange() const noexcept {
  return trackingRange_Accessor.has_value();
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::clearTrackingRange() noexcept {
  trackingRange_Accessor.reset();
  return *this;
}

const uci::type::PO_TrackDetailsType::CoastSetting& PO_TrackDetailsType::getCoastSetting() const {
  return *coastSetting_Accessor;
}

uci::type::PO_TrackDetailsType::CoastSetting& PO_TrackDetailsType::getCoastSetting() {
  return *coastSetting_Accessor;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setCoastSetting(const uci::type::PO_TrackDetailsType::CoastSetting& accessor) {
  if (&accessor != coastSetting_Accessor.get()) {
    coastSetting_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::PO_AirTargetVolumeType& PO_TrackDetailsType::getBlankingVolume_() const {
  if (blankingVolume_Accessor) {
    return *blankingVolume_Accessor;
  }
  throw uci::base::UCIException("Error in getBlankingVolume(): An attempt was made to get an optional field that was not enabled, call hasBlankingVolume() to determine if it is safe to call getBlankingVolume()");
}

const uci::type::PO_AirTargetVolumeType& PO_TrackDetailsType::getBlankingVolume() const {
  return getBlankingVolume_();
}

uci::type::PO_AirTargetVolumeType& PO_TrackDetailsType::getBlankingVolume() {
  return getBlankingVolume_();
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::setBlankingVolume(const uci::type::PO_AirTargetVolumeType& accessor) {
  enableBlankingVolume();
  if (&accessor != blankingVolume_Accessor.get()) {
    blankingVolume_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool PO_TrackDetailsType::hasBlankingVolume() const noexcept {
  return static_cast<bool>(blankingVolume_Accessor);
}

uci::type::PO_AirTargetVolumeType& PO_TrackDetailsType::enableBlankingVolume(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::pO_AirTargetVolumeType : type};
  if ((!blankingVolume_Accessor) || (blankingVolume_Accessor->getAccessorType() != requestedType)) {
    blankingVolume_Accessor = PO_AirTargetVolumeType::create(requestedType);
    if (!blankingVolume_Accessor) {
      throw uci::base::UCIException("Error in enableBlankingVolume(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *blankingVolume_Accessor;
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::clearBlankingVolume() noexcept {
  blankingVolume_Accessor.reset();
  return *this;
}

std::unique_ptr<PO_TrackDetailsType> PO_TrackDetailsType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::pO_TrackDetailsType : type};
  return (requestedType == uci::type::accessorType::pO_TrackDetailsType) ? boost::make_unique<PO_TrackDetailsType>() : nullptr;
}

/**  */
namespace PO_TrackDetailsType_Names {

constexpr const char* Extern_Type_Name{"PO_TrackDetailsType"};
constexpr const char* TrackOptionID_Name{"TrackOptionID"};
constexpr const char* Mode_Name{"Mode"};
constexpr const char* TrackArea_Name{"TrackArea"};
constexpr const char* LockPersistence_Name{"LockPersistence"};
constexpr const char* ATR_Filter_Name{"ATR_Filter"};
constexpr const char* OffsetTrackSetting_Name{"OffsetTrackSetting"};
constexpr const char* ObservedEntityThreshold_Name{"ObservedEntityThreshold"};
constexpr const char* TrackingRange_Name{"TrackingRange"};
constexpr const char* CoastSetting_Name{"CoastSetting"};
constexpr const char* BlankingVolume_Name{"BlankingVolume"};

} // namespace PO_TrackDetailsType_Names

void PO_TrackDetailsType::deserialize(const boost::property_tree::ptree& propTree, uci::type::PO_TrackDetailsType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = PO_TrackDetailsType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::TrackOptionID_Name) {
      TrackOptionsID_Type::deserialize(valueType.second, accessor.getTrackOptionID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::Mode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableMode().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::TrackArea_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableTrackArea().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::LockPersistence_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableLockPersistence().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::ATR_Filter_Name) {
      IdentityBasicType::deserialize(valueType.second, accessor.enableATR_Filter(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::OffsetTrackSetting_Name) {
      LOS_VariableB_Type::deserialize(valueType.second, accessor.enableOffsetTrackSetting(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::ObservedEntityThreshold_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setObservedEntityThreshold(asb_uci::util::SerializationHelpers::deserializeDuration(*value));
      }
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::TrackingRange_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setTrackingRange(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::CoastSetting_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::PO_TrackDetailsType::CoastSetting& boundedList = accessor.getCoastSetting();
        const uci::type::PO_TrackDetailsType::CoastSetting::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::PO_CoastSettingValueType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + PO_TrackDetailsType_Names::BlankingVolume_Name) {
      PO_AirTargetVolumeType::deserialize(valueType.second, accessor.enableBlankingVolume(), nodeName, nsPrefix);
    }
  }
}

std::string PO_TrackDetailsType::serialize(const uci::type::PO_TrackDetailsType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? PO_TrackDetailsType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, PO_TrackDetailsType_Names::Extern_Type_Name);
  }
  TrackOptionsID_Type::serialize(accessor.getTrackOptionID(), node, PO_TrackDetailsType_Names::TrackOptionID_Name);
  if (accessor.hasMode()) {
    PO_TrackCommandEnum::serialize(accessor.getMode(), node, PO_TrackDetailsType_Names::Mode_Name, false);
  }
  if (accessor.hasTrackArea()) {
    IncreaseDecreaseEnum::serialize(accessor.getTrackArea(), node, PO_TrackDetailsType_Names::TrackArea_Name, false);
  }
  if (accessor.hasLockPersistence()) {
    PO_LockPersistenceEnum::serialize(accessor.getLockPersistence(), node, PO_TrackDetailsType_Names::LockPersistence_Name, false);
  }
  if (accessor.hasATR_Filter()) {
    IdentityBasicType::serialize(accessor.getATR_Filter(), node, PO_TrackDetailsType_Names::ATR_Filter_Name);
  }
  if (accessor.hasOffsetTrackSetting()) {
    LOS_VariableB_Type::serialize(accessor.getOffsetTrackSetting(), node, PO_TrackDetailsType_Names::OffsetTrackSetting_Name);
  }
  if (accessor.hasObservedEntityThreshold()) {
    asb_uci::util::SerializationHelpers::serializeDuration(accessor.getObservedEntityThreshold(), node, PO_TrackDetailsType_Names::ObservedEntityThreshold_Name);
  }
  if (accessor.hasTrackingRange()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getTrackingRange(), node, PO_TrackDetailsType_Names::TrackingRange_Name);
  }
  {
    const uci::type::PO_TrackDetailsType::CoastSetting& boundedList = accessor.getCoastSetting();
    for (uci::type::PO_TrackDetailsType::CoastSetting::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::PO_CoastSettingValueType::serialize(boundedList.at(i), node, PO_TrackDetailsType_Names::CoastSetting_Name);
    }
  }
  if (accessor.hasBlankingVolume()) {
    PO_AirTargetVolumeType::serialize(accessor.getBlankingVolume(), node, PO_TrackDetailsType_Names::BlankingVolume_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::PO_TrackDetailsType>().release());
}

uci::type::PO_TrackDetailsType& PO_TrackDetailsType::create(const uci::type::PO_TrackDetailsType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::PO_TrackDetailsType> newAccessor{boost::make_unique<asb_uci::type::PO_TrackDetailsType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void PO_TrackDetailsType::destroy(uci::type::PO_TrackDetailsType& accessor) {
  delete dynamic_cast<asb_uci::type::PO_TrackDetailsType*>(&accessor);
}

} // namespace type

} // namespace uci

