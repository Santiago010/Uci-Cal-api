/** @file EntityManagementRequestType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:12 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/EntityManagementRequestType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/EntityManagementClearIdentityType.h"
#include "asb_uci/type/EntityManagementDownType.h"
#include "asb_uci/type/EntityManagementDropRestrictType.h"
#include "asb_uci/type/EntityManagementDropType.h"
#include "asb_uci/type/EntityManagementKinematicsType.h"
#include "asb_uci/type/EntityManagementMergeType.h"
#include "asb_uci/type/EntityManagementProposeCorrelationType.h"
#include "asb_uci/type/EntityManagementSetActivityByType.h"
#include "asb_uci/type/EntityManagementSetCapabilityType.h"
#include "asb_uci/type/EntityManagementSetEnduranceType.h"
#include "asb_uci/type/EntityManagementSetFusionEligibilityType.h"
#include "asb_uci/type/EntityManagementSetIdentityType.h"
#include "asb_uci/type/EntityManagementSetLink16MetadataType.h"
#include "asb_uci/type/EntityManagementSetModeType.h"
#include "asb_uci/type/EntityManagementSetPlatformStatusType.h"
#include "asb_uci/type/EntityManagementSetSignalSummaryType.h"
#include "asb_uci/type/EntityManagementSetStrengthType.h"
#include "asb_uci/type/EntityManagementSetVoiceControlType.h"
#include "asb_uci/type/EntityManagementSplitType.h"
#include "asb_uci/type/EntityManagementSwapType.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/EntityManagementClearIdentityType.h"
#include "uci/type/EntityManagementDownType.h"
#include "uci/type/EntityManagementDropRestrictType.h"
#include "uci/type/EntityManagementDropType.h"
#include "uci/type/EntityManagementKinematicsType.h"
#include "uci/type/EntityManagementMergeType.h"
#include "uci/type/EntityManagementProposeCorrelationType.h"
#include "uci/type/EntityManagementRequestType.h"
#include "uci/type/EntityManagementSetActivityByType.h"
#include "uci/type/EntityManagementSetCapabilityType.h"
#include "uci/type/EntityManagementSetEnduranceType.h"
#include "uci/type/EntityManagementSetFusionEligibilityType.h"
#include "uci/type/EntityManagementSetIdentityType.h"
#include "uci/type/EntityManagementSetLink16MetadataType.h"
#include "uci/type/EntityManagementSetModeType.h"
#include "uci/type/EntityManagementSetPlatformStatusType.h"
#include "uci/type/EntityManagementSetSignalSummaryType.h"
#include "uci/type/EntityManagementSetStrengthType.h"
#include "uci/type/EntityManagementSetVoiceControlType.h"
#include "uci/type/EntityManagementSplitType.h"
#include "uci/type/EntityManagementSwapType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

EntityManagementRequestType::EntityManagementRequestType() = default;

EntityManagementRequestType::~EntityManagementRequestType() = default;

void EntityManagementRequestType::copy(const uci::type::EntityManagementRequestType& accessor) {
  copyImpl(accessor, false);
}

void EntityManagementRequestType::copyImpl(const uci::type::EntityManagementRequestType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const EntityManagementRequestType&>(accessor);
    if (accessorImpl.split_Accessor) {
      setSplit(*(accessorImpl.split_Accessor));
    } else {
      split_Accessor.reset();
    }
    if (accessorImpl.merge_Accessor) {
      setMerge(*(accessorImpl.merge_Accessor));
    } else {
      merge_Accessor.reset();
    }
    if (accessorImpl.drop_Accessor) {
      setDrop(*(accessorImpl.drop_Accessor));
    } else {
      drop_Accessor.reset();
    }
    if (accessorImpl.setDropRestriction_Accessor) {
      setSetDropRestriction(*(accessorImpl.setDropRestriction_Accessor));
    } else {
      setDropRestriction_Accessor.reset();
    }
    if (accessorImpl.clearDropRestriction_Accessor) {
      setClearDropRestriction(*(accessorImpl.clearDropRestriction_Accessor));
    } else {
      clearDropRestriction_Accessor.reset();
    }
    if (accessorImpl.swap_Accessor) {
      setSwap(*(accessorImpl.swap_Accessor));
    } else {
      swap_Accessor.reset();
    }
    if (accessorImpl.setFusionEligibility_Accessor) {
      setSetFusionEligibility(*(accessorImpl.setFusionEligibility_Accessor));
    } else {
      setFusionEligibility_Accessor.reset();
    }
    if (accessorImpl.setIdentity_Accessor) {
      setSetIdentity(*(accessorImpl.setIdentity_Accessor));
    } else {
      setIdentity_Accessor.reset();
    }
    if (accessorImpl.clearIFF_Accessor) {
      setClearIFF(*(accessorImpl.clearIFF_Accessor));
    } else {
      clearIFF_Accessor.reset();
    }
    if (accessorImpl.setDownLocation_Accessor) {
      setSetDownLocation(*(accessorImpl.setDownLocation_Accessor));
    } else {
      setDownLocation_Accessor.reset();
    }
    if (accessorImpl.setKinematics_Accessor) {
      setSetKinematics(*(accessorImpl.setKinematics_Accessor));
    } else {
      setKinematics_Accessor.reset();
    }
    if (accessorImpl.setMode_Accessor) {
      setSetMode(*(accessorImpl.setMode_Accessor));
    } else {
      setMode_Accessor.reset();
    }
    if (accessorImpl.setActivityBy_Accessor) {
      setSetActivityBy(*(accessorImpl.setActivityBy_Accessor));
    } else {
      setActivityBy_Accessor.reset();
    }
    if (accessorImpl.setStrength_Accessor) {
      setSetStrength(*(accessorImpl.setStrength_Accessor));
    } else {
      setStrength_Accessor.reset();
    }
    if (accessorImpl.setPlatformStatus_Accessor) {
      setSetPlatformStatus(*(accessorImpl.setPlatformStatus_Accessor));
    } else {
      setPlatformStatus_Accessor.reset();
    }
    if (accessorImpl.setEndurance_Accessor) {
      setSetEndurance(*(accessorImpl.setEndurance_Accessor));
    } else {
      setEndurance_Accessor.reset();
    }
    if (accessorImpl.setLink16Metadata_Accessor) {
      setSetLink16Metadata(*(accessorImpl.setLink16Metadata_Accessor));
    } else {
      setLink16Metadata_Accessor.reset();
    }
    if (accessorImpl.proposeCorrelation_Accessor) {
      setProposeCorrelation(*(accessorImpl.proposeCorrelation_Accessor));
    } else {
      proposeCorrelation_Accessor.reset();
    }
    if (accessorImpl.setVoiceControl_Accessor) {
      setSetVoiceControl(*(accessorImpl.setVoiceControl_Accessor));
    } else {
      setVoiceControl_Accessor.reset();
    }
    if (accessorImpl.setCapability_Accessor) {
      setSetCapability(*(accessorImpl.setCapability_Accessor));
    } else {
      setCapability_Accessor.reset();
    }
    if (accessorImpl.setSignalSummary_Accessor) {
      setSetSignalSummary(*(accessorImpl.setSignalSummary_Accessor));
    } else {
      setSignalSummary_Accessor.reset();
    }
  }
}

void EntityManagementRequestType::reset() noexcept {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
}

uci::type::EntityManagementRequestType::EntityManagementRequestTypeChoice EntityManagementRequestType::getEntityManagementRequestTypeChoiceOrdinal() const noexcept {
  if (split_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SPLIT;
  }
  if (merge_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_MERGE;
  }
  if (drop_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_DROP;
  }
  if (setDropRestriction_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETDROPRESTRICTION;
  }
  if (clearDropRestriction_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_CLEARDROPRESTRICTION;
  }
  if (swap_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SWAP;
  }
  if (setFusionEligibility_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETFUSIONELIGIBILITY;
  }
  if (setIdentity_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETIDENTITY;
  }
  if (clearIFF_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_CLEARIFF;
  }
  if (setDownLocation_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETDOWNLOCATION;
  }
  if (setKinematics_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETKINEMATICS;
  }
  if (setMode_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETMODE;
  }
  if (setActivityBy_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETACTIVITYBY;
  }
  if (setStrength_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETSTRENGTH;
  }
  if (setPlatformStatus_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETPLATFORMSTATUS;
  }
  if (setEndurance_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETENDURANCE;
  }
  if (setLink16Metadata_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETLINK16METADATA;
  }
  if (proposeCorrelation_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_PROPOSECORRELATION;
  }
  if (setVoiceControl_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETVOICECONTROL;
  }
  if (setCapability_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETCAPABILITY;
  }
  if (setSignalSummary_Accessor) {
    return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETSIGNALSUMMARY;
  }
  return ENTITYMANAGEMENTREQUESTTYPE_CHOICE_NONE;
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setEntityManagementRequestTypeChoiceOrdinal(uci::type::EntityManagementRequestType::EntityManagementRequestTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SPLIT:
      chooseSplit("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_MERGE:
      chooseMerge("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_DROP:
      chooseDrop("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETDROPRESTRICTION:
      chooseSetDropRestriction("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_CLEARDROPRESTRICTION:
      chooseClearDropRestriction("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SWAP:
      chooseSwap("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETFUSIONELIGIBILITY:
      chooseSetFusionEligibility("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETIDENTITY:
      chooseSetIdentity("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_CLEARIFF:
      chooseClearIFF("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETDOWNLOCATION:
      chooseSetDownLocation("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETKINEMATICS:
      chooseSetKinematics("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETMODE:
      chooseSetMode("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETACTIVITYBY:
      chooseSetActivityBy("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETSTRENGTH:
      chooseSetStrength("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETPLATFORMSTATUS:
      chooseSetPlatformStatus("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETENDURANCE:
      chooseSetEndurance("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETLINK16METADATA:
      chooseSetLink16Metadata("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_PROPOSECORRELATION:
      chooseProposeCorrelation("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETVOICECONTROL:
      chooseSetVoiceControl("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETCAPABILITY:
      chooseSetCapability("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    case ENTITYMANAGEMENTREQUESTTYPE_CHOICE_SETSIGNALSUMMARY:
      chooseSetSignalSummary("setEntityManagementRequestTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setEntityManagementRequestTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::EntityManagementSplitType& EntityManagementRequestType::getSplit_() const {
  if (split_Accessor) {
    return *split_Accessor;
  }
  throw uci::base::UCIException("Error in getSplit(): Unable to get Split, field not selected");
}

const uci::type::EntityManagementSplitType& EntityManagementRequestType::getSplit() const {
  return getSplit_();
}

uci::type::EntityManagementSplitType& EntityManagementRequestType::getSplit() {
  return getSplit_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSplit(const uci::type::EntityManagementSplitType& accessor) {
  chooseSplit();
  if (&accessor != split_Accessor.get()) {
    split_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSplit() const noexcept {
  return static_cast<bool>(split_Accessor);
}

uci::type::EntityManagementSplitType& EntityManagementRequestType::chooseSplit(const std::string& method, uci::base::accessorType::AccessorType type) {
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSplitType : type};
  if ((!split_Accessor) || (split_Accessor->getAccessorType() != requestedType)) {
    split_Accessor = EntityManagementSplitType::create(type);
    if (!split_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *split_Accessor;
}

uci::type::EntityManagementSplitType& EntityManagementRequestType::chooseSplit(uci::base::accessorType::AccessorType type) {
  return chooseSplit("chooseSplit", type);
}

uci::type::EntityManagementMergeType& EntityManagementRequestType::getMerge_() const {
  if (merge_Accessor) {
    return *merge_Accessor;
  }
  throw uci::base::UCIException("Error in getMerge(): Unable to get Merge, field not selected");
}

const uci::type::EntityManagementMergeType& EntityManagementRequestType::getMerge() const {
  return getMerge_();
}

uci::type::EntityManagementMergeType& EntityManagementRequestType::getMerge() {
  return getMerge_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setMerge(const uci::type::EntityManagementMergeType& accessor) {
  chooseMerge();
  if (&accessor != merge_Accessor.get()) {
    merge_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isMerge() const noexcept {
  return static_cast<bool>(merge_Accessor);
}

uci::type::EntityManagementMergeType& EntityManagementRequestType::chooseMerge(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementMergeType : type};
  if ((!merge_Accessor) || (merge_Accessor->getAccessorType() != requestedType)) {
    merge_Accessor = EntityManagementMergeType::create(type);
    if (!merge_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *merge_Accessor;
}

uci::type::EntityManagementMergeType& EntityManagementRequestType::chooseMerge(uci::base::accessorType::AccessorType type) {
  return chooseMerge("chooseMerge", type);
}

uci::type::EntityManagementDropType& EntityManagementRequestType::getDrop_() const {
  if (drop_Accessor) {
    return *drop_Accessor;
  }
  throw uci::base::UCIException("Error in getDrop(): Unable to get Drop, field not selected");
}

const uci::type::EntityManagementDropType& EntityManagementRequestType::getDrop() const {
  return getDrop_();
}

uci::type::EntityManagementDropType& EntityManagementRequestType::getDrop() {
  return getDrop_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setDrop(const uci::type::EntityManagementDropType& accessor) {
  chooseDrop(accessor.getAccessorType());
  if (&accessor != drop_Accessor.get()) {
    drop_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isDrop() const noexcept {
  return static_cast<bool>(drop_Accessor);
}

uci::type::EntityManagementDropType& EntityManagementRequestType::chooseDrop(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementDropType : type};
  if ((!drop_Accessor) || (drop_Accessor->getAccessorType() != requestedType)) {
    drop_Accessor = EntityManagementDropType::create(type);
    if (!drop_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *drop_Accessor;
}

uci::type::EntityManagementDropType& EntityManagementRequestType::chooseDrop(uci::base::accessorType::AccessorType type) {
  return chooseDrop("chooseDrop", type);
}

uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::getSetDropRestriction_() const {
  if (setDropRestriction_Accessor) {
    return *setDropRestriction_Accessor;
  }
  throw uci::base::UCIException("Error in getSetDropRestriction(): Unable to get SetDropRestriction, field not selected");
}

const uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::getSetDropRestriction() const {
  return getSetDropRestriction_();
}

uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::getSetDropRestriction() {
  return getSetDropRestriction_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetDropRestriction(const uci::type::EntityManagementDropRestrictType& accessor) {
  chooseSetDropRestriction();
  if (&accessor != setDropRestriction_Accessor.get()) {
    setDropRestriction_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetDropRestriction() const noexcept {
  return static_cast<bool>(setDropRestriction_Accessor);
}

uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::chooseSetDropRestriction(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementDropRestrictType : type};
  if ((!setDropRestriction_Accessor) || (setDropRestriction_Accessor->getAccessorType() != requestedType)) {
    setDropRestriction_Accessor = EntityManagementDropRestrictType::create(type);
    if (!setDropRestriction_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setDropRestriction_Accessor;
}

uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::chooseSetDropRestriction(uci::base::accessorType::AccessorType type) {
  return chooseSetDropRestriction("chooseSetDropRestriction", type);
}

uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::getClearDropRestriction_() const {
  if (clearDropRestriction_Accessor) {
    return *clearDropRestriction_Accessor;
  }
  throw uci::base::UCIException("Error in getClearDropRestriction(): Unable to get ClearDropRestriction, field not selected");
}

const uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::getClearDropRestriction() const {
  return getClearDropRestriction_();
}

uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::getClearDropRestriction() {
  return getClearDropRestriction_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setClearDropRestriction(const uci::type::EntityManagementDropRestrictType& accessor) {
  chooseClearDropRestriction();
  if (&accessor != clearDropRestriction_Accessor.get()) {
    clearDropRestriction_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isClearDropRestriction() const noexcept {
  return static_cast<bool>(clearDropRestriction_Accessor);
}

uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::chooseClearDropRestriction(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementDropRestrictType : type};
  if ((!clearDropRestriction_Accessor) || (clearDropRestriction_Accessor->getAccessorType() != requestedType)) {
    clearDropRestriction_Accessor = EntityManagementDropRestrictType::create(type);
    if (!clearDropRestriction_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *clearDropRestriction_Accessor;
}

uci::type::EntityManagementDropRestrictType& EntityManagementRequestType::chooseClearDropRestriction(uci::base::accessorType::AccessorType type) {
  return chooseClearDropRestriction("chooseClearDropRestriction", type);
}

uci::type::EntityManagementSwapType& EntityManagementRequestType::getSwap_() const {
  if (swap_Accessor) {
    return *swap_Accessor;
  }
  throw uci::base::UCIException("Error in getSwap(): Unable to get Swap, field not selected");
}

const uci::type::EntityManagementSwapType& EntityManagementRequestType::getSwap() const {
  return getSwap_();
}

uci::type::EntityManagementSwapType& EntityManagementRequestType::getSwap() {
  return getSwap_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSwap(const uci::type::EntityManagementSwapType& accessor) {
  chooseSwap();
  if (&accessor != swap_Accessor.get()) {
    swap_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSwap() const noexcept {
  return static_cast<bool>(swap_Accessor);
}

uci::type::EntityManagementSwapType& EntityManagementRequestType::chooseSwap(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSwapType : type};
  if ((!swap_Accessor) || (swap_Accessor->getAccessorType() != requestedType)) {
    swap_Accessor = EntityManagementSwapType::create(type);
    if (!swap_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *swap_Accessor;
}

uci::type::EntityManagementSwapType& EntityManagementRequestType::chooseSwap(uci::base::accessorType::AccessorType type) {
  return chooseSwap("chooseSwap", type);
}

uci::type::EntityManagementSetFusionEligibilityType& EntityManagementRequestType::getSetFusionEligibility_() const {
  if (setFusionEligibility_Accessor) {
    return *setFusionEligibility_Accessor;
  }
  throw uci::base::UCIException("Error in getSetFusionEligibility(): Unable to get SetFusionEligibility, field not selected");
}

const uci::type::EntityManagementSetFusionEligibilityType& EntityManagementRequestType::getSetFusionEligibility() const {
  return getSetFusionEligibility_();
}

uci::type::EntityManagementSetFusionEligibilityType& EntityManagementRequestType::getSetFusionEligibility() {
  return getSetFusionEligibility_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetFusionEligibility(const uci::type::EntityManagementSetFusionEligibilityType& accessor) {
  chooseSetFusionEligibility();
  if (&accessor != setFusionEligibility_Accessor.get()) {
    setFusionEligibility_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetFusionEligibility() const noexcept {
  return static_cast<bool>(setFusionEligibility_Accessor);
}

uci::type::EntityManagementSetFusionEligibilityType& EntityManagementRequestType::chooseSetFusionEligibility(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetFusionEligibilityType : type};
  if ((!setFusionEligibility_Accessor) || (setFusionEligibility_Accessor->getAccessorType() != requestedType)) {
    setFusionEligibility_Accessor = EntityManagementSetFusionEligibilityType::create(type);
    if (!setFusionEligibility_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setFusionEligibility_Accessor;
}

uci::type::EntityManagementSetFusionEligibilityType& EntityManagementRequestType::chooseSetFusionEligibility(uci::base::accessorType::AccessorType type) {
  return chooseSetFusionEligibility("chooseSetFusionEligibility", type);
}

uci::type::EntityManagementSetIdentityType& EntityManagementRequestType::getSetIdentity_() const {
  if (setIdentity_Accessor) {
    return *setIdentity_Accessor;
  }
  throw uci::base::UCIException("Error in getSetIdentity(): Unable to get SetIdentity, field not selected");
}

const uci::type::EntityManagementSetIdentityType& EntityManagementRequestType::getSetIdentity() const {
  return getSetIdentity_();
}

uci::type::EntityManagementSetIdentityType& EntityManagementRequestType::getSetIdentity() {
  return getSetIdentity_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetIdentity(const uci::type::EntityManagementSetIdentityType& accessor) {
  chooseSetIdentity();
  if (&accessor != setIdentity_Accessor.get()) {
    setIdentity_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetIdentity() const noexcept {
  return static_cast<bool>(setIdentity_Accessor);
}

uci::type::EntityManagementSetIdentityType& EntityManagementRequestType::chooseSetIdentity(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetIdentityType : type};
  if ((!setIdentity_Accessor) || (setIdentity_Accessor->getAccessorType() != requestedType)) {
    setIdentity_Accessor = EntityManagementSetIdentityType::create(type);
    if (!setIdentity_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setIdentity_Accessor;
}

uci::type::EntityManagementSetIdentityType& EntityManagementRequestType::chooseSetIdentity(uci::base::accessorType::AccessorType type) {
  return chooseSetIdentity("chooseSetIdentity", type);
}

uci::type::EntityManagementClearIdentityType& EntityManagementRequestType::getClearIFF_() const {
  if (clearIFF_Accessor) {
    return *clearIFF_Accessor;
  }
  throw uci::base::UCIException("Error in getClearIFF(): Unable to get ClearIFF, field not selected");
}

const uci::type::EntityManagementClearIdentityType& EntityManagementRequestType::getClearIFF() const {
  return getClearIFF_();
}

uci::type::EntityManagementClearIdentityType& EntityManagementRequestType::getClearIFF() {
  return getClearIFF_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setClearIFF(const uci::type::EntityManagementClearIdentityType& accessor) {
  chooseClearIFF();
  if (&accessor != clearIFF_Accessor.get()) {
    clearIFF_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isClearIFF() const noexcept {
  return static_cast<bool>(clearIFF_Accessor);
}

uci::type::EntityManagementClearIdentityType& EntityManagementRequestType::chooseClearIFF(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementClearIdentityType : type};
  if ((!clearIFF_Accessor) || (clearIFF_Accessor->getAccessorType() != requestedType)) {
    clearIFF_Accessor = EntityManagementClearIdentityType::create(type);
    if (!clearIFF_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *clearIFF_Accessor;
}

uci::type::EntityManagementClearIdentityType& EntityManagementRequestType::chooseClearIFF(uci::base::accessorType::AccessorType type) {
  return chooseClearIFF("chooseClearIFF", type);
}

uci::type::EntityManagementDownType& EntityManagementRequestType::getSetDownLocation_() const {
  if (setDownLocation_Accessor) {
    return *setDownLocation_Accessor;
  }
  throw uci::base::UCIException("Error in getSetDownLocation(): Unable to get SetDownLocation, field not selected");
}

const uci::type::EntityManagementDownType& EntityManagementRequestType::getSetDownLocation() const {
  return getSetDownLocation_();
}

uci::type::EntityManagementDownType& EntityManagementRequestType::getSetDownLocation() {
  return getSetDownLocation_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetDownLocation(const uci::type::EntityManagementDownType& accessor) {
  chooseSetDownLocation();
  if (&accessor != setDownLocation_Accessor.get()) {
    setDownLocation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetDownLocation() const noexcept {
  return static_cast<bool>(setDownLocation_Accessor);
}

uci::type::EntityManagementDownType& EntityManagementRequestType::chooseSetDownLocation(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementDownType : type};
  if ((!setDownLocation_Accessor) || (setDownLocation_Accessor->getAccessorType() != requestedType)) {
    setDownLocation_Accessor = EntityManagementDownType::create(type);
    if (!setDownLocation_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setDownLocation_Accessor;
}

uci::type::EntityManagementDownType& EntityManagementRequestType::chooseSetDownLocation(uci::base::accessorType::AccessorType type) {
  return chooseSetDownLocation("chooseSetDownLocation", type);
}

uci::type::EntityManagementKinematicsType& EntityManagementRequestType::getSetKinematics_() const {
  if (setKinematics_Accessor) {
    return *setKinematics_Accessor;
  }
  throw uci::base::UCIException("Error in getSetKinematics(): Unable to get SetKinematics, field not selected");
}

const uci::type::EntityManagementKinematicsType& EntityManagementRequestType::getSetKinematics() const {
  return getSetKinematics_();
}

uci::type::EntityManagementKinematicsType& EntityManagementRequestType::getSetKinematics() {
  return getSetKinematics_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetKinematics(const uci::type::EntityManagementKinematicsType& accessor) {
  chooseSetKinematics();
  if (&accessor != setKinematics_Accessor.get()) {
    setKinematics_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetKinematics() const noexcept {
  return static_cast<bool>(setKinematics_Accessor);
}

uci::type::EntityManagementKinematicsType& EntityManagementRequestType::chooseSetKinematics(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementKinematicsType : type};
  if ((!setKinematics_Accessor) || (setKinematics_Accessor->getAccessorType() != requestedType)) {
    setKinematics_Accessor = EntityManagementKinematicsType::create(type);
    if (!setKinematics_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setKinematics_Accessor;
}

uci::type::EntityManagementKinematicsType& EntityManagementRequestType::chooseSetKinematics(uci::base::accessorType::AccessorType type) {
  return chooseSetKinematics("chooseSetKinematics", type);
}

uci::type::EntityManagementSetModeType& EntityManagementRequestType::getSetMode_() const {
  if (setMode_Accessor) {
    return *setMode_Accessor;
  }
  throw uci::base::UCIException("Error in getSetMode(): Unable to get SetMode, field not selected");
}

const uci::type::EntityManagementSetModeType& EntityManagementRequestType::getSetMode() const {
  return getSetMode_();
}

uci::type::EntityManagementSetModeType& EntityManagementRequestType::getSetMode() {
  return getSetMode_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetMode(const uci::type::EntityManagementSetModeType& accessor) {
  chooseSetMode();
  if (&accessor != setMode_Accessor.get()) {
    setMode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetMode() const noexcept {
  return static_cast<bool>(setMode_Accessor);
}

uci::type::EntityManagementSetModeType& EntityManagementRequestType::chooseSetMode(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetModeType : type};
  if ((!setMode_Accessor) || (setMode_Accessor->getAccessorType() != requestedType)) {
    setMode_Accessor = EntityManagementSetModeType::create(type);
    if (!setMode_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setMode_Accessor;
}

uci::type::EntityManagementSetModeType& EntityManagementRequestType::chooseSetMode(uci::base::accessorType::AccessorType type) {
  return chooseSetMode("chooseSetMode", type);
}

uci::type::EntityManagementSetActivityByType& EntityManagementRequestType::getSetActivityBy_() const {
  if (setActivityBy_Accessor) {
    return *setActivityBy_Accessor;
  }
  throw uci::base::UCIException("Error in getSetActivityBy(): Unable to get SetActivityBy, field not selected");
}

const uci::type::EntityManagementSetActivityByType& EntityManagementRequestType::getSetActivityBy() const {
  return getSetActivityBy_();
}

uci::type::EntityManagementSetActivityByType& EntityManagementRequestType::getSetActivityBy() {
  return getSetActivityBy_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetActivityBy(const uci::type::EntityManagementSetActivityByType& accessor) {
  chooseSetActivityBy();
  if (&accessor != setActivityBy_Accessor.get()) {
    setActivityBy_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetActivityBy() const noexcept {
  return static_cast<bool>(setActivityBy_Accessor);
}

uci::type::EntityManagementSetActivityByType& EntityManagementRequestType::chooseSetActivityBy(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetActivityByType : type};
  if ((!setActivityBy_Accessor) || (setActivityBy_Accessor->getAccessorType() != requestedType)) {
    setActivityBy_Accessor = EntityManagementSetActivityByType::create(type);
    if (!setActivityBy_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setActivityBy_Accessor;
}

uci::type::EntityManagementSetActivityByType& EntityManagementRequestType::chooseSetActivityBy(uci::base::accessorType::AccessorType type) {
  return chooseSetActivityBy("chooseSetActivityBy", type);
}

uci::type::EntityManagementSetStrengthType& EntityManagementRequestType::getSetStrength_() const {
  if (setStrength_Accessor) {
    return *setStrength_Accessor;
  }
  throw uci::base::UCIException("Error in getSetStrength(): Unable to get SetStrength, field not selected");
}

const uci::type::EntityManagementSetStrengthType& EntityManagementRequestType::getSetStrength() const {
  return getSetStrength_();
}

uci::type::EntityManagementSetStrengthType& EntityManagementRequestType::getSetStrength() {
  return getSetStrength_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetStrength(const uci::type::EntityManagementSetStrengthType& accessor) {
  chooseSetStrength();
  if (&accessor != setStrength_Accessor.get()) {
    setStrength_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetStrength() const noexcept {
  return static_cast<bool>(setStrength_Accessor);
}

uci::type::EntityManagementSetStrengthType& EntityManagementRequestType::chooseSetStrength(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetStrengthType : type};
  if ((!setStrength_Accessor) || (setStrength_Accessor->getAccessorType() != requestedType)) {
    setStrength_Accessor = EntityManagementSetStrengthType::create(type);
    if (!setStrength_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setStrength_Accessor;
}

uci::type::EntityManagementSetStrengthType& EntityManagementRequestType::chooseSetStrength(uci::base::accessorType::AccessorType type) {
  return chooseSetStrength("chooseSetStrength", type);
}

uci::type::EntityManagementSetPlatformStatusType& EntityManagementRequestType::getSetPlatformStatus_() const {
  if (setPlatformStatus_Accessor) {
    return *setPlatformStatus_Accessor;
  }
  throw uci::base::UCIException("Error in getSetPlatformStatus(): Unable to get SetPlatformStatus, field not selected");
}

const uci::type::EntityManagementSetPlatformStatusType& EntityManagementRequestType::getSetPlatformStatus() const {
  return getSetPlatformStatus_();
}

uci::type::EntityManagementSetPlatformStatusType& EntityManagementRequestType::getSetPlatformStatus() {
  return getSetPlatformStatus_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetPlatformStatus(const uci::type::EntityManagementSetPlatformStatusType& accessor) {
  chooseSetPlatformStatus();
  if (&accessor != setPlatformStatus_Accessor.get()) {
    setPlatformStatus_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetPlatformStatus() const noexcept {
  return static_cast<bool>(setPlatformStatus_Accessor);
}

uci::type::EntityManagementSetPlatformStatusType& EntityManagementRequestType::chooseSetPlatformStatus(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetPlatformStatusType : type};
  if ((!setPlatformStatus_Accessor) || (setPlatformStatus_Accessor->getAccessorType() != requestedType)) {
    setPlatformStatus_Accessor = EntityManagementSetPlatformStatusType::create(type);
    if (!setPlatformStatus_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setPlatformStatus_Accessor;
}

uci::type::EntityManagementSetPlatformStatusType& EntityManagementRequestType::chooseSetPlatformStatus(uci::base::accessorType::AccessorType type) {
  return chooseSetPlatformStatus("chooseSetPlatformStatus", type);
}

uci::type::EntityManagementSetEnduranceType& EntityManagementRequestType::getSetEndurance_() const {
  if (setEndurance_Accessor) {
    return *setEndurance_Accessor;
  }
  throw uci::base::UCIException("Error in getSetEndurance(): Unable to get SetEndurance, field not selected");
}

const uci::type::EntityManagementSetEnduranceType& EntityManagementRequestType::getSetEndurance() const {
  return getSetEndurance_();
}

uci::type::EntityManagementSetEnduranceType& EntityManagementRequestType::getSetEndurance() {
  return getSetEndurance_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetEndurance(const uci::type::EntityManagementSetEnduranceType& accessor) {
  chooseSetEndurance();
  if (&accessor != setEndurance_Accessor.get()) {
    setEndurance_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetEndurance() const noexcept {
  return static_cast<bool>(setEndurance_Accessor);
}

uci::type::EntityManagementSetEnduranceType& EntityManagementRequestType::chooseSetEndurance(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetEnduranceType : type};
  if ((!setEndurance_Accessor) || (setEndurance_Accessor->getAccessorType() != requestedType)) {
    setEndurance_Accessor = EntityManagementSetEnduranceType::create(type);
    if (!setEndurance_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setEndurance_Accessor;
}

uci::type::EntityManagementSetEnduranceType& EntityManagementRequestType::chooseSetEndurance(uci::base::accessorType::AccessorType type) {
  return chooseSetEndurance("chooseSetEndurance", type);
}

uci::type::EntityManagementSetLink16MetadataType& EntityManagementRequestType::getSetLink16Metadata_() const {
  if (setLink16Metadata_Accessor) {
    return *setLink16Metadata_Accessor;
  }
  throw uci::base::UCIException("Error in getSetLink16Metadata(): Unable to get SetLink16Metadata, field not selected");
}

const uci::type::EntityManagementSetLink16MetadataType& EntityManagementRequestType::getSetLink16Metadata() const {
  return getSetLink16Metadata_();
}

uci::type::EntityManagementSetLink16MetadataType& EntityManagementRequestType::getSetLink16Metadata() {
  return getSetLink16Metadata_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetLink16Metadata(const uci::type::EntityManagementSetLink16MetadataType& accessor) {
  chooseSetLink16Metadata();
  if (&accessor != setLink16Metadata_Accessor.get()) {
    setLink16Metadata_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetLink16Metadata() const noexcept {
  return static_cast<bool>(setLink16Metadata_Accessor);
}

uci::type::EntityManagementSetLink16MetadataType& EntityManagementRequestType::chooseSetLink16Metadata(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetLink16MetadataType : type};
  if ((!setLink16Metadata_Accessor) || (setLink16Metadata_Accessor->getAccessorType() != requestedType)) {
    setLink16Metadata_Accessor = EntityManagementSetLink16MetadataType::create(type);
    if (!setLink16Metadata_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setLink16Metadata_Accessor;
}

uci::type::EntityManagementSetLink16MetadataType& EntityManagementRequestType::chooseSetLink16Metadata(uci::base::accessorType::AccessorType type) {
  return chooseSetLink16Metadata("chooseSetLink16Metadata", type);
}

uci::type::EntityManagementProposeCorrelationType& EntityManagementRequestType::getProposeCorrelation_() const {
  if (proposeCorrelation_Accessor) {
    return *proposeCorrelation_Accessor;
  }
  throw uci::base::UCIException("Error in getProposeCorrelation(): Unable to get ProposeCorrelation, field not selected");
}

const uci::type::EntityManagementProposeCorrelationType& EntityManagementRequestType::getProposeCorrelation() const {
  return getProposeCorrelation_();
}

uci::type::EntityManagementProposeCorrelationType& EntityManagementRequestType::getProposeCorrelation() {
  return getProposeCorrelation_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setProposeCorrelation(const uci::type::EntityManagementProposeCorrelationType& accessor) {
  chooseProposeCorrelation();
  if (&accessor != proposeCorrelation_Accessor.get()) {
    proposeCorrelation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isProposeCorrelation() const noexcept {
  return static_cast<bool>(proposeCorrelation_Accessor);
}

uci::type::EntityManagementProposeCorrelationType& EntityManagementRequestType::chooseProposeCorrelation(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementProposeCorrelationType : type};
  if ((!proposeCorrelation_Accessor) || (proposeCorrelation_Accessor->getAccessorType() != requestedType)) {
    proposeCorrelation_Accessor = EntityManagementProposeCorrelationType::create(type);
    if (!proposeCorrelation_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *proposeCorrelation_Accessor;
}

uci::type::EntityManagementProposeCorrelationType& EntityManagementRequestType::chooseProposeCorrelation(uci::base::accessorType::AccessorType type) {
  return chooseProposeCorrelation("chooseProposeCorrelation", type);
}

uci::type::EntityManagementSetVoiceControlType& EntityManagementRequestType::getSetVoiceControl_() const {
  if (setVoiceControl_Accessor) {
    return *setVoiceControl_Accessor;
  }
  throw uci::base::UCIException("Error in getSetVoiceControl(): Unable to get SetVoiceControl, field not selected");
}

const uci::type::EntityManagementSetVoiceControlType& EntityManagementRequestType::getSetVoiceControl() const {
  return getSetVoiceControl_();
}

uci::type::EntityManagementSetVoiceControlType& EntityManagementRequestType::getSetVoiceControl() {
  return getSetVoiceControl_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetVoiceControl(const uci::type::EntityManagementSetVoiceControlType& accessor) {
  chooseSetVoiceControl();
  if (&accessor != setVoiceControl_Accessor.get()) {
    setVoiceControl_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetVoiceControl() const noexcept {
  return static_cast<bool>(setVoiceControl_Accessor);
}

uci::type::EntityManagementSetVoiceControlType& EntityManagementRequestType::chooseSetVoiceControl(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setCapability_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetVoiceControlType : type};
  if ((!setVoiceControl_Accessor) || (setVoiceControl_Accessor->getAccessorType() != requestedType)) {
    setVoiceControl_Accessor = EntityManagementSetVoiceControlType::create(type);
    if (!setVoiceControl_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setVoiceControl_Accessor;
}

uci::type::EntityManagementSetVoiceControlType& EntityManagementRequestType::chooseSetVoiceControl(uci::base::accessorType::AccessorType type) {
  return chooseSetVoiceControl("chooseSetVoiceControl", type);
}

uci::type::EntityManagementSetCapabilityType& EntityManagementRequestType::getSetCapability_() const {
  if (setCapability_Accessor) {
    return *setCapability_Accessor;
  }
  throw uci::base::UCIException("Error in getSetCapability(): Unable to get SetCapability, field not selected");
}

const uci::type::EntityManagementSetCapabilityType& EntityManagementRequestType::getSetCapability() const {
  return getSetCapability_();
}

uci::type::EntityManagementSetCapabilityType& EntityManagementRequestType::getSetCapability() {
  return getSetCapability_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetCapability(const uci::type::EntityManagementSetCapabilityType& accessor) {
  chooseSetCapability();
  if (&accessor != setCapability_Accessor.get()) {
    setCapability_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetCapability() const noexcept {
  return static_cast<bool>(setCapability_Accessor);
}

uci::type::EntityManagementSetCapabilityType& EntityManagementRequestType::chooseSetCapability(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setSignalSummary_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetCapabilityType : type};
  if ((!setCapability_Accessor) || (setCapability_Accessor->getAccessorType() != requestedType)) {
    setCapability_Accessor = EntityManagementSetCapabilityType::create(type);
    if (!setCapability_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setCapability_Accessor;
}

uci::type::EntityManagementSetCapabilityType& EntityManagementRequestType::chooseSetCapability(uci::base::accessorType::AccessorType type) {
  return chooseSetCapability("chooseSetCapability", type);
}

uci::type::EntityManagementSetSignalSummaryType& EntityManagementRequestType::getSetSignalSummary_() const {
  if (setSignalSummary_Accessor) {
    return *setSignalSummary_Accessor;
  }
  throw uci::base::UCIException("Error in getSetSignalSummary(): Unable to get SetSignalSummary, field not selected");
}

const uci::type::EntityManagementSetSignalSummaryType& EntityManagementRequestType::getSetSignalSummary() const {
  return getSetSignalSummary_();
}

uci::type::EntityManagementSetSignalSummaryType& EntityManagementRequestType::getSetSignalSummary() {
  return getSetSignalSummary_();
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::setSetSignalSummary(const uci::type::EntityManagementSetSignalSummaryType& accessor) {
  chooseSetSignalSummary();
  if (&accessor != setSignalSummary_Accessor.get()) {
    setSignalSummary_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool EntityManagementRequestType::isSetSignalSummary() const noexcept {
  return static_cast<bool>(setSignalSummary_Accessor);
}

uci::type::EntityManagementSetSignalSummaryType& EntityManagementRequestType::chooseSetSignalSummary(const std::string& method, uci::base::accessorType::AccessorType type) {
  split_Accessor.reset();
  merge_Accessor.reset();
  drop_Accessor.reset();
  setDropRestriction_Accessor.reset();
  clearDropRestriction_Accessor.reset();
  swap_Accessor.reset();
  setFusionEligibility_Accessor.reset();
  setIdentity_Accessor.reset();
  clearIFF_Accessor.reset();
  setDownLocation_Accessor.reset();
  setKinematics_Accessor.reset();
  setMode_Accessor.reset();
  setActivityBy_Accessor.reset();
  setStrength_Accessor.reset();
  setPlatformStatus_Accessor.reset();
  setEndurance_Accessor.reset();
  setLink16Metadata_Accessor.reset();
  proposeCorrelation_Accessor.reset();
  setVoiceControl_Accessor.reset();
  setCapability_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementSetSignalSummaryType : type};
  if ((!setSignalSummary_Accessor) || (setSignalSummary_Accessor->getAccessorType() != requestedType)) {
    setSignalSummary_Accessor = EntityManagementSetSignalSummaryType::create(type);
    if (!setSignalSummary_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *setSignalSummary_Accessor;
}

uci::type::EntityManagementSetSignalSummaryType& EntityManagementRequestType::chooseSetSignalSummary(uci::base::accessorType::AccessorType type) {
  return chooseSetSignalSummary("chooseSetSignalSummary", type);
}

std::unique_ptr<EntityManagementRequestType> EntityManagementRequestType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::entityManagementRequestType : type};
  return (requestedType == uci::type::accessorType::entityManagementRequestType) ? boost::make_unique<EntityManagementRequestType>() : nullptr;
}

/**  */
namespace EntityManagementRequestType_Names {

constexpr const char* Extern_Type_Name{"EntityManagementRequestType"};
constexpr const char* Split_Name{"Split"};
constexpr const char* Merge_Name{"Merge"};
constexpr const char* Drop_Name{"Drop"};
constexpr const char* SetDropRestriction_Name{"SetDropRestriction"};
constexpr const char* ClearDropRestriction_Name{"ClearDropRestriction"};
constexpr const char* Swap_Name{"Swap"};
constexpr const char* SetFusionEligibility_Name{"SetFusionEligibility"};
constexpr const char* SetIdentity_Name{"SetIdentity"};
constexpr const char* ClearIFF_Name{"ClearIFF"};
constexpr const char* SetDownLocation_Name{"SetDownLocation"};
constexpr const char* SetKinematics_Name{"SetKinematics"};
constexpr const char* SetMode_Name{"SetMode"};
constexpr const char* SetActivityBy_Name{"SetActivityBy"};
constexpr const char* SetStrength_Name{"SetStrength"};
constexpr const char* SetPlatformStatus_Name{"SetPlatformStatus"};
constexpr const char* SetEndurance_Name{"SetEndurance"};
constexpr const char* SetLink16Metadata_Name{"SetLink16Metadata"};
constexpr const char* ProposeCorrelation_Name{"ProposeCorrelation"};
constexpr const char* SetVoiceControl_Name{"SetVoiceControl"};
constexpr const char* SetCapability_Name{"SetCapability"};
constexpr const char* SetSignalSummary_Name{"SetSignalSummary"};

} // namespace EntityManagementRequestType_Names

void EntityManagementRequestType::deserialize(const boost::property_tree::ptree& propTree, uci::type::EntityManagementRequestType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = EntityManagementRequestType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::Split_Name) {
      EntityManagementSplitType::deserialize(valueType.second, accessor.chooseSplit(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::Merge_Name) {
      EntityManagementMergeType::deserialize(valueType.second, accessor.chooseMerge(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::Drop_Name) {
      EntityManagementDropType::deserialize(valueType.second, accessor.chooseDrop(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetDropRestriction_Name) {
      EntityManagementDropRestrictType::deserialize(valueType.second, accessor.chooseSetDropRestriction(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::ClearDropRestriction_Name) {
      EntityManagementDropRestrictType::deserialize(valueType.second, accessor.chooseClearDropRestriction(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::Swap_Name) {
      EntityManagementSwapType::deserialize(valueType.second, accessor.chooseSwap(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetFusionEligibility_Name) {
      EntityManagementSetFusionEligibilityType::deserialize(valueType.second, accessor.chooseSetFusionEligibility(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetIdentity_Name) {
      EntityManagementSetIdentityType::deserialize(valueType.second, accessor.chooseSetIdentity(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::ClearIFF_Name) {
      EntityManagementClearIdentityType::deserialize(valueType.second, accessor.chooseClearIFF(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetDownLocation_Name) {
      EntityManagementDownType::deserialize(valueType.second, accessor.chooseSetDownLocation(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetKinematics_Name) {
      EntityManagementKinematicsType::deserialize(valueType.second, accessor.chooseSetKinematics(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetMode_Name) {
      EntityManagementSetModeType::deserialize(valueType.second, accessor.chooseSetMode(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetActivityBy_Name) {
      EntityManagementSetActivityByType::deserialize(valueType.second, accessor.chooseSetActivityBy(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetStrength_Name) {
      EntityManagementSetStrengthType::deserialize(valueType.second, accessor.chooseSetStrength(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetPlatformStatus_Name) {
      EntityManagementSetPlatformStatusType::deserialize(valueType.second, accessor.chooseSetPlatformStatus(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetEndurance_Name) {
      EntityManagementSetEnduranceType::deserialize(valueType.second, accessor.chooseSetEndurance(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetLink16Metadata_Name) {
      EntityManagementSetLink16MetadataType::deserialize(valueType.second, accessor.chooseSetLink16Metadata(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::ProposeCorrelation_Name) {
      EntityManagementProposeCorrelationType::deserialize(valueType.second, accessor.chooseProposeCorrelation(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetVoiceControl_Name) {
      EntityManagementSetVoiceControlType::deserialize(valueType.second, accessor.chooseSetVoiceControl(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetCapability_Name) {
      EntityManagementSetCapabilityType::deserialize(valueType.second, accessor.chooseSetCapability(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + EntityManagementRequestType_Names::SetSignalSummary_Name) {
      EntityManagementSetSignalSummaryType::deserialize(valueType.second, accessor.chooseSetSignalSummary(), nodeName, nsPrefix);
    }
  }
}

std::string EntityManagementRequestType::serialize(const uci::type::EntityManagementRequestType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? EntityManagementRequestType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, EntityManagementRequestType_Names::Extern_Type_Name);
  }
  if (accessor.isSplit()) {
    EntityManagementSplitType::serialize(accessor.getSplit(), node, EntityManagementRequestType_Names::Split_Name);
  } else if (accessor.isMerge()) {
    EntityManagementMergeType::serialize(accessor.getMerge(), node, EntityManagementRequestType_Names::Merge_Name);
  } else if (accessor.isDrop()) {
    EntityManagementDropType::serialize(accessor.getDrop(), node, EntityManagementRequestType_Names::Drop_Name);
  } else if (accessor.isSetDropRestriction()) {
    EntityManagementDropRestrictType::serialize(accessor.getSetDropRestriction(), node, EntityManagementRequestType_Names::SetDropRestriction_Name);
  } else if (accessor.isClearDropRestriction()) {
    EntityManagementDropRestrictType::serialize(accessor.getClearDropRestriction(), node, EntityManagementRequestType_Names::ClearDropRestriction_Name);
  } else if (accessor.isSwap()) {
    EntityManagementSwapType::serialize(accessor.getSwap(), node, EntityManagementRequestType_Names::Swap_Name);
  } else if (accessor.isSetFusionEligibility()) {
    EntityManagementSetFusionEligibilityType::serialize(accessor.getSetFusionEligibility(), node, EntityManagementRequestType_Names::SetFusionEligibility_Name);
  } else if (accessor.isSetIdentity()) {
    EntityManagementSetIdentityType::serialize(accessor.getSetIdentity(), node, EntityManagementRequestType_Names::SetIdentity_Name);
  } else if (accessor.isClearIFF()) {
    EntityManagementClearIdentityType::serialize(accessor.getClearIFF(), node, EntityManagementRequestType_Names::ClearIFF_Name);
  } else if (accessor.isSetDownLocation()) {
    EntityManagementDownType::serialize(accessor.getSetDownLocation(), node, EntityManagementRequestType_Names::SetDownLocation_Name);
  } else if (accessor.isSetKinematics()) {
    EntityManagementKinematicsType::serialize(accessor.getSetKinematics(), node, EntityManagementRequestType_Names::SetKinematics_Name);
  } else if (accessor.isSetMode()) {
    EntityManagementSetModeType::serialize(accessor.getSetMode(), node, EntityManagementRequestType_Names::SetMode_Name);
  } else if (accessor.isSetActivityBy()) {
    EntityManagementSetActivityByType::serialize(accessor.getSetActivityBy(), node, EntityManagementRequestType_Names::SetActivityBy_Name);
  } else if (accessor.isSetStrength()) {
    EntityManagementSetStrengthType::serialize(accessor.getSetStrength(), node, EntityManagementRequestType_Names::SetStrength_Name);
  } else if (accessor.isSetPlatformStatus()) {
    EntityManagementSetPlatformStatusType::serialize(accessor.getSetPlatformStatus(), node, EntityManagementRequestType_Names::SetPlatformStatus_Name);
  } else if (accessor.isSetEndurance()) {
    EntityManagementSetEnduranceType::serialize(accessor.getSetEndurance(), node, EntityManagementRequestType_Names::SetEndurance_Name);
  } else if (accessor.isSetLink16Metadata()) {
    EntityManagementSetLink16MetadataType::serialize(accessor.getSetLink16Metadata(), node, EntityManagementRequestType_Names::SetLink16Metadata_Name);
  } else if (accessor.isProposeCorrelation()) {
    EntityManagementProposeCorrelationType::serialize(accessor.getProposeCorrelation(), node, EntityManagementRequestType_Names::ProposeCorrelation_Name);
  } else if (accessor.isSetVoiceControl()) {
    EntityManagementSetVoiceControlType::serialize(accessor.getSetVoiceControl(), node, EntityManagementRequestType_Names::SetVoiceControl_Name);
  } else if (accessor.isSetCapability()) {
    EntityManagementSetCapabilityType::serialize(accessor.getSetCapability(), node, EntityManagementRequestType_Names::SetCapability_Name);
  } else if (accessor.isSetSignalSummary()) {
    EntityManagementSetSignalSummaryType::serialize(accessor.getSetSignalSummary(), node, EntityManagementRequestType_Names::SetSignalSummary_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::EntityManagementRequestType& EntityManagementRequestType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::EntityManagementRequestType>().release());
}

uci::type::EntityManagementRequestType& EntityManagementRequestType::create(const uci::type::EntityManagementRequestType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::EntityManagementRequestType> newAccessor{boost::make_unique<asb_uci::type::EntityManagementRequestType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void EntityManagementRequestType::destroy(uci::type::EntityManagementRequestType& accessor) {
  delete dynamic_cast<asb_uci::type::EntityManagementRequestType*>(&accessor);
}

} // namespace type

} // namespace uci

