/** @file VideoEncoderSettingsType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/VideoEncoderSettingsType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/CropType.h"
#include "../../../include/asb_uci/type/ForeignKeyType.h"
#include "../../../include/asb_uci/type/UnsignedIntegerMinMaxType.h"
#include "../../../include/asb_uci/type/VideoBlockSizeEnum.h"
#include "../../../include/asb_uci/type/VideoChromaSubsampleEnum.h"
#include "../../../include/asb_uci/type/VideoEncoderCompressionModeEnum.h"
#include "../../../include/asb_uci/type/VisibleString32Type.h"
#include "../../../include/asb_uci/util/DerivedTypesDeserializer.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/CropType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ForeignKeyType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/FrequencyType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PercentType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/UnsignedIntegerMinMaxType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/VideoBlockSizeEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/VideoChromaSubsampleEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/VideoEncoderCompressionModeEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/VideoEncoderSettingsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/VisibleString32Type.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

VideoEncoderSettingsType::VideoEncoderSettingsType() = default;

VideoEncoderSettingsType::~VideoEncoderSettingsType() = default;

void VideoEncoderSettingsType::copy(const uci::type::VideoEncoderSettingsType& accessor) {
  copyImpl(accessor, false);
}

void VideoEncoderSettingsType::copyImpl(const uci::type::VideoEncoderSettingsType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const VideoEncoderSettingsType&>(accessor);
    if (accessorImpl.encodingType_Accessor) {
      setEncodingType(*(accessorImpl.encodingType_Accessor));
    } else {
      encodingType_Accessor.reset();
    }
    if (accessorImpl.profile_Accessor) {
      setProfile(*(accessorImpl.profile_Accessor));
    } else {
      profile_Accessor.reset();
    }
    if (accessorImpl.encodingBlocks_Accessor) {
      setEncodingBlocks(*(accessorImpl.encodingBlocks_Accessor));
    } else {
      encodingBlocks_Accessor.reset();
    }
    if (accessorImpl.chromaSubsample_Accessor) {
      setChromaSubsample(*(accessorImpl.chromaSubsample_Accessor));
    } else {
      chromaSubsample_Accessor.reset();
    }
    if (accessorImpl.hasFrameRate()) {
      setFrameRate(accessorImpl.getFrameRate());
    } else {
      clearFrameRate();
    }
    setHDR(accessorImpl.hDR_Accessor);
    if (accessorImpl.hasBitRate()) {
      setBitRate(accessorImpl.getBitRate());
    } else {
      clearBitRate();
    }
    setEmbedKLV_Metadata(accessorImpl.embedKLV_Metadata_Accessor);
    setEmbedPlatformMetadata(accessorImpl.embedPlatformMetadata_Accessor);
    if (accessorImpl.hasSkipFrames()) {
      setSkipFrames(accessorImpl.getSkipFrames());
    } else {
      clearSkipFrames();
    }
    if (accessorImpl.quantMinMax_Accessor) {
      setQuantMinMax(*(accessorImpl.quantMinMax_Accessor));
    } else {
      quantMinMax_Accessor.reset();
    }
    if (accessorImpl.compressionMode_Accessor) {
      setCompressionMode(*(accessorImpl.compressionMode_Accessor));
    } else {
      compressionMode_Accessor.reset();
    }
    if (accessorImpl.hasB_Frames()) {
      setB_Frames(accessorImpl.getB_Frames());
    } else {
      clearB_Frames();
    }
    if (accessorImpl.hasGOP_Size()) {
      setGOP_Size(accessorImpl.getGOP_Size());
    } else {
      clearGOP_Size();
    }
    setIntraRefreshMode(accessorImpl.intraRefreshMode_Accessor);
    if (accessorImpl.hasIntraRefreshPercentage()) {
      setIntraRefreshPercentage(accessorImpl.getIntraRefreshPercentage());
    } else {
      clearIntraRefreshPercentage();
    }
    setColorBitDepth(accessorImpl.colorBitDepth_Accessor);
    if (accessorImpl.crop_Accessor) {
      setCrop(*(accessorImpl.crop_Accessor));
    } else {
      crop_Accessor.reset();
    }
    if (accessorImpl.hasScaling()) {
      setScaling(accessorImpl.getScaling());
    } else {
      clearScaling();
    }
  }
}

void VideoEncoderSettingsType::reset() noexcept {
  encodingType_Accessor.reset();
  profile_Accessor.reset();
  encodingBlocks_Accessor.reset();
  chromaSubsample_Accessor.reset();
  clearFrameRate();
  hDR_Accessor = false;
  clearBitRate();
  embedKLV_Metadata_Accessor = false;
  embedPlatformMetadata_Accessor = false;
  clearSkipFrames();
  quantMinMax_Accessor.reset();
  compressionMode_Accessor.reset();
  clearB_Frames();
  clearGOP_Size();
  intraRefreshMode_Accessor = false;
  clearIntraRefreshPercentage();
  colorBitDepth_Accessor = 0;
  crop_Accessor.reset();
  clearScaling();
}

uci::type::ForeignKeyType& VideoEncoderSettingsType::getEncodingType_() const {
  if (encodingType_Accessor) {
    return *encodingType_Accessor;
  }
  throw uci::base::UCIException("Error in getEncodingType(): An attempt was made to get an optional field that was not enabled, call hasEncodingType() to determine if it is safe to call getEncodingType()");
}

const uci::type::ForeignKeyType& VideoEncoderSettingsType::getEncodingType() const {
  return getEncodingType_();
}

uci::type::ForeignKeyType& VideoEncoderSettingsType::getEncodingType() {
  return getEncodingType_();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setEncodingType(const uci::type::ForeignKeyType& accessor) {
  enableEncodingType(accessor.getAccessorType());
  if (&accessor != encodingType_Accessor.get()) {
    encodingType_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool VideoEncoderSettingsType::hasEncodingType() const noexcept {
  return static_cast<bool>(encodingType_Accessor);
}

uci::type::ForeignKeyType& VideoEncoderSettingsType::enableEncodingType(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::foreignKeyType : type};
  if ((!encodingType_Accessor) || (encodingType_Accessor->getAccessorType() != requestedType)) {
    encodingType_Accessor = ForeignKeyType::create(requestedType);
    if (!encodingType_Accessor) {
      throw uci::base::UCIException("Error in enableEncodingType(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *encodingType_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearEncodingType() noexcept {
  encodingType_Accessor.reset();
  return *this;
}

uci::type::VisibleString32Type& VideoEncoderSettingsType::getProfile_() const {
  if (profile_Accessor) {
    return *profile_Accessor;
  }
  throw uci::base::UCIException("Error in getProfile(): An attempt was made to get an optional field that was not enabled, call hasProfile() to determine if it is safe to call getProfile()");
}

const uci::type::VisibleString32Type& VideoEncoderSettingsType::getProfile() const {
  return getProfile_();
}

uci::type::VisibleString32Type& VideoEncoderSettingsType::getProfile() {
  return getProfile_();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setProfile(const uci::type::VisibleString32Type& value) {
  return setProfile(value.c_str());
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setProfile(const std::string& value) {
  return setProfile(value.c_str());
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setProfile(const char* value) {
  enableProfile().setStringValue(value);
  return *this;
}

bool VideoEncoderSettingsType::hasProfile() const noexcept {
  return static_cast<bool>(profile_Accessor);
}

uci::type::VisibleString32Type& VideoEncoderSettingsType::enableProfile(uci::base::accessorType::AccessorType type) {
  if (!profile_Accessor) {
    profile_Accessor = VisibleString32Type::create(type);
  }
  return *profile_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearProfile() noexcept {
  profile_Accessor.reset();
  return *this;
}

uci::type::VideoBlockSizeEnum& VideoEncoderSettingsType::getEncodingBlocks_() const {
  if (encodingBlocks_Accessor) {
    return *encodingBlocks_Accessor;
  }
  throw uci::base::UCIException("Error in getEncodingBlocks(): An attempt was made to get an optional field that was not enabled, call hasEncodingBlocks() to determine if it is safe to call getEncodingBlocks()");
}

const uci::type::VideoBlockSizeEnum& VideoEncoderSettingsType::getEncodingBlocks() const {
  return getEncodingBlocks_();
}

uci::type::VideoBlockSizeEnum& VideoEncoderSettingsType::getEncodingBlocks() {
  return getEncodingBlocks_();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setEncodingBlocks(const uci::type::VideoBlockSizeEnum& accessor) {
  enableEncodingBlocks();
  if (&accessor != encodingBlocks_Accessor.get()) {
    encodingBlocks_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setEncodingBlocks(const uci::type::VideoBlockSizeEnum::EnumerationItem value) {
  enableEncodingBlocks().setValue(value);
  return *this;
}

bool VideoEncoderSettingsType::hasEncodingBlocks() const noexcept {
  return static_cast<bool>(encodingBlocks_Accessor);
}

uci::type::VideoBlockSizeEnum& VideoEncoderSettingsType::enableEncodingBlocks(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::videoBlockSizeEnum : type};
  if ((!encodingBlocks_Accessor) || (encodingBlocks_Accessor->getAccessorType() != requestedType)) {
    encodingBlocks_Accessor = VideoBlockSizeEnum::create(requestedType);
    if (!encodingBlocks_Accessor) {
      throw uci::base::UCIException("Error in enableEncodingBlocks(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *encodingBlocks_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearEncodingBlocks() noexcept {
  encodingBlocks_Accessor.reset();
  return *this;
}

uci::type::VideoChromaSubsampleEnum& VideoEncoderSettingsType::getChromaSubsample_() const {
  if (chromaSubsample_Accessor) {
    return *chromaSubsample_Accessor;
  }
  throw uci::base::UCIException("Error in getChromaSubsample(): An attempt was made to get an optional field that was not enabled, call hasChromaSubsample() to determine if it is safe to call getChromaSubsample()");
}

const uci::type::VideoChromaSubsampleEnum& VideoEncoderSettingsType::getChromaSubsample() const {
  return getChromaSubsample_();
}

uci::type::VideoChromaSubsampleEnum& VideoEncoderSettingsType::getChromaSubsample() {
  return getChromaSubsample_();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setChromaSubsample(const uci::type::VideoChromaSubsampleEnum& accessor) {
  enableChromaSubsample();
  if (&accessor != chromaSubsample_Accessor.get()) {
    chromaSubsample_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setChromaSubsample(const uci::type::VideoChromaSubsampleEnum::EnumerationItem value) {
  enableChromaSubsample().setValue(value);
  return *this;
}

bool VideoEncoderSettingsType::hasChromaSubsample() const noexcept {
  return static_cast<bool>(chromaSubsample_Accessor);
}

uci::type::VideoChromaSubsampleEnum& VideoEncoderSettingsType::enableChromaSubsample(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::videoChromaSubsampleEnum : type};
  if ((!chromaSubsample_Accessor) || (chromaSubsample_Accessor->getAccessorType() != requestedType)) {
    chromaSubsample_Accessor = VideoChromaSubsampleEnum::create(requestedType);
    if (!chromaSubsample_Accessor) {
      throw uci::base::UCIException("Error in enableChromaSubsample(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *chromaSubsample_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearChromaSubsample() noexcept {
  chromaSubsample_Accessor.reset();
  return *this;
}

uci::type::FrequencyTypeValue VideoEncoderSettingsType::getFrameRate() const {
  if (frameRate_Accessor) {
    return *frameRate_Accessor;
  }
  throw uci::base::UCIException("Error in getFrameRate(): An attempt was made to get an optional field that was not enabled, call hasFrameRate() to determine if it is safe to call getFrameRate()");
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setFrameRate(uci::type::FrequencyTypeValue value) {
  frameRate_Accessor = value;
  return *this;
}

bool VideoEncoderSettingsType::hasFrameRate() const noexcept {
  return frameRate_Accessor.has_value();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearFrameRate() noexcept {
  frameRate_Accessor.reset();
  return *this;
}

xs::Boolean VideoEncoderSettingsType::getHDR() const {
  return hDR_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setHDR(xs::Boolean value) {
  hDR_Accessor = value;
  return *this;
}


xs::UnsignedInt VideoEncoderSettingsType::getBitRate() const {
  if (bitRate_Accessor) {
    return *bitRate_Accessor;
  }
  throw uci::base::UCIException("Error in getBitRate(): An attempt was made to get an optional field that was not enabled, call hasBitRate() to determine if it is safe to call getBitRate()");
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setBitRate(xs::UnsignedInt value) {
  bitRate_Accessor = value;
  return *this;
}

bool VideoEncoderSettingsType::hasBitRate() const noexcept {
  return bitRate_Accessor.has_value();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearBitRate() noexcept {
  bitRate_Accessor.reset();
  return *this;
}

xs::Boolean VideoEncoderSettingsType::getEmbedKLV_Metadata() const {
  return embedKLV_Metadata_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setEmbedKLV_Metadata(xs::Boolean value) {
  embedKLV_Metadata_Accessor = value;
  return *this;
}


xs::Boolean VideoEncoderSettingsType::getEmbedPlatformMetadata() const {
  return embedPlatformMetadata_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setEmbedPlatformMetadata(xs::Boolean value) {
  embedPlatformMetadata_Accessor = value;
  return *this;
}


xs::UnsignedByte VideoEncoderSettingsType::getSkipFrames() const {
  if (skipFrames_Accessor) {
    return *skipFrames_Accessor;
  }
  throw uci::base::UCIException("Error in getSkipFrames(): An attempt was made to get an optional field that was not enabled, call hasSkipFrames() to determine if it is safe to call getSkipFrames()");
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setSkipFrames(xs::UnsignedByte value) {
  skipFrames_Accessor = value;
  return *this;
}

bool VideoEncoderSettingsType::hasSkipFrames() const noexcept {
  return skipFrames_Accessor.has_value();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearSkipFrames() noexcept {
  skipFrames_Accessor.reset();
  return *this;
}

uci::type::UnsignedIntegerMinMaxType& VideoEncoderSettingsType::getQuantMinMax_() const {
  if (quantMinMax_Accessor) {
    return *quantMinMax_Accessor;
  }
  throw uci::base::UCIException("Error in getQuantMinMax(): An attempt was made to get an optional field that was not enabled, call hasQuantMinMax() to determine if it is safe to call getQuantMinMax()");
}

const uci::type::UnsignedIntegerMinMaxType& VideoEncoderSettingsType::getQuantMinMax() const {
  return getQuantMinMax_();
}

uci::type::UnsignedIntegerMinMaxType& VideoEncoderSettingsType::getQuantMinMax() {
  return getQuantMinMax_();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setQuantMinMax(const uci::type::UnsignedIntegerMinMaxType& accessor) {
  enableQuantMinMax(accessor.getAccessorType());
  if (&accessor != quantMinMax_Accessor.get()) {
    quantMinMax_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool VideoEncoderSettingsType::hasQuantMinMax() const noexcept {
  return static_cast<bool>(quantMinMax_Accessor);
}

uci::type::UnsignedIntegerMinMaxType& VideoEncoderSettingsType::enableQuantMinMax(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::unsignedIntegerMinMaxType : type};
  if ((!quantMinMax_Accessor) || (quantMinMax_Accessor->getAccessorType() != requestedType)) {
    quantMinMax_Accessor = UnsignedIntegerMinMaxType::create(requestedType);
    if (!quantMinMax_Accessor) {
      throw uci::base::UCIException("Error in enableQuantMinMax(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *quantMinMax_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearQuantMinMax() noexcept {
  quantMinMax_Accessor.reset();
  return *this;
}

uci::type::VideoEncoderCompressionModeEnum& VideoEncoderSettingsType::getCompressionMode_() const {
  if (compressionMode_Accessor) {
    return *compressionMode_Accessor;
  }
  throw uci::base::UCIException("Error in getCompressionMode(): An attempt was made to get an optional field that was not enabled, call hasCompressionMode() to determine if it is safe to call getCompressionMode()");
}

const uci::type::VideoEncoderCompressionModeEnum& VideoEncoderSettingsType::getCompressionMode() const {
  return getCompressionMode_();
}

uci::type::VideoEncoderCompressionModeEnum& VideoEncoderSettingsType::getCompressionMode() {
  return getCompressionMode_();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setCompressionMode(const uci::type::VideoEncoderCompressionModeEnum& accessor) {
  enableCompressionMode();
  if (&accessor != compressionMode_Accessor.get()) {
    compressionMode_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setCompressionMode(const uci::type::VideoEncoderCompressionModeEnum::EnumerationItem value) {
  enableCompressionMode().setValue(value);
  return *this;
}

bool VideoEncoderSettingsType::hasCompressionMode() const noexcept {
  return static_cast<bool>(compressionMode_Accessor);
}

uci::type::VideoEncoderCompressionModeEnum& VideoEncoderSettingsType::enableCompressionMode(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::videoEncoderCompressionModeEnum : type};
  if ((!compressionMode_Accessor) || (compressionMode_Accessor->getAccessorType() != requestedType)) {
    compressionMode_Accessor = VideoEncoderCompressionModeEnum::create(requestedType);
    if (!compressionMode_Accessor) {
      throw uci::base::UCIException("Error in enableCompressionMode(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *compressionMode_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearCompressionMode() noexcept {
  compressionMode_Accessor.reset();
  return *this;
}

xs::UnsignedByte VideoEncoderSettingsType::getB_Frames() const {
  if (b_Frames_Accessor) {
    return *b_Frames_Accessor;
  }
  throw uci::base::UCIException("Error in getB_Frames(): An attempt was made to get an optional field that was not enabled, call hasB_Frames() to determine if it is safe to call getB_Frames()");
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setB_Frames(xs::UnsignedByte value) {
  b_Frames_Accessor = value;
  return *this;
}

bool VideoEncoderSettingsType::hasB_Frames() const noexcept {
  return b_Frames_Accessor.has_value();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearB_Frames() noexcept {
  b_Frames_Accessor.reset();
  return *this;
}

xs::UnsignedShort VideoEncoderSettingsType::getGOP_Size() const {
  if (gOP_Size_Accessor) {
    return *gOP_Size_Accessor;
  }
  throw uci::base::UCIException("Error in getGOP_Size(): An attempt was made to get an optional field that was not enabled, call hasGOP_Size() to determine if it is safe to call getGOP_Size()");
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setGOP_Size(xs::UnsignedShort value) {
  gOP_Size_Accessor = value;
  return *this;
}

bool VideoEncoderSettingsType::hasGOP_Size() const noexcept {
  return gOP_Size_Accessor.has_value();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearGOP_Size() noexcept {
  gOP_Size_Accessor.reset();
  return *this;
}

xs::Boolean VideoEncoderSettingsType::getIntraRefreshMode() const {
  return intraRefreshMode_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setIntraRefreshMode(xs::Boolean value) {
  intraRefreshMode_Accessor = value;
  return *this;
}


uci::type::PercentTypeValue VideoEncoderSettingsType::getIntraRefreshPercentage() const {
  if (intraRefreshPercentage_Accessor) {
    return *intraRefreshPercentage_Accessor;
  }
  throw uci::base::UCIException("Error in getIntraRefreshPercentage(): An attempt was made to get an optional field that was not enabled, call hasIntraRefreshPercentage() to determine if it is safe to call getIntraRefreshPercentage()");
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setIntraRefreshPercentage(uci::type::PercentTypeValue value) {
  intraRefreshPercentage_Accessor = value;
  return *this;
}

bool VideoEncoderSettingsType::hasIntraRefreshPercentage() const noexcept {
  return intraRefreshPercentage_Accessor.has_value();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearIntraRefreshPercentage() noexcept {
  intraRefreshPercentage_Accessor.reset();
  return *this;
}

xs::UnsignedByte VideoEncoderSettingsType::getColorBitDepth() const {
  return colorBitDepth_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setColorBitDepth(xs::UnsignedByte value) {
  colorBitDepth_Accessor = value;
  return *this;
}


uci::type::CropType& VideoEncoderSettingsType::getCrop_() const {
  if (crop_Accessor) {
    return *crop_Accessor;
  }
  throw uci::base::UCIException("Error in getCrop(): An attempt was made to get an optional field that was not enabled, call hasCrop() to determine if it is safe to call getCrop()");
}

const uci::type::CropType& VideoEncoderSettingsType::getCrop() const {
  return getCrop_();
}

uci::type::CropType& VideoEncoderSettingsType::getCrop() {
  return getCrop_();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setCrop(const uci::type::CropType& accessor) {
  enableCrop();
  if (&accessor != crop_Accessor.get()) {
    crop_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool VideoEncoderSettingsType::hasCrop() const noexcept {
  return static_cast<bool>(crop_Accessor);
}

uci::type::CropType& VideoEncoderSettingsType::enableCrop(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::cropType : type};
  if ((!crop_Accessor) || (crop_Accessor->getAccessorType() != requestedType)) {
    crop_Accessor = CropType::create(requestedType);
    if (!crop_Accessor) {
      throw uci::base::UCIException("Error in enableCrop(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *crop_Accessor;
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearCrop() noexcept {
  crop_Accessor.reset();
  return *this;
}

uci::type::PercentTypeValue VideoEncoderSettingsType::getScaling() const {
  if (scaling_Accessor) {
    return *scaling_Accessor;
  }
  throw uci::base::UCIException("Error in getScaling(): An attempt was made to get an optional field that was not enabled, call hasScaling() to determine if it is safe to call getScaling()");
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::setScaling(uci::type::PercentTypeValue value) {
  scaling_Accessor = value;
  return *this;
}

bool VideoEncoderSettingsType::hasScaling() const noexcept {
  return scaling_Accessor.has_value();
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::clearScaling() noexcept {
  scaling_Accessor.reset();
  return *this;
}

std::unique_ptr<VideoEncoderSettingsType> VideoEncoderSettingsType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::videoEncoderSettingsType : type};
  return (requestedType == uci::type::accessorType::videoEncoderSettingsType) ? boost::make_unique<VideoEncoderSettingsType>() : nullptr;
}

/**  */
namespace VideoEncoderSettingsType_Names {

constexpr const char* Extern_Type_Name{"VideoEncoderSettingsType"};
constexpr const char* EncodingType_Name{"EncodingType"};
constexpr const char* Profile_Name{"Profile"};
constexpr const char* EncodingBlocks_Name{"EncodingBlocks"};
constexpr const char* ChromaSubsample_Name{"ChromaSubsample"};
constexpr const char* FrameRate_Name{"FrameRate"};
constexpr const char* HDR_Name{"HDR"};
constexpr const char* BitRate_Name{"BitRate"};
constexpr const char* EmbedKLV_Metadata_Name{"EmbedKLV_Metadata"};
constexpr const char* EmbedPlatformMetadata_Name{"EmbedPlatformMetadata"};
constexpr const char* SkipFrames_Name{"SkipFrames"};
constexpr const char* QuantMinMax_Name{"QuantMinMax"};
constexpr const char* CompressionMode_Name{"CompressionMode"};
constexpr const char* B_Frames_Name{"B_Frames"};
constexpr const char* GOP_Size_Name{"GOP_Size"};
constexpr const char* IntraRefreshMode_Name{"IntraRefreshMode"};
constexpr const char* IntraRefreshPercentage_Name{"IntraRefreshPercentage"};
constexpr const char* ColorBitDepth_Name{"ColorBitDepth"};
constexpr const char* Crop_Name{"Crop"};
constexpr const char* Scaling_Name{"Scaling"};

} // namespace VideoEncoderSettingsType_Names

void VideoEncoderSettingsType::deserialize(const boost::property_tree::ptree& propTree, uci::type::VideoEncoderSettingsType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = VideoEncoderSettingsType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::EncodingType_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableEncodingType(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::Profile_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setProfile(*value);
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::EncodingBlocks_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableEncodingBlocks().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::ChromaSubsample_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableChromaSubsample().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::FrameRate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFrameRate(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::HDR_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setHDR(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::BitRate_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setBitRate(asb_uci::util::SerializationHelpers::deserializeUnsignedInt(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::EmbedKLV_Metadata_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setEmbedKLV_Metadata(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::EmbedPlatformMetadata_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setEmbedPlatformMetadata(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::SkipFrames_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setSkipFrames(asb_uci::util::SerializationHelpers::deserializeUnsignedByte(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::QuantMinMax_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableQuantMinMax(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::CompressionMode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableCompressionMode().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::B_Frames_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setB_Frames(asb_uci::util::SerializationHelpers::deserializeUnsignedByte(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::GOP_Size_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setGOP_Size(asb_uci::util::SerializationHelpers::deserializeUnsignedShort(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::IntraRefreshMode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setIntraRefreshMode(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::IntraRefreshPercentage_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setIntraRefreshPercentage(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::ColorBitDepth_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setColorBitDepth(asb_uci::util::SerializationHelpers::deserializeUnsignedByte(*value));
      }
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::Crop_Name) {
      CropType::deserialize(valueType.second, accessor.enableCrop(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + VideoEncoderSettingsType_Names::Scaling_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setScaling(asb_uci::util::SerializationHelpers::deserializeDouble(*value));
      }
    }
  }
}

std::string VideoEncoderSettingsType::serialize(const uci::type::VideoEncoderSettingsType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? VideoEncoderSettingsType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, VideoEncoderSettingsType_Names::Extern_Type_Name);
  }
  if (accessor.hasEncodingType()) {
    ForeignKeyType::serialize(accessor.getEncodingType(), node, VideoEncoderSettingsType_Names::EncodingType_Name);
  }
  if (accessor.hasProfile()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getProfile(), node, VideoEncoderSettingsType_Names::Profile_Name);
  }
  if (accessor.hasEncodingBlocks()) {
    VideoBlockSizeEnum::serialize(accessor.getEncodingBlocks(), node, VideoEncoderSettingsType_Names::EncodingBlocks_Name, false);
  }
  if (accessor.hasChromaSubsample()) {
    VideoChromaSubsampleEnum::serialize(accessor.getChromaSubsample(), node, VideoEncoderSettingsType_Names::ChromaSubsample_Name, false);
  }
  if (accessor.hasFrameRate()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getFrameRate(), node, VideoEncoderSettingsType_Names::FrameRate_Name);
  }
  asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getHDR(), node, VideoEncoderSettingsType_Names::HDR_Name);
  if (accessor.hasBitRate()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedInt(accessor.getBitRate(), node, VideoEncoderSettingsType_Names::BitRate_Name);
  }
  asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getEmbedKLV_Metadata(), node, VideoEncoderSettingsType_Names::EmbedKLV_Metadata_Name);
  asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getEmbedPlatformMetadata(), node, VideoEncoderSettingsType_Names::EmbedPlatformMetadata_Name);
  if (accessor.hasSkipFrames()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedByte(accessor.getSkipFrames(), node, VideoEncoderSettingsType_Names::SkipFrames_Name);
  }
  if (accessor.hasQuantMinMax()) {
    UnsignedIntegerMinMaxType::serialize(accessor.getQuantMinMax(), node, VideoEncoderSettingsType_Names::QuantMinMax_Name);
  }
  if (accessor.hasCompressionMode()) {
    VideoEncoderCompressionModeEnum::serialize(accessor.getCompressionMode(), node, VideoEncoderSettingsType_Names::CompressionMode_Name, false);
  }
  if (accessor.hasB_Frames()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedByte(accessor.getB_Frames(), node, VideoEncoderSettingsType_Names::B_Frames_Name);
  }
  if (accessor.hasGOP_Size()) {
    asb_uci::util::SerializationHelpers::serializeUnsignedShort(accessor.getGOP_Size(), node, VideoEncoderSettingsType_Names::GOP_Size_Name);
  }
  asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getIntraRefreshMode(), node, VideoEncoderSettingsType_Names::IntraRefreshMode_Name);
  if (accessor.hasIntraRefreshPercentage()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getIntraRefreshPercentage(), node, VideoEncoderSettingsType_Names::IntraRefreshPercentage_Name);
  }
  asb_uci::util::SerializationHelpers::serializeUnsignedByte(accessor.getColorBitDepth(), node, VideoEncoderSettingsType_Names::ColorBitDepth_Name);
  if (accessor.hasCrop()) {
    CropType::serialize(accessor.getCrop(), node, VideoEncoderSettingsType_Names::Crop_Name);
  }
  if (accessor.hasScaling()) {
    asb_uci::util::SerializationHelpers::serializeDouble(accessor.getScaling(), node, VideoEncoderSettingsType_Names::Scaling_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::VideoEncoderSettingsType>().release());
}

uci::type::VideoEncoderSettingsType& VideoEncoderSettingsType::create(const uci::type::VideoEncoderSettingsType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::VideoEncoderSettingsType> newAccessor{boost::make_unique<asb_uci::type::VideoEncoderSettingsType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void VideoEncoderSettingsType::destroy(uci::type::VideoEncoderSettingsType& accessor) {
  delete dynamic_cast<asb_uci::type::VideoEncoderSettingsType*>(&accessor);
}

} // namespace type

} // namespace uci

