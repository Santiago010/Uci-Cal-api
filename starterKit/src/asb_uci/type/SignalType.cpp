/** @file SignalType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/SignalType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/ActivityByType.h"
#include "../../../include/asb_uci/type/EmitterFunctionType.h"
#include "../../../include/asb_uci/type/EmitterUrgencyEnum.h"
#include "../../../include/asb_uci/type/EmptyType.h"
#include "../../../include/asb_uci/type/ForeignKeyType.h"
#include "../../../include/asb_uci/type/LockIndicatorEnum.h"
#include "../../../include/asb_uci/type/MeasurementQualityEnum.h"
#include "../../../include/asb_uci/type/MobilityEnum.h"
#include "../../../include/asb_uci/type/ModulationEnum.h"
#include "../../../include/asb_uci/type/ModulationParameterType.h"
#include "../../../include/asb_uci/type/PulseDataID_Type.h"
#include "../../../include/asb_uci/type/SignalEmitterKinematicsType.h"
#include "../../../include/asb_uci/type/SignalID_Type.h"
#include "../../../include/asb_uci/type/SignalIdentityType.h"
#include "../../../include/asb_uci/type/SignalNavDataType.h"
#include "../../../include/asb_uci/type/SignalParametricsType.h"
#include "../../../include/asb_uci/type/SignalRemoveInfoType.h"
#include "../../../include/asb_uci/type/SignalReportStateEnum.h"
#include "../../../include/asb_uci/type/SignalSourceType.h"
#include "../../../include/asb_uci/util/DerivedTypesDeserializer.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ActivityByType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/DateTimeType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/EmitterFunctionType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/EmitterUrgencyEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/EmptyType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ForeignKeyType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/LockIndicatorEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MeasurementQualityEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MobilityEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ModulationEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ModulationParameterType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/PulseDataID_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalEmitterKinematicsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalID_Type.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalIdentityType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalNavDataType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalParametricsType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalRemoveInfoType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalReportStateEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalSourceType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

SignalType::SignalType()
  : signalID_Accessor{boost::make_unique<SignalID_Type>()},
    signalState_Accessor{boost::make_unique<SignalReportStateEnum>()},
    associatedPulseDataID_Accessor{boost::make_unique<AssociatedPulseDataID>(0, SIZE_MAX)},
    collectorKinematics_Accessor{boost::make_unique<CollectorKinematics>(0, SIZE_MAX)},
    modulation_Accessor{boost::make_unique<Modulation>(0, 62)},
    modulationParameter_Accessor{boost::make_unique<ModulationParameter>(0, SIZE_MAX)} {
}

SignalType::~SignalType() = default;

void SignalType::copy(const uci::type::SignalType& accessor) {
  copyImpl(accessor, false);
}

void SignalType::copyImpl(const uci::type::SignalType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const SignalType&>(accessor);
    setSignalID(*(accessorImpl.signalID_Accessor));
    setSignalState(*(accessorImpl.signalState_Accessor));
    if (accessorImpl.source_Accessor) {
      setSource(*(accessorImpl.source_Accessor));
    } else {
      source_Accessor.reset();
    }
    if (accessorImpl.localTrackIdentifier_Accessor) {
      setLocalTrackIdentifier(*(accessorImpl.localTrackIdentifier_Accessor));
    } else {
      localTrackIdentifier_Accessor.reset();
    }
    setAssociatedPulseDataID(*(accessorImpl.associatedPulseDataID_Accessor));
    if (accessorImpl.hasInitialDetectionTimestamp()) {
      setInitialDetectionTimestamp(accessorImpl.getInitialDetectionTimestamp());
    } else {
      clearInitialDetectionTimestamp();
    }
    if (accessorImpl.hasLatestDetectionTimestamp()) {
      setLatestDetectionTimestamp(accessorImpl.getLatestDetectionTimestamp());
    } else {
      clearLatestDetectionTimestamp();
    }
    if (accessorImpl.timestampQuality_Accessor) {
      setTimestampQuality(*(accessorImpl.timestampQuality_Accessor));
    } else {
      timestampQuality_Accessor.reset();
    }
    if (accessorImpl.parametrics_Accessor) {
      setParametrics(*(accessorImpl.parametrics_Accessor));
    } else {
      parametrics_Accessor.reset();
    }
    if (accessorImpl.emitterFunction_Accessor) {
      setEmitterFunction(*(accessorImpl.emitterFunction_Accessor));
    } else {
      emitterFunction_Accessor.reset();
    }
    if (accessorImpl.emitterIdentity_Accessor) {
      setEmitterIdentity(*(accessorImpl.emitterIdentity_Accessor));
    } else {
      emitterIdentity_Accessor.reset();
    }
    if (accessorImpl.emitterKinematics_Accessor) {
      setEmitterKinematics(*(accessorImpl.emitterKinematics_Accessor));
    } else {
      emitterKinematics_Accessor.reset();
    }
    setCollectorKinematics(*(accessorImpl.collectorKinematics_Accessor));
    if (accessorImpl.wartimeReserveMode_Accessor) {
      setWartimeReserveMode(*(accessorImpl.wartimeReserveMode_Accessor));
    } else {
      wartimeReserveMode_Accessor.reset();
    }
    if (accessorImpl.lockIndicator_Accessor) {
      setLockIndicator(*(accessorImpl.lockIndicator_Accessor));
    } else {
      lockIndicator_Accessor.reset();
    }
    if (accessorImpl.activityBy_Accessor) {
      setActivityBy(*(accessorImpl.activityBy_Accessor));
    } else {
      activityBy_Accessor.reset();
    }
    if (accessorImpl.removeInfo_Accessor) {
      setRemoveInfo(*(accessorImpl.removeInfo_Accessor));
    } else {
      removeInfo_Accessor.reset();
    }
    setModulation(*(accessorImpl.modulation_Accessor));
    setModulationParameter(*(accessorImpl.modulationParameter_Accessor));
    if (accessorImpl.urgency_Accessor) {
      setUrgency(*(accessorImpl.urgency_Accessor));
    } else {
      urgency_Accessor.reset();
    }
    if (accessorImpl.mobility_Accessor) {
      setMobility(*(accessorImpl.mobility_Accessor));
    } else {
      mobility_Accessor.reset();
    }
  }
}

void SignalType::reset() noexcept {
  signalID_Accessor->reset();
  signalState_Accessor->reset();
  source_Accessor.reset();
  localTrackIdentifier_Accessor.reset();
  associatedPulseDataID_Accessor->reset();
  clearInitialDetectionTimestamp();
  clearLatestDetectionTimestamp();
  timestampQuality_Accessor.reset();
  parametrics_Accessor.reset();
  emitterFunction_Accessor.reset();
  emitterIdentity_Accessor.reset();
  emitterKinematics_Accessor.reset();
  collectorKinematics_Accessor->reset();
  wartimeReserveMode_Accessor.reset();
  lockIndicator_Accessor.reset();
  activityBy_Accessor.reset();
  removeInfo_Accessor.reset();
  modulation_Accessor->reset();
  modulationParameter_Accessor->reset();
  urgency_Accessor.reset();
  mobility_Accessor.reset();
}

const uci::type::SignalID_Type& SignalType::getSignalID() const {
  return *signalID_Accessor;
}

uci::type::SignalID_Type& SignalType::getSignalID() {
  return *signalID_Accessor;
}

uci::type::SignalType& SignalType::setSignalID(const uci::type::SignalID_Type& accessor) {
  if (&accessor != signalID_Accessor.get()) {
    signalID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SignalReportStateEnum& SignalType::getSignalState() const {
  return *signalState_Accessor;
}

uci::type::SignalReportStateEnum& SignalType::getSignalState() {
  return *signalState_Accessor;
}

uci::type::SignalType& SignalType::setSignalState(const uci::type::SignalReportStateEnum& accessor) {
  if (&accessor != signalState_Accessor.get()) {
    signalState_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalType& SignalType::setSignalState(uci::type::SignalReportStateEnum::EnumerationItem value) {
  signalState_Accessor->setValue(value);
  return *this;
}


uci::type::SignalSourceType& SignalType::getSource_() const {
  if (source_Accessor) {
    return *source_Accessor;
  }
  throw uci::base::UCIException("Error in getSource(): An attempt was made to get an optional field that was not enabled, call hasSource() to determine if it is safe to call getSource()");
}

const uci::type::SignalSourceType& SignalType::getSource() const {
  return getSource_();
}

uci::type::SignalSourceType& SignalType::getSource() {
  return getSource_();
}

uci::type::SignalType& SignalType::setSource(const uci::type::SignalSourceType& accessor) {
  enableSource();
  if (&accessor != source_Accessor.get()) {
    source_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalType::hasSource() const noexcept {
  return static_cast<bool>(source_Accessor);
}

uci::type::SignalSourceType& SignalType::enableSource(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalSourceType : type};
  if ((!source_Accessor) || (source_Accessor->getAccessorType() != requestedType)) {
    source_Accessor = SignalSourceType::create(requestedType);
    if (!source_Accessor) {
      throw uci::base::UCIException("Error in enableSource(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *source_Accessor;
}

uci::type::SignalType& SignalType::clearSource() noexcept {
  source_Accessor.reset();
  return *this;
}

uci::type::ForeignKeyType& SignalType::getLocalTrackIdentifier_() const {
  if (localTrackIdentifier_Accessor) {
    return *localTrackIdentifier_Accessor;
  }
  throw uci::base::UCIException("Error in getLocalTrackIdentifier(): An attempt was made to get an optional field that was not enabled, call hasLocalTrackIdentifier() to determine if it is safe to call getLocalTrackIdentifier()");
}

const uci::type::ForeignKeyType& SignalType::getLocalTrackIdentifier() const {
  return getLocalTrackIdentifier_();
}

uci::type::ForeignKeyType& SignalType::getLocalTrackIdentifier() {
  return getLocalTrackIdentifier_();
}

uci::type::SignalType& SignalType::setLocalTrackIdentifier(const uci::type::ForeignKeyType& accessor) {
  enableLocalTrackIdentifier(accessor.getAccessorType());
  if (&accessor != localTrackIdentifier_Accessor.get()) {
    localTrackIdentifier_Accessor->copyImpl(accessor, true);
  }
  return *this;
}

bool SignalType::hasLocalTrackIdentifier() const noexcept {
  return static_cast<bool>(localTrackIdentifier_Accessor);
}

uci::type::ForeignKeyType& SignalType::enableLocalTrackIdentifier(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::foreignKeyType : type};
  if ((!localTrackIdentifier_Accessor) || (localTrackIdentifier_Accessor->getAccessorType() != requestedType)) {
    localTrackIdentifier_Accessor = ForeignKeyType::create(requestedType);
    if (!localTrackIdentifier_Accessor) {
      throw uci::base::UCIException("Error in enableLocalTrackIdentifier(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *localTrackIdentifier_Accessor;
}

uci::type::SignalType& SignalType::clearLocalTrackIdentifier() noexcept {
  localTrackIdentifier_Accessor.reset();
  return *this;
}

const uci::type::SignalType::AssociatedPulseDataID& SignalType::getAssociatedPulseDataID() const {
  return *associatedPulseDataID_Accessor;
}

uci::type::SignalType::AssociatedPulseDataID& SignalType::getAssociatedPulseDataID() {
  return *associatedPulseDataID_Accessor;
}

uci::type::SignalType& SignalType::setAssociatedPulseDataID(const uci::type::SignalType::AssociatedPulseDataID& accessor) {
  if (&accessor != associatedPulseDataID_Accessor.get()) {
    associatedPulseDataID_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::DateTimeTypeValue SignalType::getInitialDetectionTimestamp() const {
  if (initialDetectionTimestamp_Accessor) {
    return *initialDetectionTimestamp_Accessor;
  }
  throw uci::base::UCIException("Error in getInitialDetectionTimestamp(): An attempt was made to get an optional field that was not enabled, call hasInitialDetectionTimestamp() to determine if it is safe to call getInitialDetectionTimestamp()");
}

uci::type::SignalType& SignalType::setInitialDetectionTimestamp(uci::type::DateTimeTypeValue value) {
  initialDetectionTimestamp_Accessor = value;
  return *this;
}

bool SignalType::hasInitialDetectionTimestamp() const noexcept {
  return initialDetectionTimestamp_Accessor.has_value();
}

uci::type::SignalType& SignalType::clearInitialDetectionTimestamp() noexcept {
  initialDetectionTimestamp_Accessor.reset();
  return *this;
}

uci::type::DateTimeTypeValue SignalType::getLatestDetectionTimestamp() const {
  if (latestDetectionTimestamp_Accessor) {
    return *latestDetectionTimestamp_Accessor;
  }
  throw uci::base::UCIException("Error in getLatestDetectionTimestamp(): An attempt was made to get an optional field that was not enabled, call hasLatestDetectionTimestamp() to determine if it is safe to call getLatestDetectionTimestamp()");
}

uci::type::SignalType& SignalType::setLatestDetectionTimestamp(uci::type::DateTimeTypeValue value) {
  latestDetectionTimestamp_Accessor = value;
  return *this;
}

bool SignalType::hasLatestDetectionTimestamp() const noexcept {
  return latestDetectionTimestamp_Accessor.has_value();
}

uci::type::SignalType& SignalType::clearLatestDetectionTimestamp() noexcept {
  latestDetectionTimestamp_Accessor.reset();
  return *this;
}

uci::type::MeasurementQualityEnum& SignalType::getTimestampQuality_() const {
  if (timestampQuality_Accessor) {
    return *timestampQuality_Accessor;
  }
  throw uci::base::UCIException("Error in getTimestampQuality(): An attempt was made to get an optional field that was not enabled, call hasTimestampQuality() to determine if it is safe to call getTimestampQuality()");
}

const uci::type::MeasurementQualityEnum& SignalType::getTimestampQuality() const {
  return getTimestampQuality_();
}

uci::type::MeasurementQualityEnum& SignalType::getTimestampQuality() {
  return getTimestampQuality_();
}

uci::type::SignalType& SignalType::setTimestampQuality(const uci::type::MeasurementQualityEnum& accessor) {
  enableTimestampQuality();
  if (&accessor != timestampQuality_Accessor.get()) {
    timestampQuality_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalType& SignalType::setTimestampQuality(const uci::type::MeasurementQualityEnum::EnumerationItem value) {
  enableTimestampQuality().setValue(value);
  return *this;
}

bool SignalType::hasTimestampQuality() const noexcept {
  return static_cast<bool>(timestampQuality_Accessor);
}

uci::type::MeasurementQualityEnum& SignalType::enableTimestampQuality(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::measurementQualityEnum : type};
  if ((!timestampQuality_Accessor) || (timestampQuality_Accessor->getAccessorType() != requestedType)) {
    timestampQuality_Accessor = MeasurementQualityEnum::create(requestedType);
    if (!timestampQuality_Accessor) {
      throw uci::base::UCIException("Error in enableTimestampQuality(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *timestampQuality_Accessor;
}

uci::type::SignalType& SignalType::clearTimestampQuality() noexcept {
  timestampQuality_Accessor.reset();
  return *this;
}

uci::type::SignalParametricsType& SignalType::getParametrics_() const {
  if (parametrics_Accessor) {
    return *parametrics_Accessor;
  }
  throw uci::base::UCIException("Error in getParametrics(): An attempt was made to get an optional field that was not enabled, call hasParametrics() to determine if it is safe to call getParametrics()");
}

const uci::type::SignalParametricsType& SignalType::getParametrics() const {
  return getParametrics_();
}

uci::type::SignalParametricsType& SignalType::getParametrics() {
  return getParametrics_();
}

uci::type::SignalType& SignalType::setParametrics(const uci::type::SignalParametricsType& accessor) {
  enableParametrics();
  if (&accessor != parametrics_Accessor.get()) {
    parametrics_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalType::hasParametrics() const noexcept {
  return static_cast<bool>(parametrics_Accessor);
}

uci::type::SignalParametricsType& SignalType::enableParametrics(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalParametricsType : type};
  if ((!parametrics_Accessor) || (parametrics_Accessor->getAccessorType() != requestedType)) {
    parametrics_Accessor = SignalParametricsType::create(requestedType);
    if (!parametrics_Accessor) {
      throw uci::base::UCIException("Error in enableParametrics(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *parametrics_Accessor;
}

uci::type::SignalType& SignalType::clearParametrics() noexcept {
  parametrics_Accessor.reset();
  return *this;
}

uci::type::EmitterFunctionType& SignalType::getEmitterFunction_() const {
  if (emitterFunction_Accessor) {
    return *emitterFunction_Accessor;
  }
  throw uci::base::UCIException("Error in getEmitterFunction(): An attempt was made to get an optional field that was not enabled, call hasEmitterFunction() to determine if it is safe to call getEmitterFunction()");
}

const uci::type::EmitterFunctionType& SignalType::getEmitterFunction() const {
  return getEmitterFunction_();
}

uci::type::EmitterFunctionType& SignalType::getEmitterFunction() {
  return getEmitterFunction_();
}

uci::type::SignalType& SignalType::setEmitterFunction(const uci::type::EmitterFunctionType& accessor) {
  enableEmitterFunction();
  if (&accessor != emitterFunction_Accessor.get()) {
    emitterFunction_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalType::hasEmitterFunction() const noexcept {
  return static_cast<bool>(emitterFunction_Accessor);
}

uci::type::EmitterFunctionType& SignalType::enableEmitterFunction(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::emitterFunctionType : type};
  if ((!emitterFunction_Accessor) || (emitterFunction_Accessor->getAccessorType() != requestedType)) {
    emitterFunction_Accessor = EmitterFunctionType::create(requestedType);
    if (!emitterFunction_Accessor) {
      throw uci::base::UCIException("Error in enableEmitterFunction(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *emitterFunction_Accessor;
}

uci::type::SignalType& SignalType::clearEmitterFunction() noexcept {
  emitterFunction_Accessor.reset();
  return *this;
}

uci::type::SignalIdentityType& SignalType::getEmitterIdentity_() const {
  if (emitterIdentity_Accessor) {
    return *emitterIdentity_Accessor;
  }
  throw uci::base::UCIException("Error in getEmitterIdentity(): An attempt was made to get an optional field that was not enabled, call hasEmitterIdentity() to determine if it is safe to call getEmitterIdentity()");
}

const uci::type::SignalIdentityType& SignalType::getEmitterIdentity() const {
  return getEmitterIdentity_();
}

uci::type::SignalIdentityType& SignalType::getEmitterIdentity() {
  return getEmitterIdentity_();
}

uci::type::SignalType& SignalType::setEmitterIdentity(const uci::type::SignalIdentityType& accessor) {
  enableEmitterIdentity();
  if (&accessor != emitterIdentity_Accessor.get()) {
    emitterIdentity_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalType::hasEmitterIdentity() const noexcept {
  return static_cast<bool>(emitterIdentity_Accessor);
}

uci::type::SignalIdentityType& SignalType::enableEmitterIdentity(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalIdentityType : type};
  if ((!emitterIdentity_Accessor) || (emitterIdentity_Accessor->getAccessorType() != requestedType)) {
    emitterIdentity_Accessor = SignalIdentityType::create(requestedType);
    if (!emitterIdentity_Accessor) {
      throw uci::base::UCIException("Error in enableEmitterIdentity(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *emitterIdentity_Accessor;
}

uci::type::SignalType& SignalType::clearEmitterIdentity() noexcept {
  emitterIdentity_Accessor.reset();
  return *this;
}

uci::type::SignalEmitterKinematicsType& SignalType::getEmitterKinematics_() const {
  if (emitterKinematics_Accessor) {
    return *emitterKinematics_Accessor;
  }
  throw uci::base::UCIException("Error in getEmitterKinematics(): An attempt was made to get an optional field that was not enabled, call hasEmitterKinematics() to determine if it is safe to call getEmitterKinematics()");
}

const uci::type::SignalEmitterKinematicsType& SignalType::getEmitterKinematics() const {
  return getEmitterKinematics_();
}

uci::type::SignalEmitterKinematicsType& SignalType::getEmitterKinematics() {
  return getEmitterKinematics_();
}

uci::type::SignalType& SignalType::setEmitterKinematics(const uci::type::SignalEmitterKinematicsType& accessor) {
  enableEmitterKinematics();
  if (&accessor != emitterKinematics_Accessor.get()) {
    emitterKinematics_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalType::hasEmitterKinematics() const noexcept {
  return static_cast<bool>(emitterKinematics_Accessor);
}

uci::type::SignalEmitterKinematicsType& SignalType::enableEmitterKinematics(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalEmitterKinematicsType : type};
  if ((!emitterKinematics_Accessor) || (emitterKinematics_Accessor->getAccessorType() != requestedType)) {
    emitterKinematics_Accessor = SignalEmitterKinematicsType::create(requestedType);
    if (!emitterKinematics_Accessor) {
      throw uci::base::UCIException("Error in enableEmitterKinematics(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *emitterKinematics_Accessor;
}

uci::type::SignalType& SignalType::clearEmitterKinematics() noexcept {
  emitterKinematics_Accessor.reset();
  return *this;
}

const uci::type::SignalType::CollectorKinematics& SignalType::getCollectorKinematics() const {
  return *collectorKinematics_Accessor;
}

uci::type::SignalType::CollectorKinematics& SignalType::getCollectorKinematics() {
  return *collectorKinematics_Accessor;
}

uci::type::SignalType& SignalType::setCollectorKinematics(const uci::type::SignalType::CollectorKinematics& accessor) {
  if (&accessor != collectorKinematics_Accessor.get()) {
    collectorKinematics_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::EmptyType& SignalType::getWartimeReserveMode_() const {
  if (wartimeReserveMode_Accessor) {
    return *wartimeReserveMode_Accessor;
  }
  throw uci::base::UCIException("Error in getWartimeReserveMode(): An attempt was made to get an optional field that was not enabled, call hasWartimeReserveMode() to determine if it is safe to call getWartimeReserveMode()");
}

const uci::type::EmptyType& SignalType::getWartimeReserveMode() const {
  return getWartimeReserveMode_();
}

uci::type::EmptyType& SignalType::getWartimeReserveMode() {
  return getWartimeReserveMode_();
}

uci::type::SignalType& SignalType::setWartimeReserveMode(const uci::type::EmptyType& value) {
  return setWartimeReserveMode(value.c_str());
}

uci::type::SignalType& SignalType::setWartimeReserveMode(const std::string& value) {
  return setWartimeReserveMode(value.c_str());
}

uci::type::SignalType& SignalType::setWartimeReserveMode(const char* value) {
  enableWartimeReserveMode().setStringValue(value);
  return *this;
}

bool SignalType::hasWartimeReserveMode() const noexcept {
  return static_cast<bool>(wartimeReserveMode_Accessor);
}

uci::type::EmptyType& SignalType::enableWartimeReserveMode(uci::base::accessorType::AccessorType type) {
  if (!wartimeReserveMode_Accessor) {
    wartimeReserveMode_Accessor = EmptyType::create(type);
  }
  return *wartimeReserveMode_Accessor;
}

uci::type::SignalType& SignalType::clearWartimeReserveMode() noexcept {
  wartimeReserveMode_Accessor.reset();
  return *this;
}

uci::type::LockIndicatorEnum& SignalType::getLockIndicator_() const {
  if (lockIndicator_Accessor) {
    return *lockIndicator_Accessor;
  }
  throw uci::base::UCIException("Error in getLockIndicator(): An attempt was made to get an optional field that was not enabled, call hasLockIndicator() to determine if it is safe to call getLockIndicator()");
}

const uci::type::LockIndicatorEnum& SignalType::getLockIndicator() const {
  return getLockIndicator_();
}

uci::type::LockIndicatorEnum& SignalType::getLockIndicator() {
  return getLockIndicator_();
}

uci::type::SignalType& SignalType::setLockIndicator(const uci::type::LockIndicatorEnum& accessor) {
  enableLockIndicator();
  if (&accessor != lockIndicator_Accessor.get()) {
    lockIndicator_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalType& SignalType::setLockIndicator(const uci::type::LockIndicatorEnum::EnumerationItem value) {
  enableLockIndicator().setValue(value);
  return *this;
}

bool SignalType::hasLockIndicator() const noexcept {
  return static_cast<bool>(lockIndicator_Accessor);
}

uci::type::LockIndicatorEnum& SignalType::enableLockIndicator(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::lockIndicatorEnum : type};
  if ((!lockIndicator_Accessor) || (lockIndicator_Accessor->getAccessorType() != requestedType)) {
    lockIndicator_Accessor = LockIndicatorEnum::create(requestedType);
    if (!lockIndicator_Accessor) {
      throw uci::base::UCIException("Error in enableLockIndicator(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *lockIndicator_Accessor;
}

uci::type::SignalType& SignalType::clearLockIndicator() noexcept {
  lockIndicator_Accessor.reset();
  return *this;
}

uci::type::ActivityByType& SignalType::getActivityBy_() const {
  if (activityBy_Accessor) {
    return *activityBy_Accessor;
  }
  throw uci::base::UCIException("Error in getActivityBy(): An attempt was made to get an optional field that was not enabled, call hasActivityBy() to determine if it is safe to call getActivityBy()");
}

const uci::type::ActivityByType& SignalType::getActivityBy() const {
  return getActivityBy_();
}

uci::type::ActivityByType& SignalType::getActivityBy() {
  return getActivityBy_();
}

uci::type::SignalType& SignalType::setActivityBy(const uci::type::ActivityByType& accessor) {
  enableActivityBy();
  if (&accessor != activityBy_Accessor.get()) {
    activityBy_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalType::hasActivityBy() const noexcept {
  return static_cast<bool>(activityBy_Accessor);
}

uci::type::ActivityByType& SignalType::enableActivityBy(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::activityByType : type};
  if ((!activityBy_Accessor) || (activityBy_Accessor->getAccessorType() != requestedType)) {
    activityBy_Accessor = ActivityByType::create(requestedType);
    if (!activityBy_Accessor) {
      throw uci::base::UCIException("Error in enableActivityBy(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *activityBy_Accessor;
}

uci::type::SignalType& SignalType::clearActivityBy() noexcept {
  activityBy_Accessor.reset();
  return *this;
}

uci::type::SignalRemoveInfoType& SignalType::getRemoveInfo_() const {
  if (removeInfo_Accessor) {
    return *removeInfo_Accessor;
  }
  throw uci::base::UCIException("Error in getRemoveInfo(): An attempt was made to get an optional field that was not enabled, call hasRemoveInfo() to determine if it is safe to call getRemoveInfo()");
}

const uci::type::SignalRemoveInfoType& SignalType::getRemoveInfo() const {
  return getRemoveInfo_();
}

uci::type::SignalRemoveInfoType& SignalType::getRemoveInfo() {
  return getRemoveInfo_();
}

uci::type::SignalType& SignalType::setRemoveInfo(const uci::type::SignalRemoveInfoType& accessor) {
  enableRemoveInfo();
  if (&accessor != removeInfo_Accessor.get()) {
    removeInfo_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalType::hasRemoveInfo() const noexcept {
  return static_cast<bool>(removeInfo_Accessor);
}

uci::type::SignalRemoveInfoType& SignalType::enableRemoveInfo(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalRemoveInfoType : type};
  if ((!removeInfo_Accessor) || (removeInfo_Accessor->getAccessorType() != requestedType)) {
    removeInfo_Accessor = SignalRemoveInfoType::create(requestedType);
    if (!removeInfo_Accessor) {
      throw uci::base::UCIException("Error in enableRemoveInfo(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *removeInfo_Accessor;
}

uci::type::SignalType& SignalType::clearRemoveInfo() noexcept {
  removeInfo_Accessor.reset();
  return *this;
}

const uci::type::SignalType::Modulation& SignalType::getModulation() const {
  return *modulation_Accessor;
}

uci::type::SignalType::Modulation& SignalType::getModulation() {
  return *modulation_Accessor;
}

uci::type::SignalType& SignalType::setModulation(const uci::type::SignalType::Modulation& accessor) {
  if (&accessor != modulation_Accessor.get()) {
    modulation_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

const uci::type::SignalType::ModulationParameter& SignalType::getModulationParameter() const {
  return *modulationParameter_Accessor;
}

uci::type::SignalType::ModulationParameter& SignalType::getModulationParameter() {
  return *modulationParameter_Accessor;
}

uci::type::SignalType& SignalType::setModulationParameter(const uci::type::SignalType::ModulationParameter& accessor) {
  if (&accessor != modulationParameter_Accessor.get()) {
    modulationParameter_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::EmitterUrgencyEnum& SignalType::getUrgency_() const {
  if (urgency_Accessor) {
    return *urgency_Accessor;
  }
  throw uci::base::UCIException("Error in getUrgency(): An attempt was made to get an optional field that was not enabled, call hasUrgency() to determine if it is safe to call getUrgency()");
}

const uci::type::EmitterUrgencyEnum& SignalType::getUrgency() const {
  return getUrgency_();
}

uci::type::EmitterUrgencyEnum& SignalType::getUrgency() {
  return getUrgency_();
}

uci::type::SignalType& SignalType::setUrgency(const uci::type::EmitterUrgencyEnum& accessor) {
  enableUrgency();
  if (&accessor != urgency_Accessor.get()) {
    urgency_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalType& SignalType::setUrgency(const uci::type::EmitterUrgencyEnum::EnumerationItem value) {
  enableUrgency().setValue(value);
  return *this;
}

bool SignalType::hasUrgency() const noexcept {
  return static_cast<bool>(urgency_Accessor);
}

uci::type::EmitterUrgencyEnum& SignalType::enableUrgency(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::emitterUrgencyEnum : type};
  if ((!urgency_Accessor) || (urgency_Accessor->getAccessorType() != requestedType)) {
    urgency_Accessor = EmitterUrgencyEnum::create(requestedType);
    if (!urgency_Accessor) {
      throw uci::base::UCIException("Error in enableUrgency(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *urgency_Accessor;
}

uci::type::SignalType& SignalType::clearUrgency() noexcept {
  urgency_Accessor.reset();
  return *this;
}

uci::type::MobilityEnum& SignalType::getMobility_() const {
  if (mobility_Accessor) {
    return *mobility_Accessor;
  }
  throw uci::base::UCIException("Error in getMobility(): An attempt was made to get an optional field that was not enabled, call hasMobility() to determine if it is safe to call getMobility()");
}

const uci::type::MobilityEnum& SignalType::getMobility() const {
  return getMobility_();
}

uci::type::MobilityEnum& SignalType::getMobility() {
  return getMobility_();
}

uci::type::SignalType& SignalType::setMobility(const uci::type::MobilityEnum& accessor) {
  enableMobility();
  if (&accessor != mobility_Accessor.get()) {
    mobility_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalType& SignalType::setMobility(const uci::type::MobilityEnum::EnumerationItem value) {
  enableMobility().setValue(value);
  return *this;
}

bool SignalType::hasMobility() const noexcept {
  return static_cast<bool>(mobility_Accessor);
}

uci::type::MobilityEnum& SignalType::enableMobility(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::mobilityEnum : type};
  if ((!mobility_Accessor) || (mobility_Accessor->getAccessorType() != requestedType)) {
    mobility_Accessor = MobilityEnum::create(requestedType);
    if (!mobility_Accessor) {
      throw uci::base::UCIException("Error in enableMobility(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *mobility_Accessor;
}

uci::type::SignalType& SignalType::clearMobility() noexcept {
  mobility_Accessor.reset();
  return *this;
}

std::unique_ptr<SignalType> SignalType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalType : type};
  return (requestedType == uci::type::accessorType::signalType) ? boost::make_unique<SignalType>() : nullptr;
}

/**  */
namespace SignalType_Names {

constexpr const char* Extern_Type_Name{"SignalType"};
constexpr const char* SignalID_Name{"SignalID"};
constexpr const char* SignalState_Name{"SignalState"};
constexpr const char* Source_Name{"Source"};
constexpr const char* LocalTrackIdentifier_Name{"LocalTrackIdentifier"};
constexpr const char* AssociatedPulseDataID_Name{"AssociatedPulseDataID"};
constexpr const char* InitialDetectionTimestamp_Name{"InitialDetectionTimestamp"};
constexpr const char* LatestDetectionTimestamp_Name{"LatestDetectionTimestamp"};
constexpr const char* TimestampQuality_Name{"TimestampQuality"};
constexpr const char* Parametrics_Name{"Parametrics"};
constexpr const char* EmitterFunction_Name{"EmitterFunction"};
constexpr const char* EmitterIdentity_Name{"EmitterIdentity"};
constexpr const char* EmitterKinematics_Name{"EmitterKinematics"};
constexpr const char* CollectorKinematics_Name{"CollectorKinematics"};
constexpr const char* WartimeReserveMode_Name{"WartimeReserveMode"};
constexpr const char* LockIndicator_Name{"LockIndicator"};
constexpr const char* ActivityBy_Name{"ActivityBy"};
constexpr const char* RemoveInfo_Name{"RemoveInfo"};
constexpr const char* Modulation_Name{"Modulation"};
constexpr const char* ModulationParameter_Name{"ModulationParameter"};
constexpr const char* Urgency_Name{"Urgency"};
constexpr const char* Mobility_Name{"Mobility"};

} // namespace SignalType_Names

void SignalType::deserialize(const boost::property_tree::ptree& propTree, uci::type::SignalType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = SignalType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + SignalType_Names::SignalID_Name) {
      SignalID_Type::deserialize(valueType.second, accessor.getSignalID(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::SignalState_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.getSignalState().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::Source_Name) {
      SignalSourceType::deserialize(valueType.second, accessor.enableSource(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::LocalTrackIdentifier_Name) {
      asb_uci::util::DerivedTypesDeserializer::deserialize(valueType.second, accessor.enableLocalTrackIdentifier(asb_uci::util::SerializationHelpers::checkForTypeAttribute(valueType.second, nsPrefix)), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::AssociatedPulseDataID_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SignalType::AssociatedPulseDataID& boundedList = accessor.getAssociatedPulseDataID();
        const uci::type::SignalType::AssociatedPulseDataID::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::PulseDataID_Type::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::InitialDetectionTimestamp_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setInitialDetectionTimestamp(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::LatestDetectionTimestamp_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setLatestDetectionTimestamp(asb_uci::util::SerializationHelpers::deserializeDateTime(*value));
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::TimestampQuality_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableTimestampQuality().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::Parametrics_Name) {
      SignalParametricsType::deserialize(valueType.second, accessor.enableParametrics(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::EmitterFunction_Name) {
      EmitterFunctionType::deserialize(valueType.second, accessor.enableEmitterFunction(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::EmitterIdentity_Name) {
      SignalIdentityType::deserialize(valueType.second, accessor.enableEmitterIdentity(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::EmitterKinematics_Name) {
      SignalEmitterKinematicsType::deserialize(valueType.second, accessor.enableEmitterKinematics(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::CollectorKinematics_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SignalType::CollectorKinematics& boundedList = accessor.getCollectorKinematics();
        const uci::type::SignalType::CollectorKinematics::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::SignalNavDataType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::WartimeReserveMode_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setWartimeReserveMode(*value);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::LockIndicator_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableLockIndicator().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::ActivityBy_Name) {
      ActivityByType::deserialize(valueType.second, accessor.enableActivityBy(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::RemoveInfo_Name) {
      SignalRemoveInfoType::deserialize(valueType.second, accessor.enableRemoveInfo(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalType_Names::Modulation_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SignalType::Modulation& boundedList = accessor.getModulation();
        const uci::type::SignalType::Modulation::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        boundedList.at(boundedListSize).setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::ModulationParameter_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        uci::type::SignalType::ModulationParameter& boundedList = accessor.getModulationParameter();
        const uci::type::SignalType::ModulationParameter::size_type boundedListSize{boundedList.size()};
        boundedList.resize(boundedListSize + 1);
        asb_uci::type::ModulationParameterType::deserialize(valueType.second, boundedList.at(boundedListSize), nodeName, nsPrefix);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::Urgency_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableUrgency().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalType_Names::Mobility_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableMobility().setValueFromName(*value);
      }
    }
  }
}

std::string SignalType::serialize(const uci::type::SignalType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? SignalType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, SignalType_Names::Extern_Type_Name);
  }
  SignalID_Type::serialize(accessor.getSignalID(), node, SignalType_Names::SignalID_Name);
  SignalReportStateEnum::serialize(accessor.getSignalState(), node, SignalType_Names::SignalState_Name, false);
  if (accessor.hasSource()) {
    SignalSourceType::serialize(accessor.getSource(), node, SignalType_Names::Source_Name);
  }
  if (accessor.hasLocalTrackIdentifier()) {
    ForeignKeyType::serialize(accessor.getLocalTrackIdentifier(), node, SignalType_Names::LocalTrackIdentifier_Name);
  }
  {
    const uci::type::SignalType::AssociatedPulseDataID& boundedList = accessor.getAssociatedPulseDataID();
    for (uci::type::SignalType::AssociatedPulseDataID::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::PulseDataID_Type::serialize(boundedList.at(i), node, SignalType_Names::AssociatedPulseDataID_Name);
    }
  }
  if (accessor.hasInitialDetectionTimestamp()) {
    asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getInitialDetectionTimestamp(), node, SignalType_Names::InitialDetectionTimestamp_Name);
  }
  if (accessor.hasLatestDetectionTimestamp()) {
    asb_uci::util::SerializationHelpers::serializeDateTime(accessor.getLatestDetectionTimestamp(), node, SignalType_Names::LatestDetectionTimestamp_Name);
  }
  if (accessor.hasTimestampQuality()) {
    MeasurementQualityEnum::serialize(accessor.getTimestampQuality(), node, SignalType_Names::TimestampQuality_Name, false);
  }
  if (accessor.hasParametrics()) {
    SignalParametricsType::serialize(accessor.getParametrics(), node, SignalType_Names::Parametrics_Name);
  }
  if (accessor.hasEmitterFunction()) {
    EmitterFunctionType::serialize(accessor.getEmitterFunction(), node, SignalType_Names::EmitterFunction_Name);
  }
  if (accessor.hasEmitterIdentity()) {
    SignalIdentityType::serialize(accessor.getEmitterIdentity(), node, SignalType_Names::EmitterIdentity_Name);
  }
  if (accessor.hasEmitterKinematics()) {
    SignalEmitterKinematicsType::serialize(accessor.getEmitterKinematics(), node, SignalType_Names::EmitterKinematics_Name);
  }
  {
    const uci::type::SignalType::CollectorKinematics& boundedList = accessor.getCollectorKinematics();
    for (uci::type::SignalType::CollectorKinematics::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::SignalNavDataType::serialize(boundedList.at(i), node, SignalType_Names::CollectorKinematics_Name);
    }
  }
  if (accessor.hasWartimeReserveMode()) {
    asb_uci::util::SerializationHelpers::serializeString(accessor.getWartimeReserveMode(), node, SignalType_Names::WartimeReserveMode_Name);
  }
  if (accessor.hasLockIndicator()) {
    LockIndicatorEnum::serialize(accessor.getLockIndicator(), node, SignalType_Names::LockIndicator_Name, false);
  }
  if (accessor.hasActivityBy()) {
    ActivityByType::serialize(accessor.getActivityBy(), node, SignalType_Names::ActivityBy_Name);
  }
  if (accessor.hasRemoveInfo()) {
    SignalRemoveInfoType::serialize(accessor.getRemoveInfo(), node, SignalType_Names::RemoveInfo_Name);
  }
  {
    const uci::type::SignalType::Modulation& boundedList = accessor.getModulation();
    for (uci::type::SignalType::Modulation::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      ModulationEnum::serialize(boundedList.at(i), node, SignalType_Names::Modulation_Name, false);
    }
  }
  {
    const uci::type::SignalType::ModulationParameter& boundedList = accessor.getModulationParameter();
    for (uci::type::SignalType::ModulationParameter::size_type i = 0, end = boundedList.size(); i < end; ++i) {
      asb_uci::type::ModulationParameterType::serialize(boundedList.at(i), node, SignalType_Names::ModulationParameter_Name);
    }
  }
  if (accessor.hasUrgency()) {
    EmitterUrgencyEnum::serialize(accessor.getUrgency(), node, SignalType_Names::Urgency_Name, false);
  }
  if (accessor.hasMobility()) {
    MobilityEnum::serialize(accessor.getMobility(), node, SignalType_Names::Mobility_Name, false);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::SignalType& SignalType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::SignalType>().release());
}

uci::type::SignalType& SignalType::create(const uci::type::SignalType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::SignalType> newAccessor{boost::make_unique<asb_uci::type::SignalType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void SignalType::destroy(uci::type::SignalType& accessor) {
  delete dynamic_cast<asb_uci::type::SignalType*>(&accessor);
}

} // namespace type

} // namespace uci

