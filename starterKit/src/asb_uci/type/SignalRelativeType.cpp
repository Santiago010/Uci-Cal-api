/** @file SignalRelativeType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:15 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/type/SignalRelativeType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/type/EW_MeasurementEnum.h"
#include "../../../include/asb_uci/type/LOS_MeasurementWithUncertaintyType.h"
#include "../../../include/asb_uci/type/MeasurementStatusEnum.h"
#include "../../../include/asb_uci/type/ReferenceObjectType.h"
#include "../../../include/asb_uci/type/SignalMeasurementFlagEnum.h"
#include "../../../include/asb_uci/type/SignalMeasurementMethodEnum.h"
#include "../../../include/asb_uci/util/SerializationHelpers.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/accessorType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/EW_MeasurementEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/MeasurementStatusEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/ReferenceObjectType.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalMeasurementFlagEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalMeasurementMethodEnum.h"
#include "../../../../cppInterface/2.3.2/include/uci/type/SignalRelativeType.h"
#include "../../../../cppInterface/2.3.2/include/xs/type/simpleXmlSchemaPrimitives.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

SignalRelativeType::SignalRelativeType() = default;

SignalRelativeType::~SignalRelativeType() = default;

void SignalRelativeType::copy(const uci::type::SignalRelativeType& accessor) {
  copyImpl(accessor, false);
}

void SignalRelativeType::copyImpl(const uci::type::SignalRelativeType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    LOS_MeasurementWithUncertaintyType::copyImpl(accessor, false);
    const auto& accessorImpl = dynamic_cast<const SignalRelativeType&>(accessor);
    if (accessorImpl.referenceIdentifier_Accessor) {
      setReferenceIdentifier(*(accessorImpl.referenceIdentifier_Accessor));
    } else {
      referenceIdentifier_Accessor.reset();
    }
    if (accessorImpl.measurement_Method_Accessor) {
      setMeasurement_Method(*(accessorImpl.measurement_Method_Accessor));
    } else {
      measurement_Method_Accessor.reset();
    }
    if (accessorImpl.measurement_Status_Accessor) {
      setMeasurement_Status(*(accessorImpl.measurement_Status_Accessor));
    } else {
      measurement_Status_Accessor.reset();
    }
    if (accessorImpl.measurement_Flag_Accessor) {
      setMeasurement_Flag(*(accessorImpl.measurement_Flag_Accessor));
    } else {
      measurement_Flag_Accessor.reset();
    }
    if (accessorImpl.hasSuspect()) {
      setSuspect(accessorImpl.getSuspect());
    } else {
      clearSuspect();
    }
    if (accessorImpl.hasExcessiveAttitude()) {
      setExcessiveAttitude(accessorImpl.getExcessiveAttitude());
    } else {
      clearExcessiveAttitude();
    }
    if (accessorImpl.hasFringeDetection()) {
      setFringeDetection(accessorImpl.getFringeDetection());
    } else {
      clearFringeDetection();
    }
    if (accessorImpl.eW_MeasurementType_Accessor) {
      setEW_MeasurementType(*(accessorImpl.eW_MeasurementType_Accessor));
    } else {
      eW_MeasurementType_Accessor.reset();
    }
  }
}

void SignalRelativeType::reset() noexcept {
  LOS_MeasurementWithUncertaintyType::reset();
  referenceIdentifier_Accessor.reset();
  measurement_Method_Accessor.reset();
  measurement_Status_Accessor.reset();
  measurement_Flag_Accessor.reset();
  clearSuspect();
  clearExcessiveAttitude();
  clearFringeDetection();
  eW_MeasurementType_Accessor.reset();
}

uci::type::ReferenceObjectType& SignalRelativeType::getReferenceIdentifier_() const {
  if (referenceIdentifier_Accessor) {
    return *referenceIdentifier_Accessor;
  }
  throw uci::base::UCIException("Error in getReferenceIdentifier(): An attempt was made to get an optional field that was not enabled, call hasReferenceIdentifier() to determine if it is safe to call getReferenceIdentifier()");
}

const uci::type::ReferenceObjectType& SignalRelativeType::getReferenceIdentifier() const {
  return getReferenceIdentifier_();
}

uci::type::ReferenceObjectType& SignalRelativeType::getReferenceIdentifier() {
  return getReferenceIdentifier_();
}

uci::type::SignalRelativeType& SignalRelativeType::setReferenceIdentifier(const uci::type::ReferenceObjectType& accessor) {
  enableReferenceIdentifier();
  if (&accessor != referenceIdentifier_Accessor.get()) {
    referenceIdentifier_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool SignalRelativeType::hasReferenceIdentifier() const noexcept {
  return static_cast<bool>(referenceIdentifier_Accessor);
}

uci::type::ReferenceObjectType& SignalRelativeType::enableReferenceIdentifier(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::referenceObjectType : type};
  if ((!referenceIdentifier_Accessor) || (referenceIdentifier_Accessor->getAccessorType() != requestedType)) {
    referenceIdentifier_Accessor = ReferenceObjectType::create(requestedType);
    if (!referenceIdentifier_Accessor) {
      throw uci::base::UCIException("Error in enableReferenceIdentifier(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *referenceIdentifier_Accessor;
}

uci::type::SignalRelativeType& SignalRelativeType::clearReferenceIdentifier() noexcept {
  referenceIdentifier_Accessor.reset();
  return *this;
}

uci::type::SignalMeasurementMethodEnum& SignalRelativeType::getMeasurement_Method_() const {
  if (measurement_Method_Accessor) {
    return *measurement_Method_Accessor;
  }
  throw uci::base::UCIException("Error in getMeasurement_Method(): An attempt was made to get an optional field that was not enabled, call hasMeasurement_Method() to determine if it is safe to call getMeasurement_Method()");
}

const uci::type::SignalMeasurementMethodEnum& SignalRelativeType::getMeasurement_Method() const {
  return getMeasurement_Method_();
}

uci::type::SignalMeasurementMethodEnum& SignalRelativeType::getMeasurement_Method() {
  return getMeasurement_Method_();
}

uci::type::SignalRelativeType& SignalRelativeType::setMeasurement_Method(const uci::type::SignalMeasurementMethodEnum& accessor) {
  enableMeasurement_Method();
  if (&accessor != measurement_Method_Accessor.get()) {
    measurement_Method_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalRelativeType& SignalRelativeType::setMeasurement_Method(const uci::type::SignalMeasurementMethodEnum::EnumerationItem value) {
  enableMeasurement_Method().setValue(value);
  return *this;
}

bool SignalRelativeType::hasMeasurement_Method() const noexcept {
  return static_cast<bool>(measurement_Method_Accessor);
}

uci::type::SignalMeasurementMethodEnum& SignalRelativeType::enableMeasurement_Method(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalMeasurementMethodEnum : type};
  if ((!measurement_Method_Accessor) || (measurement_Method_Accessor->getAccessorType() != requestedType)) {
    measurement_Method_Accessor = SignalMeasurementMethodEnum::create(requestedType);
    if (!measurement_Method_Accessor) {
      throw uci::base::UCIException("Error in enableMeasurement_Method(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *measurement_Method_Accessor;
}

uci::type::SignalRelativeType& SignalRelativeType::clearMeasurement_Method() noexcept {
  measurement_Method_Accessor.reset();
  return *this;
}

uci::type::MeasurementStatusEnum& SignalRelativeType::getMeasurement_Status_() const {
  if (measurement_Status_Accessor) {
    return *measurement_Status_Accessor;
  }
  throw uci::base::UCIException("Error in getMeasurement_Status(): An attempt was made to get an optional field that was not enabled, call hasMeasurement_Status() to determine if it is safe to call getMeasurement_Status()");
}

const uci::type::MeasurementStatusEnum& SignalRelativeType::getMeasurement_Status() const {
  return getMeasurement_Status_();
}

uci::type::MeasurementStatusEnum& SignalRelativeType::getMeasurement_Status() {
  return getMeasurement_Status_();
}

uci::type::SignalRelativeType& SignalRelativeType::setMeasurement_Status(const uci::type::MeasurementStatusEnum& accessor) {
  enableMeasurement_Status();
  if (&accessor != measurement_Status_Accessor.get()) {
    measurement_Status_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalRelativeType& SignalRelativeType::setMeasurement_Status(const uci::type::MeasurementStatusEnum::EnumerationItem value) {
  enableMeasurement_Status().setValue(value);
  return *this;
}

bool SignalRelativeType::hasMeasurement_Status() const noexcept {
  return static_cast<bool>(measurement_Status_Accessor);
}

uci::type::MeasurementStatusEnum& SignalRelativeType::enableMeasurement_Status(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::measurementStatusEnum : type};
  if ((!measurement_Status_Accessor) || (measurement_Status_Accessor->getAccessorType() != requestedType)) {
    measurement_Status_Accessor = MeasurementStatusEnum::create(requestedType);
    if (!measurement_Status_Accessor) {
      throw uci::base::UCIException("Error in enableMeasurement_Status(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *measurement_Status_Accessor;
}

uci::type::SignalRelativeType& SignalRelativeType::clearMeasurement_Status() noexcept {
  measurement_Status_Accessor.reset();
  return *this;
}

uci::type::SignalMeasurementFlagEnum& SignalRelativeType::getMeasurement_Flag_() const {
  if (measurement_Flag_Accessor) {
    return *measurement_Flag_Accessor;
  }
  throw uci::base::UCIException("Error in getMeasurement_Flag(): An attempt was made to get an optional field that was not enabled, call hasMeasurement_Flag() to determine if it is safe to call getMeasurement_Flag()");
}

const uci::type::SignalMeasurementFlagEnum& SignalRelativeType::getMeasurement_Flag() const {
  return getMeasurement_Flag_();
}

uci::type::SignalMeasurementFlagEnum& SignalRelativeType::getMeasurement_Flag() {
  return getMeasurement_Flag_();
}

uci::type::SignalRelativeType& SignalRelativeType::setMeasurement_Flag(const uci::type::SignalMeasurementFlagEnum& accessor) {
  enableMeasurement_Flag();
  if (&accessor != measurement_Flag_Accessor.get()) {
    measurement_Flag_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalRelativeType& SignalRelativeType::setMeasurement_Flag(const uci::type::SignalMeasurementFlagEnum::EnumerationItem value) {
  enableMeasurement_Flag().setValue(value);
  return *this;
}

bool SignalRelativeType::hasMeasurement_Flag() const noexcept {
  return static_cast<bool>(measurement_Flag_Accessor);
}

uci::type::SignalMeasurementFlagEnum& SignalRelativeType::enableMeasurement_Flag(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalMeasurementFlagEnum : type};
  if ((!measurement_Flag_Accessor) || (measurement_Flag_Accessor->getAccessorType() != requestedType)) {
    measurement_Flag_Accessor = SignalMeasurementFlagEnum::create(requestedType);
    if (!measurement_Flag_Accessor) {
      throw uci::base::UCIException("Error in enableMeasurement_Flag(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *measurement_Flag_Accessor;
}

uci::type::SignalRelativeType& SignalRelativeType::clearMeasurement_Flag() noexcept {
  measurement_Flag_Accessor.reset();
  return *this;
}

xs::Boolean SignalRelativeType::getSuspect() const {
  if (suspect_Accessor) {
    return *suspect_Accessor;
  }
  throw uci::base::UCIException("Error in getSuspect(): An attempt was made to get an optional field that was not enabled, call hasSuspect() to determine if it is safe to call getSuspect()");
}

uci::type::SignalRelativeType& SignalRelativeType::setSuspect(xs::Boolean value) {
  suspect_Accessor = value;
  return *this;
}

bool SignalRelativeType::hasSuspect() const noexcept {
  return suspect_Accessor.has_value();
}

uci::type::SignalRelativeType& SignalRelativeType::clearSuspect() noexcept {
  suspect_Accessor.reset();
  return *this;
}

xs::Boolean SignalRelativeType::getExcessiveAttitude() const {
  if (excessiveAttitude_Accessor) {
    return *excessiveAttitude_Accessor;
  }
  throw uci::base::UCIException("Error in getExcessiveAttitude(): An attempt was made to get an optional field that was not enabled, call hasExcessiveAttitude() to determine if it is safe to call getExcessiveAttitude()");
}

uci::type::SignalRelativeType& SignalRelativeType::setExcessiveAttitude(xs::Boolean value) {
  excessiveAttitude_Accessor = value;
  return *this;
}

bool SignalRelativeType::hasExcessiveAttitude() const noexcept {
  return excessiveAttitude_Accessor.has_value();
}

uci::type::SignalRelativeType& SignalRelativeType::clearExcessiveAttitude() noexcept {
  excessiveAttitude_Accessor.reset();
  return *this;
}

xs::Boolean SignalRelativeType::getFringeDetection() const {
  if (fringeDetection_Accessor) {
    return *fringeDetection_Accessor;
  }
  throw uci::base::UCIException("Error in getFringeDetection(): An attempt was made to get an optional field that was not enabled, call hasFringeDetection() to determine if it is safe to call getFringeDetection()");
}

uci::type::SignalRelativeType& SignalRelativeType::setFringeDetection(xs::Boolean value) {
  fringeDetection_Accessor = value;
  return *this;
}

bool SignalRelativeType::hasFringeDetection() const noexcept {
  return fringeDetection_Accessor.has_value();
}

uci::type::SignalRelativeType& SignalRelativeType::clearFringeDetection() noexcept {
  fringeDetection_Accessor.reset();
  return *this;
}

uci::type::EW_MeasurementEnum& SignalRelativeType::getEW_MeasurementType_() const {
  if (eW_MeasurementType_Accessor) {
    return *eW_MeasurementType_Accessor;
  }
  throw uci::base::UCIException("Error in getEW_MeasurementType(): An attempt was made to get an optional field that was not enabled, call hasEW_MeasurementType() to determine if it is safe to call getEW_MeasurementType()");
}

const uci::type::EW_MeasurementEnum& SignalRelativeType::getEW_MeasurementType() const {
  return getEW_MeasurementType_();
}

uci::type::EW_MeasurementEnum& SignalRelativeType::getEW_MeasurementType() {
  return getEW_MeasurementType_();
}

uci::type::SignalRelativeType& SignalRelativeType::setEW_MeasurementType(const uci::type::EW_MeasurementEnum& accessor) {
  enableEW_MeasurementType();
  if (&accessor != eW_MeasurementType_Accessor.get()) {
    eW_MeasurementType_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

uci::type::SignalRelativeType& SignalRelativeType::setEW_MeasurementType(const uci::type::EW_MeasurementEnum::EnumerationItem value) {
  enableEW_MeasurementType().setValue(value);
  return *this;
}

bool SignalRelativeType::hasEW_MeasurementType() const noexcept {
  return static_cast<bool>(eW_MeasurementType_Accessor);
}

uci::type::EW_MeasurementEnum& SignalRelativeType::enableEW_MeasurementType(uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::eW_MeasurementEnum : type};
  if ((!eW_MeasurementType_Accessor) || (eW_MeasurementType_Accessor->getAccessorType() != requestedType)) {
    eW_MeasurementType_Accessor = EW_MeasurementEnum::create(requestedType);
    if (!eW_MeasurementType_Accessor) {
      throw uci::base::UCIException("Error in enableEW_MeasurementType(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *eW_MeasurementType_Accessor;
}

uci::type::SignalRelativeType& SignalRelativeType::clearEW_MeasurementType() noexcept {
  eW_MeasurementType_Accessor.reset();
  return *this;
}

std::unique_ptr<SignalRelativeType> SignalRelativeType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::signalRelativeType : type};
  return (requestedType == uci::type::accessorType::signalRelativeType) ? boost::make_unique<SignalRelativeType>() : nullptr;
}

/**  */
namespace SignalRelativeType_Names {

constexpr const char* Extern_Type_Name{"SignalRelativeType"};
constexpr const char* ReferenceIdentifier_Name{"ReferenceIdentifier"};
constexpr const char* Measurement_Method_Name{"Measurement_Method"};
constexpr const char* Measurement_Status_Name{"Measurement_Status"};
constexpr const char* Measurement_Flag_Name{"Measurement_Flag"};
constexpr const char* Suspect_Name{"Suspect"};
constexpr const char* ExcessiveAttitude_Name{"ExcessiveAttitude"};
constexpr const char* FringeDetection_Name{"FringeDetection"};
constexpr const char* EW_MeasurementType_Name{"EW_MeasurementType"};

} // namespace SignalRelativeType_Names

void SignalRelativeType::deserialize(const boost::property_tree::ptree& propTree, uci::type::SignalRelativeType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = SignalRelativeType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + SignalRelativeType_Names::ReferenceIdentifier_Name) {
      ReferenceObjectType::deserialize(valueType.second, accessor.enableReferenceIdentifier(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + SignalRelativeType_Names::Measurement_Method_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableMeasurement_Method().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalRelativeType_Names::Measurement_Status_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableMeasurement_Status().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalRelativeType_Names::Measurement_Flag_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableMeasurement_Flag().setValueFromName(*value);
      }
    } else if (valueType.first == nsPrefix + SignalRelativeType_Names::Suspect_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setSuspect(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + SignalRelativeType_Names::ExcessiveAttitude_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setExcessiveAttitude(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + SignalRelativeType_Names::FringeDetection_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.setFringeDetection(asb_uci::util::SerializationHelpers::deserializeBoolean(*value));
      }
    } else if (valueType.first == nsPrefix + SignalRelativeType_Names::EW_MeasurementType_Name) {
      if (const boost::optional<std::string> value = valueType.second.get_value_optional<std::string>()) {
        accessor.enableEW_MeasurementType().setValueFromName(*value);
      }
    }
  }
  LOS_MeasurementWithUncertaintyType::deserialize(node, accessor, nodeName, nsPrefix);
}

std::string SignalRelativeType::serialize(const uci::type::SignalRelativeType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? SignalRelativeType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, SignalRelativeType_Names::Extern_Type_Name);
  }
  LOS_MeasurementWithUncertaintyType::serialize(accessor, node, "", false, false, false);
  if (accessor.hasReferenceIdentifier()) {
    ReferenceObjectType::serialize(accessor.getReferenceIdentifier(), node, SignalRelativeType_Names::ReferenceIdentifier_Name);
  }
  if (accessor.hasMeasurement_Method()) {
    SignalMeasurementMethodEnum::serialize(accessor.getMeasurement_Method(), node, SignalRelativeType_Names::Measurement_Method_Name, false);
  }
  if (accessor.hasMeasurement_Status()) {
    MeasurementStatusEnum::serialize(accessor.getMeasurement_Status(), node, SignalRelativeType_Names::Measurement_Status_Name, false);
  }
  if (accessor.hasMeasurement_Flag()) {
    SignalMeasurementFlagEnum::serialize(accessor.getMeasurement_Flag(), node, SignalRelativeType_Names::Measurement_Flag_Name, false);
  }
  if (accessor.hasSuspect()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getSuspect(), node, SignalRelativeType_Names::Suspect_Name);
  }
  if (accessor.hasExcessiveAttitude()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getExcessiveAttitude(), node, SignalRelativeType_Names::ExcessiveAttitude_Name);
  }
  if (accessor.hasFringeDetection()) {
    asb_uci::util::SerializationHelpers::serializeBoolean(accessor.getFringeDetection(), node, SignalRelativeType_Names::FringeDetection_Name);
  }
  if (accessor.hasEW_MeasurementType()) {
    EW_MeasurementEnum::serialize(accessor.getEW_MeasurementType(), node, SignalRelativeType_Names::EW_MeasurementType_Name, false);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::SignalRelativeType& SignalRelativeType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::SignalRelativeType>().release());
}

uci::type::SignalRelativeType& SignalRelativeType::create(const uci::type::SignalRelativeType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::SignalRelativeType> newAccessor{boost::make_unique<asb_uci::type::SignalRelativeType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void SignalRelativeType::destroy(uci::type::SignalRelativeType& accessor) {
  delete dynamic_cast<asb_uci::type::SignalRelativeType*>(&accessor);
}

} // namespace type

} // namespace uci

