/** @file CharacterizationChoiceType.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:12 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "asb_uci/type/CharacterizationChoiceType.h"

#include <memory>
#include <string>

#include <boost/optional/optional.hpp>
#include <boost/smart_ptr/make_unique.hpp>

#include "asb_uci/type/ColorPhotometryParamsType.h"
#include "asb_uci/type/FrequencyParamsType.h"
#include "asb_uci/type/IR_ImageParamsType.h"
#include "asb_uci/type/MetricParamsType.h"
#include "asb_uci/type/Narrowband_SOI_ParamsType.h"
#include "asb_uci/type/OpticalImageParamsType.h"
#include "asb_uci/type/PhotometryParamsType.h"
#include "asb_uci/type/RCS_ParamsType.h"
#include "asb_uci/type/VisMagParamsType.h"
#include "asb_uci/type/Wideband_SOI_ParamsType.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"
#include "uci/base/accessorType.h"
#include "uci/type/CharacterizationChoiceType.h"
#include "uci/type/ColorPhotometryParamsType.h"
#include "uci/type/FrequencyParamsType.h"
#include "uci/type/IR_ImageParamsType.h"
#include "uci/type/MetricParamsType.h"
#include "uci/type/Narrowband_SOI_ParamsType.h"
#include "uci/type/OpticalImageParamsType.h"
#include "uci/type/PhotometryParamsType.h"
#include "uci/type/RCS_ParamsType.h"
#include "uci/type/VisMagParamsType.h"
#include "uci/type/Wideband_SOI_ParamsType.h"

/**  */
namespace asb_uci {

/** The namespace in which all generated data types are declared */
namespace type {

CharacterizationChoiceType::CharacterizationChoiceType() = default;

CharacterizationChoiceType::~CharacterizationChoiceType() = default;

void CharacterizationChoiceType::copy(const uci::type::CharacterizationChoiceType& accessor) {
  copyImpl(accessor, false);
}

void CharacterizationChoiceType::copyImpl(const uci::type::CharacterizationChoiceType& accessor, const bool /*checkIfDerivation*/) {
  if (&accessor != this) {
    const auto& accessorImpl = dynamic_cast<const CharacterizationChoiceType&>(accessor);
    if (accessorImpl.frequency_Accessor) {
      setFrequency(*(accessorImpl.frequency_Accessor));
    } else {
      frequency_Accessor.reset();
    }
    if (accessorImpl.iR_Image_Accessor) {
      setIR_Image(*(accessorImpl.iR_Image_Accessor));
    } else {
      iR_Image_Accessor.reset();
    }
    if (accessorImpl.metricObservations_Accessor) {
      setMetricObservations(*(accessorImpl.metricObservations_Accessor));
    } else {
      metricObservations_Accessor.reset();
    }
    if (accessorImpl.narrowband_SOI_Accessor) {
      setNarrowband_SOI(*(accessorImpl.narrowband_SOI_Accessor));
    } else {
      narrowband_SOI_Accessor.reset();
    }
    if (accessorImpl.opticalImage_Accessor) {
      setOpticalImage(*(accessorImpl.opticalImage_Accessor));
    } else {
      opticalImage_Accessor.reset();
    }
    if (accessorImpl.rCS_Accessor) {
      setRCS(*(accessorImpl.rCS_Accessor));
    } else {
      rCS_Accessor.reset();
    }
    if (accessorImpl.visMag_Accessor) {
      setVisMag(*(accessorImpl.visMag_Accessor));
    } else {
      visMag_Accessor.reset();
    }
    if (accessorImpl.wideband_SOI_Accessor) {
      setWideband_SOI(*(accessorImpl.wideband_SOI_Accessor));
    } else {
      wideband_SOI_Accessor.reset();
    }
    if (accessorImpl.photometry_Accessor) {
      setPhotometry(*(accessorImpl.photometry_Accessor));
    } else {
      photometry_Accessor.reset();
    }
    if (accessorImpl.colorPhotometry_Accessor) {
      setColorPhotometry(*(accessorImpl.colorPhotometry_Accessor));
    } else {
      colorPhotometry_Accessor.reset();
    }
  }
}

void CharacterizationChoiceType::reset() noexcept {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
}

uci::type::CharacterizationChoiceType::CharacterizationChoiceTypeChoice CharacterizationChoiceType::getCharacterizationChoiceTypeChoiceOrdinal() const noexcept {
  if (frequency_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_FREQUENCY;
  }
  if (iR_Image_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_IR_IMAGE;
  }
  if (metricObservations_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_METRICOBSERVATIONS;
  }
  if (narrowband_SOI_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_NARROWBAND_SOI;
  }
  if (opticalImage_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_OPTICALIMAGE;
  }
  if (rCS_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_RCS;
  }
  if (visMag_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_VISMAG;
  }
  if (wideband_SOI_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_WIDEBAND_SOI;
  }
  if (photometry_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_PHOTOMETRY;
  }
  if (colorPhotometry_Accessor) {
    return CHARACTERIZATIONCHOICETYPE_CHOICE_COLORPHOTOMETRY;
  }
  return CHARACTERIZATIONCHOICETYPE_CHOICE_NONE;
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setCharacterizationChoiceTypeChoiceOrdinal(uci::type::CharacterizationChoiceType::CharacterizationChoiceTypeChoice ordinal, uci::base::accessorType::AccessorType type) {
  switch (ordinal) {
    case CHARACTERIZATIONCHOICETYPE_CHOICE_FREQUENCY:
      chooseFrequency("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_IR_IMAGE:
      chooseIR_Image("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_METRICOBSERVATIONS:
      chooseMetricObservations("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_NARROWBAND_SOI:
      chooseNarrowband_SOI("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_OPTICALIMAGE:
      chooseOpticalImage("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_RCS:
      chooseRCS("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_VISMAG:
      chooseVisMag("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_WIDEBAND_SOI:
      chooseWideband_SOI("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_PHOTOMETRY:
      choosePhotometry("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    case CHARACTERIZATIONCHOICETYPE_CHOICE_COLORPHOTOMETRY:
      chooseColorPhotometry("setCharacterizationChoiceTypeChoiceOrdinal", type);
      break;
    default:
      throw uci::base::UCIException("Error in setCharacterizationChoiceTypeChoiceOrdinal(): The provided ordinal is not valid");
      break;
  }
  return *this;
}

uci::type::FrequencyParamsType& CharacterizationChoiceType::getFrequency_() const {
  if (frequency_Accessor) {
    return *frequency_Accessor;
  }
  throw uci::base::UCIException("Error in getFrequency(): Unable to get Frequency, field not selected");
}

const uci::type::FrequencyParamsType& CharacterizationChoiceType::getFrequency() const {
  return getFrequency_();
}

uci::type::FrequencyParamsType& CharacterizationChoiceType::getFrequency() {
  return getFrequency_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setFrequency(const uci::type::FrequencyParamsType& accessor) {
  chooseFrequency();
  if (&accessor != frequency_Accessor.get()) {
    frequency_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isFrequency() const noexcept {
  return static_cast<bool>(frequency_Accessor);
}

uci::type::FrequencyParamsType& CharacterizationChoiceType::chooseFrequency(const std::string& method, uci::base::accessorType::AccessorType type) {
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::frequencyParamsType : type};
  if ((!frequency_Accessor) || (frequency_Accessor->getAccessorType() != requestedType)) {
    frequency_Accessor = FrequencyParamsType::create(type);
    if (!frequency_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *frequency_Accessor;
}

uci::type::FrequencyParamsType& CharacterizationChoiceType::chooseFrequency(uci::base::accessorType::AccessorType type) {
  return chooseFrequency("chooseFrequency", type);
}

uci::type::IR_ImageParamsType& CharacterizationChoiceType::getIR_Image_() const {
  if (iR_Image_Accessor) {
    return *iR_Image_Accessor;
  }
  throw uci::base::UCIException("Error in getIR_Image(): Unable to get IR_Image, field not selected");
}

const uci::type::IR_ImageParamsType& CharacterizationChoiceType::getIR_Image() const {
  return getIR_Image_();
}

uci::type::IR_ImageParamsType& CharacterizationChoiceType::getIR_Image() {
  return getIR_Image_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setIR_Image(const uci::type::IR_ImageParamsType& accessor) {
  chooseIR_Image();
  if (&accessor != iR_Image_Accessor.get()) {
    iR_Image_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isIR_Image() const noexcept {
  return static_cast<bool>(iR_Image_Accessor);
}

uci::type::IR_ImageParamsType& CharacterizationChoiceType::chooseIR_Image(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::iR_ImageParamsType : type};
  if ((!iR_Image_Accessor) || (iR_Image_Accessor->getAccessorType() != requestedType)) {
    iR_Image_Accessor = IR_ImageParamsType::create(type);
    if (!iR_Image_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *iR_Image_Accessor;
}

uci::type::IR_ImageParamsType& CharacterizationChoiceType::chooseIR_Image(uci::base::accessorType::AccessorType type) {
  return chooseIR_Image("chooseIR_Image", type);
}

uci::type::MetricParamsType& CharacterizationChoiceType::getMetricObservations_() const {
  if (metricObservations_Accessor) {
    return *metricObservations_Accessor;
  }
  throw uci::base::UCIException("Error in getMetricObservations(): Unable to get MetricObservations, field not selected");
}

const uci::type::MetricParamsType& CharacterizationChoiceType::getMetricObservations() const {
  return getMetricObservations_();
}

uci::type::MetricParamsType& CharacterizationChoiceType::getMetricObservations() {
  return getMetricObservations_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setMetricObservations(const uci::type::MetricParamsType& accessor) {
  chooseMetricObservations();
  if (&accessor != metricObservations_Accessor.get()) {
    metricObservations_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isMetricObservations() const noexcept {
  return static_cast<bool>(metricObservations_Accessor);
}

uci::type::MetricParamsType& CharacterizationChoiceType::chooseMetricObservations(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::metricParamsType : type};
  if ((!metricObservations_Accessor) || (metricObservations_Accessor->getAccessorType() != requestedType)) {
    metricObservations_Accessor = MetricParamsType::create(type);
    if (!metricObservations_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *metricObservations_Accessor;
}

uci::type::MetricParamsType& CharacterizationChoiceType::chooseMetricObservations(uci::base::accessorType::AccessorType type) {
  return chooseMetricObservations("chooseMetricObservations", type);
}

uci::type::Narrowband_SOI_ParamsType& CharacterizationChoiceType::getNarrowband_SOI_() const {
  if (narrowband_SOI_Accessor) {
    return *narrowband_SOI_Accessor;
  }
  throw uci::base::UCIException("Error in getNarrowband_SOI(): Unable to get Narrowband_SOI, field not selected");
}

const uci::type::Narrowband_SOI_ParamsType& CharacterizationChoiceType::getNarrowband_SOI() const {
  return getNarrowband_SOI_();
}

uci::type::Narrowband_SOI_ParamsType& CharacterizationChoiceType::getNarrowband_SOI() {
  return getNarrowband_SOI_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setNarrowband_SOI(const uci::type::Narrowband_SOI_ParamsType& accessor) {
  chooseNarrowband_SOI();
  if (&accessor != narrowband_SOI_Accessor.get()) {
    narrowband_SOI_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isNarrowband_SOI() const noexcept {
  return static_cast<bool>(narrowband_SOI_Accessor);
}

uci::type::Narrowband_SOI_ParamsType& CharacterizationChoiceType::chooseNarrowband_SOI(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::narrowband_SOI_ParamsType : type};
  if ((!narrowband_SOI_Accessor) || (narrowband_SOI_Accessor->getAccessorType() != requestedType)) {
    narrowband_SOI_Accessor = Narrowband_SOI_ParamsType::create(type);
    if (!narrowband_SOI_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *narrowband_SOI_Accessor;
}

uci::type::Narrowband_SOI_ParamsType& CharacterizationChoiceType::chooseNarrowband_SOI(uci::base::accessorType::AccessorType type) {
  return chooseNarrowband_SOI("chooseNarrowband_SOI", type);
}

uci::type::OpticalImageParamsType& CharacterizationChoiceType::getOpticalImage_() const {
  if (opticalImage_Accessor) {
    return *opticalImage_Accessor;
  }
  throw uci::base::UCIException("Error in getOpticalImage(): Unable to get OpticalImage, field not selected");
}

const uci::type::OpticalImageParamsType& CharacterizationChoiceType::getOpticalImage() const {
  return getOpticalImage_();
}

uci::type::OpticalImageParamsType& CharacterizationChoiceType::getOpticalImage() {
  return getOpticalImage_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setOpticalImage(const uci::type::OpticalImageParamsType& accessor) {
  chooseOpticalImage();
  if (&accessor != opticalImage_Accessor.get()) {
    opticalImage_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isOpticalImage() const noexcept {
  return static_cast<bool>(opticalImage_Accessor);
}

uci::type::OpticalImageParamsType& CharacterizationChoiceType::chooseOpticalImage(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::opticalImageParamsType : type};
  if ((!opticalImage_Accessor) || (opticalImage_Accessor->getAccessorType() != requestedType)) {
    opticalImage_Accessor = OpticalImageParamsType::create(type);
    if (!opticalImage_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *opticalImage_Accessor;
}

uci::type::OpticalImageParamsType& CharacterizationChoiceType::chooseOpticalImage(uci::base::accessorType::AccessorType type) {
  return chooseOpticalImage("chooseOpticalImage", type);
}

uci::type::RCS_ParamsType& CharacterizationChoiceType::getRCS_() const {
  if (rCS_Accessor) {
    return *rCS_Accessor;
  }
  throw uci::base::UCIException("Error in getRCS(): Unable to get RCS, field not selected");
}

const uci::type::RCS_ParamsType& CharacterizationChoiceType::getRCS() const {
  return getRCS_();
}

uci::type::RCS_ParamsType& CharacterizationChoiceType::getRCS() {
  return getRCS_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setRCS(const uci::type::RCS_ParamsType& accessor) {
  chooseRCS();
  if (&accessor != rCS_Accessor.get()) {
    rCS_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isRCS() const noexcept {
  return static_cast<bool>(rCS_Accessor);
}

uci::type::RCS_ParamsType& CharacterizationChoiceType::chooseRCS(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::rCS_ParamsType : type};
  if ((!rCS_Accessor) || (rCS_Accessor->getAccessorType() != requestedType)) {
    rCS_Accessor = RCS_ParamsType::create(type);
    if (!rCS_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *rCS_Accessor;
}

uci::type::RCS_ParamsType& CharacterizationChoiceType::chooseRCS(uci::base::accessorType::AccessorType type) {
  return chooseRCS("chooseRCS", type);
}

uci::type::VisMagParamsType& CharacterizationChoiceType::getVisMag_() const {
  if (visMag_Accessor) {
    return *visMag_Accessor;
  }
  throw uci::base::UCIException("Error in getVisMag(): Unable to get VisMag, field not selected");
}

const uci::type::VisMagParamsType& CharacterizationChoiceType::getVisMag() const {
  return getVisMag_();
}

uci::type::VisMagParamsType& CharacterizationChoiceType::getVisMag() {
  return getVisMag_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setVisMag(const uci::type::VisMagParamsType& accessor) {
  chooseVisMag();
  if (&accessor != visMag_Accessor.get()) {
    visMag_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isVisMag() const noexcept {
  return static_cast<bool>(visMag_Accessor);
}

uci::type::VisMagParamsType& CharacterizationChoiceType::chooseVisMag(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::visMagParamsType : type};
  if ((!visMag_Accessor) || (visMag_Accessor->getAccessorType() != requestedType)) {
    visMag_Accessor = VisMagParamsType::create(type);
    if (!visMag_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *visMag_Accessor;
}

uci::type::VisMagParamsType& CharacterizationChoiceType::chooseVisMag(uci::base::accessorType::AccessorType type) {
  return chooseVisMag("chooseVisMag", type);
}

uci::type::Wideband_SOI_ParamsType& CharacterizationChoiceType::getWideband_SOI_() const {
  if (wideband_SOI_Accessor) {
    return *wideband_SOI_Accessor;
  }
  throw uci::base::UCIException("Error in getWideband_SOI(): Unable to get Wideband_SOI, field not selected");
}

const uci::type::Wideband_SOI_ParamsType& CharacterizationChoiceType::getWideband_SOI() const {
  return getWideband_SOI_();
}

uci::type::Wideband_SOI_ParamsType& CharacterizationChoiceType::getWideband_SOI() {
  return getWideband_SOI_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setWideband_SOI(const uci::type::Wideband_SOI_ParamsType& accessor) {
  chooseWideband_SOI();
  if (&accessor != wideband_SOI_Accessor.get()) {
    wideband_SOI_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isWideband_SOI() const noexcept {
  return static_cast<bool>(wideband_SOI_Accessor);
}

uci::type::Wideband_SOI_ParamsType& CharacterizationChoiceType::chooseWideband_SOI(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  photometry_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::wideband_SOI_ParamsType : type};
  if ((!wideband_SOI_Accessor) || (wideband_SOI_Accessor->getAccessorType() != requestedType)) {
    wideband_SOI_Accessor = Wideband_SOI_ParamsType::create(type);
    if (!wideband_SOI_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *wideband_SOI_Accessor;
}

uci::type::Wideband_SOI_ParamsType& CharacterizationChoiceType::chooseWideband_SOI(uci::base::accessorType::AccessorType type) {
  return chooseWideband_SOI("chooseWideband_SOI", type);
}

uci::type::PhotometryParamsType& CharacterizationChoiceType::getPhotometry_() const {
  if (photometry_Accessor) {
    return *photometry_Accessor;
  }
  throw uci::base::UCIException("Error in getPhotometry(): Unable to get Photometry, field not selected");
}

const uci::type::PhotometryParamsType& CharacterizationChoiceType::getPhotometry() const {
  return getPhotometry_();
}

uci::type::PhotometryParamsType& CharacterizationChoiceType::getPhotometry() {
  return getPhotometry_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setPhotometry(const uci::type::PhotometryParamsType& accessor) {
  choosePhotometry();
  if (&accessor != photometry_Accessor.get()) {
    photometry_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isPhotometry() const noexcept {
  return static_cast<bool>(photometry_Accessor);
}

uci::type::PhotometryParamsType& CharacterizationChoiceType::choosePhotometry(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  colorPhotometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::photometryParamsType : type};
  if ((!photometry_Accessor) || (photometry_Accessor->getAccessorType() != requestedType)) {
    photometry_Accessor = PhotometryParamsType::create(type);
    if (!photometry_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *photometry_Accessor;
}

uci::type::PhotometryParamsType& CharacterizationChoiceType::choosePhotometry(uci::base::accessorType::AccessorType type) {
  return choosePhotometry("choosePhotometry", type);
}

uci::type::ColorPhotometryParamsType& CharacterizationChoiceType::getColorPhotometry_() const {
  if (colorPhotometry_Accessor) {
    return *colorPhotometry_Accessor;
  }
  throw uci::base::UCIException("Error in getColorPhotometry(): Unable to get ColorPhotometry, field not selected");
}

const uci::type::ColorPhotometryParamsType& CharacterizationChoiceType::getColorPhotometry() const {
  return getColorPhotometry_();
}

uci::type::ColorPhotometryParamsType& CharacterizationChoiceType::getColorPhotometry() {
  return getColorPhotometry_();
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::setColorPhotometry(const uci::type::ColorPhotometryParamsType& accessor) {
  chooseColorPhotometry();
  if (&accessor != colorPhotometry_Accessor.get()) {
    colorPhotometry_Accessor->copyImpl(accessor, false);
  }
  return *this;
}

bool CharacterizationChoiceType::isColorPhotometry() const noexcept {
  return static_cast<bool>(colorPhotometry_Accessor);
}

uci::type::ColorPhotometryParamsType& CharacterizationChoiceType::chooseColorPhotometry(const std::string& method, uci::base::accessorType::AccessorType type) {
  frequency_Accessor.reset();
  iR_Image_Accessor.reset();
  metricObservations_Accessor.reset();
  narrowband_SOI_Accessor.reset();
  opticalImage_Accessor.reset();
  rCS_Accessor.reset();
  visMag_Accessor.reset();
  wideband_SOI_Accessor.reset();
  photometry_Accessor.reset();
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::colorPhotometryParamsType : type};
  if ((!colorPhotometry_Accessor) || (colorPhotometry_Accessor->getAccessorType() != requestedType)) {
    colorPhotometry_Accessor = ColorPhotometryParamsType::create(type);
    if (!colorPhotometry_Accessor) {
      throw uci::base::UCIException("Error in " + method + "(): Specified type is not equal to nor derived from the native type of object");
    }
  }
  return *colorPhotometry_Accessor;
}

uci::type::ColorPhotometryParamsType& CharacterizationChoiceType::chooseColorPhotometry(uci::base::accessorType::AccessorType type) {
  return chooseColorPhotometry("chooseColorPhotometry", type);
}

std::unique_ptr<CharacterizationChoiceType> CharacterizationChoiceType::create(const uci::base::accessorType::AccessorType type) {
  const uci::base::accessorType::AccessorType requestedType{(type == uci::base::accessorType::null) ? uci::type::accessorType::characterizationChoiceType : type};
  return (requestedType == uci::type::accessorType::characterizationChoiceType) ? boost::make_unique<CharacterizationChoiceType>() : nullptr;
}

/**  */
namespace CharacterizationChoiceType_Names {

constexpr const char* Extern_Type_Name{"CharacterizationChoiceType"};
constexpr const char* Frequency_Name{"Frequency"};
constexpr const char* IR_Image_Name{"IR_Image"};
constexpr const char* MetricObservations_Name{"MetricObservations"};
constexpr const char* Narrowband_SOI_Name{"Narrowband_SOI"};
constexpr const char* OpticalImage_Name{"OpticalImage"};
constexpr const char* RCS_Name{"RCS"};
constexpr const char* VisMag_Name{"VisMag"};
constexpr const char* Wideband_SOI_Name{"Wideband_SOI"};
constexpr const char* Photometry_Name{"Photometry"};
constexpr const char* ColorPhotometry_Name{"ColorPhotometry"};

} // namespace CharacterizationChoiceType_Names

void CharacterizationChoiceType::deserialize(const boost::property_tree::ptree& propTree, uci::type::CharacterizationChoiceType& accessor, std::string& nodeName, std::string& nsPrefix, const bool topLevel) {
  nodeName = CharacterizationChoiceType_Names::Extern_Type_Name;
  const boost::property_tree::ptree& node = (topLevel ? propTree.ordered_begin()->second : propTree);
  for (const boost::property_tree::ptree::value_type& valueType : node.get_child("")) {
    if ((valueType.first == "<xmlattr>") && topLevel) {
      nsPrefix = asb_uci::util::SerializationHelpers::checkForNamespacePrefix(valueType.second.get_child(""));
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::Frequency_Name) {
      FrequencyParamsType::deserialize(valueType.second, accessor.chooseFrequency(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::IR_Image_Name) {
      IR_ImageParamsType::deserialize(valueType.second, accessor.chooseIR_Image(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::MetricObservations_Name) {
      MetricParamsType::deserialize(valueType.second, accessor.chooseMetricObservations(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::Narrowband_SOI_Name) {
      Narrowband_SOI_ParamsType::deserialize(valueType.second, accessor.chooseNarrowband_SOI(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::OpticalImage_Name) {
      OpticalImageParamsType::deserialize(valueType.second, accessor.chooseOpticalImage(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::RCS_Name) {
      RCS_ParamsType::deserialize(valueType.second, accessor.chooseRCS(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::VisMag_Name) {
      VisMagParamsType::deserialize(valueType.second, accessor.chooseVisMag(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::Wideband_SOI_Name) {
      Wideband_SOI_ParamsType::deserialize(valueType.second, accessor.chooseWideband_SOI(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::Photometry_Name) {
      PhotometryParamsType::deserialize(valueType.second, accessor.choosePhotometry(), nodeName, nsPrefix);
    } else if (valueType.first == nsPrefix + CharacterizationChoiceType_Names::ColorPhotometry_Name) {
      ColorPhotometryParamsType::deserialize(valueType.second, accessor.chooseColorPhotometry(), nodeName, nsPrefix);
    }
  }
}

std::string CharacterizationChoiceType::serialize(const uci::type::CharacterizationChoiceType& accessor, boost::property_tree::ptree& propTree, const std::string& nodeName, const bool createNode, const bool addTypeAttribute, const bool /*checkIfDerivation*/, const bool /*topLevel*/) {
  std::string generatedNodeName{(nodeName.empty() ? CharacterizationChoiceType_Names::Extern_Type_Name : nodeName)};
  boost::property_tree::ptree newNode;
  boost::property_tree::ptree& node = (createNode ? newNode : propTree);
  if (addTypeAttribute) {
    asb_uci::util::SerializationHelpers::addTypeAttribute(node, CharacterizationChoiceType_Names::Extern_Type_Name);
  }
  if (accessor.isFrequency()) {
    FrequencyParamsType::serialize(accessor.getFrequency(), node, CharacterizationChoiceType_Names::Frequency_Name);
  } else if (accessor.isIR_Image()) {
    IR_ImageParamsType::serialize(accessor.getIR_Image(), node, CharacterizationChoiceType_Names::IR_Image_Name);
  } else if (accessor.isMetricObservations()) {
    MetricParamsType::serialize(accessor.getMetricObservations(), node, CharacterizationChoiceType_Names::MetricObservations_Name);
  } else if (accessor.isNarrowband_SOI()) {
    Narrowband_SOI_ParamsType::serialize(accessor.getNarrowband_SOI(), node, CharacterizationChoiceType_Names::Narrowband_SOI_Name);
  } else if (accessor.isOpticalImage()) {
    OpticalImageParamsType::serialize(accessor.getOpticalImage(), node, CharacterizationChoiceType_Names::OpticalImage_Name);
  } else if (accessor.isRCS()) {
    RCS_ParamsType::serialize(accessor.getRCS(), node, CharacterizationChoiceType_Names::RCS_Name);
  } else if (accessor.isVisMag()) {
    VisMagParamsType::serialize(accessor.getVisMag(), node, CharacterizationChoiceType_Names::VisMag_Name);
  } else if (accessor.isWideband_SOI()) {
    Wideband_SOI_ParamsType::serialize(accessor.getWideband_SOI(), node, CharacterizationChoiceType_Names::Wideband_SOI_Name);
  } else if (accessor.isPhotometry()) {
    PhotometryParamsType::serialize(accessor.getPhotometry(), node, CharacterizationChoiceType_Names::Photometry_Name);
  } else if (accessor.isColorPhotometry()) {
    ColorPhotometryParamsType::serialize(accessor.getColorPhotometry(), node, CharacterizationChoiceType_Names::ColorPhotometry_Name);
  }
  if (createNode) {
    propTree.add_child(generatedNodeName, node);
  }
  return generatedNodeName;
}

} // namespace type

} // namespace asb_uci

/** The namespace in which all UCI data types are declared */
namespace uci {

/** The namespace in which all generated data types are declared */
namespace type {

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::create(uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  return *(boost::make_unique<asb_uci::type::CharacterizationChoiceType>().release());
}

uci::type::CharacterizationChoiceType& CharacterizationChoiceType::create(const uci::type::CharacterizationChoiceType& accessor, uci::base::AbstractServiceBusConnection* /*abstractServiceBusConnection*/) {
  std::unique_ptr<asb_uci::type::CharacterizationChoiceType> newAccessor{boost::make_unique<asb_uci::type::CharacterizationChoiceType>()};
  newAccessor->copyImpl(accessor, false);
  return *(newAccessor.release());
}

void CharacterizationChoiceType::destroy(uci::type::CharacterizationChoiceType& accessor) {
  delete dynamic_cast<asb_uci::type::CharacterizationChoiceType*>(&accessor);
}

} // namespace type

} // namespace uci

