/** @file AbstractServiceBusConnection.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:16 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/base/AbstractServiceBusConnection.h"

#include <chrono>
#include <cstdint>
#include <exception>
#include <iostream>
#include <memory>
#include <mutex>
#include <sstream>
#include <string>
#include <thread>
#include <utility>
#include <boost/make_unique.hpp>

#include <activemq/core/ActiveMQConnection.h>
#include <activemq/core/ActiveMQConnectionFactory.h>
#include <activemq/library/ActiveMQCPP.h>
#include <boost/smart_ptr/make_unique.hpp>
#include <cms/Connection.h>

#include "../../../include/asb_uci/base/ConfigReader.h"
#include "../../../include/asb_uci/base/Externalizer.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/Externalizer.h"
#include "../../../include/asb_uci/base/ExternalizerLoader.h"
#include "../../../include/asb_uci/base/ConnectionMonitor.h"
#include "../../../include/asb_uci/base/ConnectionStatus.h"
#include "../../../include/asb_uci/base/Reader.h"
#include "../../../include/asb_uci/base/MessageWriter.h"
#include "../../../include/asb_uci/base/Writer.h"
#include "../../../include/asb_uci/base/AbstractServiceBusConnection.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/AbstractServiceBusConnectionStatusListener.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UUID.h"
#include <log4cpp/Category.hh>//Libreria para los Logs 
#include <log4cpp/PropertyConfigurator.hh> //libreria para los Logs
#include "../../../include/asb_uci/base/UUIDFactory.h"
#include "../../../include/asb_uci/base/MessageReader.h"

/**  */
namespace asb_uci {

/** The namespace in which all base data types are declared */
namespace base {

log4cpp::Category& AbstractServiceBusConnection::root = log4cpp::Category::getRoot();


template <typename T>
std::unique_ptr<asb_uci::base::MessageWriter<T>> AbstractServiceBusConnection::createWriter(const std::string& target, const std::shared_ptr<T>& type) {
    // Llamar a init si no se ha llamado antes (por ejemplo, si se llama desde fuera del constructor)
    if (!connection) {
        init("service_identifier", true);
    }

    auto writer = boost::make_unique<asb_uci::base::MessageWriter<T>>(connection.get(), target, type, externalizer);
    root.info("Created message writer for target {} with type {}", target);

    return writer;
}


  template <typename T>
  std::unique_ptr<asb_uci::base::MessageReader<T>> AbstractServiceBusConnection::createReader(std::string target,const std::shared_ptr<T>& type){
    if (!connection) {
        init("service_identifier", true);
    }

// TODO:tenemos que investigar cuales son los parametros que recibe Reader en su contructor
    auto reader = boost::make_unique<asb_uci::base::MessageReader<T>>(connection.get(), target, type, externalizer);
    root.info("Created message reader for target {} with type {}", target);

    return reader;
  }

asb_uci::base::Externalizer AbstractServiceBusConnection::getExternalizer(std::string externalizerType){
    asb_uci::base::ExternalizerLoader el;
    uci::base::Externalizer* externalizerPtr = el.getExternalizer("XML","3.0","2.3.3");
    
    if(externalizerPtr){
      externalizer = *dynamic_cast<asb_uci::base::Externalizer*>(externalizerPtr);
    }else{
      root.error("Unable to get Externalizer for externalizerType : ");
    }

  return externalizer;
}

uci::base::UUID AbstractServiceBusConnection::generateUUID(){
  uci::base::UUID uuid = uuidFactory.generateUUID();
  root.debug("Created {} uuid '{}'");
  return uuid;
}

uci::base::UUID AbstractServiceBusConnection::getNilUUID(){
  return uuidFactory.getNilUUID();
}

uci::base::UUID AbstractServiceBusConnection::createVersion3UUID(std::string name){
  uci::base::UUID uuid = uuidFactory.createVersion3UUID(name);
  root.debug("Created version 3 (name-based) uuid '{}'");
  return uuid;
}

uci::base::UUID AbstractServiceBusConnection::createVersion3UUID(uci::base::UUID namesp,std::string name){
  uci::base::UUID uuid = uuidFactory.createVersion3UUID(namesp,name);
  root.debug("Created version 3 (name-based) uuid '{}'");

  return uuid;
}

struct AbstractServiceBusConnection::ConnectionComponents {
  bool connected{false};
  std::unique_ptr<activemq::core::ActiveMQConnectionFactory> connectionFactory;
  std::unique_ptr<cms::Connection> connection;
  std::unique_ptr<cms::Session> readerSession;
  std::unique_ptr<cms::Session> writerSession;
  std::unique_ptr<ConnectionMonitor> connectionMonitor;
};

AbstractServiceBusConnection::AbstractServiceBusConnection(std::string asbId)
  : asbId{std::move(asbId)},externalizer("XML", "3.0", "2.3.3") {
}

void AbstractServiceBusConnection::init(const std::string& serviceIdentifier, const bool firstConnection) {
    configReader = boost::make_unique<ConfigReader>(serviceIdentifier);
    connectionStatus = std::make_shared<ConnectionStatus>();

    const ConfigReader::ConnectionMap& connections{ configReader->getConnections() };
    const std::string& defaultConnection{ configReader->getDefaultConnection() };
    if (!configReader->getDefaultConnection().empty()) {
        const auto defaultConn = connections.find(defaultConnection);
        if ((defaultConn != connections.end()) && (connectionComponentsMap.find(defaultConnection) == connectionComponentsMap.end())) {
            connectionComponentsMap.insert({ defaultConnection, std::make_shared<ConnectionComponents>() });
        }
        else {
            throw uci::base::UCIException("Failed to find DefaultConnection " + defaultConnection + " in Connections");
        }
    }
    for (const auto& topic : configReader->getTopics()) {
        const auto topicConn = connections.find(topic.second);
        if (topicConn != connections.end()) {
            if (connectionComponentsMap.find(topic.second) == connectionComponentsMap.end()) {
                connectionComponentsMap.insert({ topic.second, std::make_shared<ConnectionComponents>() });
            }
        }
        else {
            throw uci::base::UCIException("Failed to find Connection " + topic.second + " for Topic " + topic.first);
        }
    }

    if (firstConnection) {
        activemq::library::ActiveMQCPP::initializeLibrary();
    }

    for (auto& component : connectionComponentsMap) {
        const auto& connection = connections.find(component.first)->second; // Obtener la conexiÃ³n correcta
        component.second->connectionFactory = boost::make_unique<activemq::core::ActiveMQConnectionFactory>(connection);
        component.second->connected = false;
        component.second->connectionMonitor = boost::make_unique<ConnectionMonitor>(connectionStatus);
        while (!component.second->connected) {
            try {
                component.second->connection = std::unique_ptr<cms::Connection>(component.second->connectionFactory->createConnection());
                component.second->connection->start();
                component.second->connected = true;
                component.second->readerSession = std::unique_ptr<cms::Session>(component.second->connection->createSession(cms::Session::AUTO_ACKNOWLEDGE));
                component.second->writerSession = std::unique_ptr<cms::Session>(component.second->connection->createSession(cms::Session::AUTO_ACKNOWLEDGE));
                component.second->connection->setExceptionListener(component.second->connectionMonitor.get());
                dynamic_cast<activemq::core::ActiveMQConnection*>(component.second->connection.get())->addTransportListener(component.second->connectionMonitor.get());
            }
            catch (...) {
                if (connection.find("failover:") != std::string::npos) {
                    throw uci::base::UCIException("Failed to establish ActiveMQ connection using URI " + connection);
                }
                component.second->connection.reset();
                std::cout << "Failed to establish ActiveMQ connection using URI " << connection << "\n";
                std::cout << "Will try again in 3 seconds ....\n";
                std::this_thread::sleep_for(std::chrono::seconds(3));
            }
        }
        connectionStatus->updateStatus(uci::base::AbstractServiceBusConnection::NORMAL, "");
    }

    if (firstConnection) {
        std::cout << "ATTENTION: The StarterKit CAL is not to be fielded in an operational capacity. This software is "
                     "intended for research, training, and development use and has undergone neither safety nor software "
                     "assurance testing. Use at your own risk.\n";
    }
}


void AbstractServiceBusConnection::shutdown() {
  for (const auto& component : connectionComponentsMap) {
    // Close the ActiveMQ Connection and sessions
    if (component.second->connection != nullptr && component.second->connected) {
      try {
        component.second->connection->close();
      } catch (...) {
        // close() sometimes throws an exception if in failed state after connection to broker is lost
      }
    }
    component.second->connected = false;

    // Need to delete ActiveMQ components before shutdown
    component.second->readerSession.reset();
    component.second->writerSession.reset();
    component.second->connectionFactory.reset();
    component.second->connection.reset();
  }
  const AsbMapData asbMapData{getAsbMap()};
  const std::lock_guard<std::mutex> guard{*(asbMapData.first)};
  AsbMapType& asbMap = *(asbMapData.second);
  if (asbMap.find(asbId) != asbMap.end()) {
    asbMap.erase(asbId);
  }
  if (asbMap.empty()) {
    activemq::library::ActiveMQCPP::shutdownLibrary();
  }
  // all cleanup done in shutdown(), destructor is protected
  delete this;
}

std::string AbstractServiceBusConnection::getMySystemLabel() const {
  return configReader->getSystemLabel();
}

uci::base::UUID AbstractServiceBusConnection::getMySystemUUID() const {
  return configReader->getSystemId();
}

uci::base::UUID AbstractServiceBusConnection::getMyServiceUUID() const {
  return configReader->getServiceId();
}

uci::base::UUID AbstractServiceBusConnection::getMySubsystemUUID() const {
  return configReader->getSubsystemId();
}

uci::base::UUID AbstractServiceBusConnection::getMyComponentUUID(const std::string& name) const {
  const ConfigReader::UUIDMap& componentIdMap{configReader->getComponentIds()};
  const auto componentId = componentIdMap.find(name);
  return (componentId != componentIdMap.end() ? componentId->second : uci::base::UUID());
}

uci::base::UUID AbstractServiceBusConnection::getMyCapabilityUUID(const std::string& name) const {
  const ConfigReader::UUIDMap& capabilityIdMap{configReader->getCapabilityIds()};
  const auto capabilityId = capabilityIdMap.find(name);
  return (capabilityId != capabilityIdMap.end() ? capabilityId->second : uci::base::UUID());
}

std::string AbstractServiceBusConnection::getAbstractServiceBusConnectionVersion() const {
  return "C++ Starter Kit CAL 2.3.2  CAL-GT: 7.18.0  Schema: 002.3  Build Date: Mon Apr 01 14:25:16 PDT 2024";
}

uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData AbstractServiceBusConnection::getStatus() const {
  return connectionStatus->getStatus();
}

void AbstractServiceBusConnection::addStatusListener(uci::base::AbstractServiceBusConnectionStatusListener& listener) {
  connectionStatus->addStatusListener(listener);
}


void AbstractServiceBusConnection::removeStatusListener(uci::base::AbstractServiceBusConnectionStatusListener& listener) {
  connectionStatus->removeStatusListener(listener);
}

cms::Session* AbstractServiceBusConnection::getReaderSession(const std::string& topic) {
  const ConfigReader::TopicMap& topicMap{configReader->getTopics()};
  const auto existingTopic = topicMap.find(topic);
  const std::string connection{((existingTopic != topicMap.end()) ? existingTopic->second : configReader->getDefaultConnection())};
  return ((!connection.empty()) ? connectionComponentsMap.find(connection)->second->readerSession.get() : nullptr);
}

cms::Session* AbstractServiceBusConnection::getWriterSession(const std::string& topic) {
  const ConfigReader::TopicMap& topicMap{configReader->getTopics()};
  const auto existingTopic = topicMap.find(topic);
  const std::string connection{((existingTopic != topicMap.end()) ? existingTopic->second : configReader->getDefaultConnection())};
  return ((!connection.empty()) ? connectionComponentsMap.find(connection)->second->writerSession.get() : nullptr);
}

std::string AbstractServiceBusConnection::getConfigParam(const std::string& param, const std::string& defaultParam) {
  const ConfigReader::QosParamMap& qosParams{configReader->getQosParams()};
  const auto mapEntry = qosParams.find(param);
  return ((mapEntry != qosParams.end()) ? mapEntry->second : defaultParam);
}

std::int32_t AbstractServiceBusConnection::getConfigParam(const std::string& param, const std::int32_t defaultParam) {
  try {
    const ConfigReader::QosParamMap& qosParams{configReader->getQosParams()};
    const auto mapEntry = qosParams.find(param);
    return ((mapEntry != qosParams.end()) ? std::stoi(mapEntry->second) : defaultParam);
  } catch (const std::exception& e) {
    std::ostringstream errMsg;
    errMsg << "Failed to convert configuration parameter '" << param << "' to integer (" << e.what() << ")";
    throw uci::base::UCIException(errMsg);
  }
}

void AbstractServiceBusConnection::registerReader(ReaderBase* reader) {
  connectionStatus->registerReader(reader);
}

void AbstractServiceBusConnection::registerWriter(WriterBase* writer) {
  connectionStatus->registerWriter(writer);
}

void AbstractServiceBusConnection::unRegisterReader(ReaderBase* reader) {
  connectionStatus->unRegisterReader(reader);
}

void AbstractServiceBusConnection::unRegisterWriter(WriterBase* writer) {
  connectionStatus->unRegisterWriter(writer);
}

AsbMapData getAsbMap() {
  static std::mutex asbMapLock;
  static AsbMapType asbMap;
  return {&asbMapLock, &asbMap};
}

std::ostream& operator<<(std::ostream& oStream, const uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStateEnum& state) {
  if (state == uci::base::AbstractServiceBusConnection::INITIALIZING) {
    return oStream << "INITIALIZING";
  }
  if (state == uci::base::AbstractServiceBusConnection::DEGRADED) {
    return oStream << "DEGRADED";
  }
  if (state == uci::base::AbstractServiceBusConnection::INOPERABLE) {
    return oStream << "INOPERABLE";
  }
  if (state == uci::base::AbstractServiceBusConnection::FAILED) {
    return oStream << "FAILED";
  }
  return oStream << "NORMAL";
}

} // namespace base

} // namespace asb_uci

extern "C" {

uci::base::AbstractServiceBusConnection* uci_getAbstractServiceBusConnection(const std::string& serviceIdentifier, const std::string& typeOfAbstractServiceBusConnection) {
  const asb_uci::base::AsbMapData asbMapData{asb_uci::base::getAsbMap()};
  const std::lock_guard<std::mutex> guard{*(asbMapData.first)};
  asb_uci::base::AsbMapType& asbMap = *(asbMapData.second);
  const bool firstConnection{asbMap.empty()};
  const std::string mapKey{typeOfAbstractServiceBusConnection + serviceIdentifier};
  const auto existingAsb = asbMap.find(mapKey);
  if (existingAsb == asbMap.end()) {
    asb_uci::base::AbstractServiceBusConnection* newAsb{boost::make_unique<asb_uci::base::AbstractServiceBusConnection>(mapKey).release()};
    asbMap.insert({mapKey, newAsb});
    newAsb->init(serviceIdentifier, firstConnection);
    return newAsb;
  }
  return existingAsb->second;
}

}


