/** @file ConnectionStatus.cpp
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:16 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#include "../../../include/asb_uci/base/ConnectionStatus.h"

#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <utility>

#include <boost/smart_ptr/make_unique.hpp>

#include "../../../include/asb_uci/base/Reader.h"
#include "../../../include/asb_uci/base/Writer.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/AbstractServiceBusConnection.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/AbstractServiceBusConnectionStatusListener.h"

/**  */
namespace asb_uci {

/** The namespace in which all base data types are declared */
namespace base {

uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData ConnectionStatus::getStatus() const {
  const std::unique_lock<std::mutex> localLock(stateDataLock);
  return uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData{state, stateDetail};
}

void ConnectionStatus::updateStatus(const uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStateEnum newState, const std::string& newStateDetail) {
  const std::unique_lock<std::mutex> localLock(stateDataLock);
  if ((state != newState) && (state != uci::base::AbstractServiceBusConnection::FAILED)) {
    state = newState;
    stateDetail = newStateDetail;
    {
      // Update status of all current readers
      const std::lock_guard<std::mutex> guard{readersLock};
      for (auto& reader : readers) {
        reader->updateStatus(uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData{state, stateDetail});
      }
    }
    {
      // Update status of all current writers
      const std::lock_guard<std::mutex> guard{writersLock};
      for (auto& writer : writers) {
        writer->updateStatus(uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData{state, stateDetail});
      }
    }
    {
      // Deliver status to all current listeners
      const std::lock_guard<std::mutex> guard{listenersLock};
      for (auto& listener : listeners) {
        listener->push(uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData{state, stateDetail});
      }
    }
    // Notify all blocking reads if new state is failed
    if (state == uci::base::AbstractServiceBusConnection::FAILED) {
      const std::lock_guard<std::mutex> guard{readersLock};
      for (auto& reader : readers) {
        reader->notifyBlockingReads(true);
      }
    }
  }
}

void ConnectionStatus::addStatusListener(uci::base::AbstractServiceBusConnectionStatusListener& listener) {
  std::unique_ptr<AdvisoryStatusListener> newStatusListener{boost::make_unique<AdvisoryStatusListener>(listener)};
  AdvisoryStatusListener* newListener{newStatusListener.get()};
  {
    const std::lock_guard<std::mutex> guard{listenersLock};
    listeners.push_back(std::move(newStatusListener));
  }
  // after registering always callback with current status
  newListener->push(getStatus());
}

void ConnectionStatus::removeStatusListener(uci::base::AbstractServiceBusConnectionStatusListener& listener) {
  const std::lock_guard<std::mutex> guard{listenersLock};
  for (auto& listnr : listeners) {
    if (std::addressof(listnr->getListener()) == std::addressof(listener)) {
      listnr->shutdown();
      listeners.remove(listnr);
      break;
    }
  }
}

void ConnectionStatus::registerReader(ReaderBase* reader) {
  const std::lock_guard<std::mutex> guard{readersLock};
  readers.push_back(reader);
}

void ConnectionStatus::registerWriter(WriterBase* writer) {
  const std::lock_guard<std::mutex> guard{writersLock};
  writers.push_back(writer);
}

void ConnectionStatus::unRegisterReader(ReaderBase* reader) {
  const std::lock_guard<std::mutex> guard{readersLock};
  readers.remove(reader);
}

void ConnectionStatus::unRegisterWriter(WriterBase* writer) {
  const std::lock_guard<std::mutex> guard{writersLock};
  writers.remove(writer);
}

void ConnectionStatus::close() {
  const std::lock_guard<std::mutex> guard{listenersLock};
  for (auto& listnr : listeners) {
    listnr->shutdown();
  }
  listeners.clear();
}

ConnectionStatus::AdvisoryStatusListener::AdvisoryStatusListener(uci::base::AbstractServiceBusConnectionStatusListener& listener)
  : listener(listener) {
  listenerThread = std::thread([this] { process(); });
}

void ConnectionStatus::AdvisoryStatusListener::process() {
  while (running) {
    const std::shared_ptr<uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData> status{queue.wait_and_pop()};
    if (running && status) {
      listener.statusChanged(*status);
    }
  }
}

void ConnectionStatus::AdvisoryStatusListener::push(const uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData& status) {
  queue.push(std::make_shared<uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData>(status));
}

void ConnectionStatus::AdvisoryStatusListener::shutdown() {
  running = false;
  queue.push(std::shared_ptr<uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData>());
  if (listenerThread.joinable()) {
    listenerThread.join();
  }
}

} // namespace base

} // namespace asb_uci

