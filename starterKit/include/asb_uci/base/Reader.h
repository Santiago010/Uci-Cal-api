/** @file Reader.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:16 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef ASB_UCI_BASE_READER_H
#define ASB_UCI_BASE_READER_H

#include <condition_variable>
#include <cstdint>
#include <deque>
#include <memory>
#include <mutex>
#include <set>
#include <sstream>
#include <string>
#include <thread>

#include <boost/lockfree/queue.hpp>
#include <boost/property_tree/xml_parser.hpp>
#include <boost/smart_ptr/make_unique.hpp>
#include <cms/MessageConsumer.h>
#include <cms/MessageListener.h>
#include <cms/Session.h>
#include <cms/Topic.h>

#include "AbstractServiceBusConnection.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"

/**  */
namespace asb_uci {

/** The namespace in which all base data types are declared */
namespace base {

/** The Reader provides a base class for all Reader */
class ReaderBase {
public:
  /** The constructor */
  ReaderBase() = default;

  /** The copy constructor
    *
    * @param rhs The ReaderBase to copy from
    */
  ReaderBase(const ReaderBase& rhs) = default;

  /** The move constructor
    *
    * @param rhs The ReaderBase to move from
    */
  ReaderBase(ReaderBase&& rhs) = default;

  /** The assignment operator
    *
    * @param rhs The ReaderBase to copy from
    * @return The ReaderBase that was assigned
    */
  ReaderBase& operator=(const ReaderBase& rhs) = default;

  /** The move assignment operator
    *
    * @param rhs The ReaderBase to move from
    * @return The ReaderBase that was assigned
    */
  ReaderBase& operator=(ReaderBase&& rhs) = default;

  /** The destructor */
  virtual ~ReaderBase() = default;

  /** Initializes reader */
  virtual void init() = 0;

  /** Notifies blocking reads of this reader.
    *
    * @param asbcFailed True if Abstract Service Bus Connection status is failed
    */
  virtual void notifyBlockingReads(bool asbcFailed) = 0;

  /** Update status of Abstract Service Bus Connection associated with reader
    *
    * @param newStatus New Abstract Service Bus Connection status
    */
  virtual void updateStatus(const uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData& newStatus) = 0;

};

/** The Reader provides the support required to read messages */
template<typename T_UCI, typename T_ASB_UCI>
class Reader : public T_UCI::Reader, public ReaderBase, public cms::MessageListener {
public:
  /** The constructor
    *
    * @param topic The name of the topic to be subscribed
    * @param asbConnection XCC Manager used by this Reader
    */
  Reader(const std::string& topic, uci::base::AbstractServiceBusConnection* asbConnection)
    : topic{topic},
      abstractServiceBusConnection{dynamic_cast<asb_uci::base::AbstractServiceBusConnection*>(asbConnection)},
      asbConnectionStatusData(abstractServiceBusConnection->getStatus()) {
    if ((topic.empty()) || (asbConnection == nullptr)) {
      throw uci::base::UCIException("Failed to create reader for topic " + topic + ": invalid argument");
    }
    maxQueueSize = abstractServiceBusConnection->getConfigParam("ReaderQueueMax", defaultReaderQueueSize);
    abstractServiceBusConnection->registerReader(this);
    cms::Session* session{abstractServiceBusConnection->getReaderSession(topic)};
    if (session != nullptr) {
      try {
        cmsTopic.reset(session->createTopic(topic));
        cmsConsumer.reset(session->createConsumer(cmsTopic.get(), "", (abstractServiceBusConnection->getConfigParam("ActiveMQNoEchoMode", 0) == 1)));
        cmsConsumer->setMessageListener(this);
      } catch (...) {
        cmsTopic.reset();
        cmsConsumer.reset();
        throw uci::base::UCIException("Failed to create reader for topic " + topic + ": failed to create ActiveMQ topic/consumer");
      }
    } else {
      throw uci::base::UCIException("Failed to create reader for topic " + topic + ": topic not found and no DefaultConnection specified");
    }
  }

  /** The copy constructor
    *
    * @param rhs The Reader to copy from
    */
  Reader(const Reader& rhs) = delete;

  /** The move constructor
    *
    * @param rhs The Reader to move from
    */
  Reader(Reader&& rhs) = delete;

  /** The assignment operator
    *
    * @param rhs The Reader to copy from
    * @return The Reader that was assigned
    */
  Reader& operator=(const Reader& rhs) = delete;

  /** The move assignment operator
    *
    * @param rhs The Reader to move from
    * @return The Reader that was assigned
    */
  Reader& operator=(Reader&& rhs) = delete;

  /** The destructor */
  ~Reader() override {
    abstractServiceBusConnection->unRegisterReader(this);
    close();
  }

  /** Initializes reader */
  void init() override {
    updateStatus(asbConnectionStatusData);
  }

  /** Registers a listener that will listen for new messages as they arrive. When a new message arrives, the aircraft
    * service bus will invoke the listener's handleMessage() method with the appropriate arguments. The pointer to the
    * message is guaranteed to be valid as long as the listener's handleMessage() method does not return. Once the
    * handleMessage() method returns, the message pointer should no longer considered to be valid.
    *
    * @param listener The listener whose handleMessage() method will be invoked when a new message arrives
    */
  void addListener(typename T_UCI::Listener& listener) override {
    {
      const std::lock_guard<std::mutex> guard{asbConnectionStatusDataLock};
      if (!allowAddListener) {
        std::ostringstream errMsg;
        errMsg << "Unable to execute addListener() for topic " << topic << " when the ASB state is " << asbConnectionStatusData.state;
        throw uci::base::UCIException(errMsg);
      }
    }
    const std::lock_guard<std::mutex> guard{messageLock};
    listenerSet.insert(std::make_shared<ReaderListener>(topic, abstractServiceBusConnection, listener, notificationCondition, notificationLock));
  }

  /** Removes the specified listener that was previously added to listen to the arrival of new messages.
    *
    * @param listener The listener that is to be removed.
    */
  void removeListener(typename T_UCI::Listener& listener) override {
    const std::lock_guard<std::mutex> guard{messageLock};
    for (const auto& listnr : listenerSet) {
      if (&(listnr->getListener()) == &listener) {
        listnr->shutdown();
        listenerSet.erase(listnr);
        break;
      }
    }
  }

  /** Reads arriving messages. If no messages have arrived previous to the invocation of this method, then this method will
    * will return immediately.
    *
    * @param maxNumberOfMessages The maximum number of messages that will be handled by this read request.
    * @param listener The listener whose handleMessage() method will be invoked to handle existing messages.
    * @return The number of messages that were handled
    * @note Unlike the handling of arriving messages by the listener's handleMessage() method when the listener has been
    *      added, this method executes in the same thread that this method was invoked in.
    */
  unsigned long readNoWait(unsigned long maxNumberOfMessages, typename T_UCI::Listener& listener) override {
    {
      const std::lock_guard<std::mutex> guard{asbConnectionStatusDataLock};
      if (!allowReadNoWait) {
        std::ostringstream errMsg;
        errMsg << "Unable to execute readNoWait() for topic " << topic << " when the ASB state is " << asbConnectionStatusData.state;
        throw uci::base::UCIException(errMsg);
      }
    }
    return readImplementation(false, 0, maxNumberOfMessages, listener);
  }

  /** Reads arriving messages. If no messages have arrived previous to the invocation of this method, then this method will
    * block waiting for messages to arrive or until the timeout expires in which case this method will immediately return.
    * Once messages are available for processing, the specified listener's handleMessage() method will be invoked for each
    * message that has been received up to the maximum number of messages. Once all recieved messages have been process or
    * the maximum number of messages have been processed, then this method will return.
    *
    * @param timeout Maximum time in microseconds to wait for new messages to arrive. The timeout is ignored if one or
    *      messages are already queued. After first invocation of the listener's handleMessage(), this timeout is ignored.
    *      A zero indicates that the read should wait forever.
    * @param maxNumberOfMessages The maximum number of messages that will be handled by this read request.
    * @param listener The listener whose handleMessage() method will be invoked to handle existing messages.
    * @return The number of messages that were handled
    * @note Unlike the handling of arriving messages by the listener's handleMessage() method when the listener has been
    *      added, this method executes in the same thread that this method was invoked in.
    */
  unsigned long read(unsigned long timeout, unsigned long maxNumberOfMessages, typename T_UCI::Listener& listener) override {
    {
      const std::lock_guard<std::mutex> guard{asbConnectionStatusDataLock};
      if (!allowRead) {
        std::ostringstream errMsg;
        errMsg << "Unable to execute read() for topic " << topic << " when the ASB state is " << asbConnectionStatusData.state;
        throw uci::base::UCIException(errMsg);
      }
    }
    return readImplementation(true, timeout, maxNumberOfMessages, listener);
  }

  /** Closes this reader. Once closed, any further attempts to use this reader to read messages will result in an error
    * condition and an exception being thrown.
    */
  void close() override {
    for (const auto& listnr : listenerSet) {
      listnr->shutdown();
    }
    listenerSet.clear();
    notifyBlockingReads(false);
    cmsTopic.reset();
    cmsConsumer.reset();
  }

  /** Notifies blocking reads of this reader.
    *
    * @param asbcFailed True if Abstract Service Bus Connection status is failed
    */
  void notifyBlockingReads(bool asbcFailed) override {
    readerState = (asbcFailed ? ReaderState::FAILED : ReaderState::CLOSED);
    notificationCondition.notify_all();
  }

  /** Update status of Abstract Service Bus Connection associated with reader
    *
    * @param newStatus New Abstract Service Bus Connection status
    */
  void updateStatus(const uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData& newStatus) override {
    const std::lock_guard<std::mutex> guard{asbConnectionStatusDataLock};
    asbConnectionStatusData = newStatus;
    allowAddListener = (asbConnectionStatusData.state != uci::base::AbstractServiceBusConnection::FAILED);
    allowRead = (asbConnectionStatusData.state != uci::base::AbstractServiceBusConnection::FAILED);
    allowReadNoWait = ((asbConnectionStatusData.state == uci::base::AbstractServiceBusConnection::NORMAL) || (asbConnectionStatusData.state == uci::base::AbstractServiceBusConnection::DEGRADED));
  }

private:
  /** Implementation for reading messages.
    *
    * @param enableTimeout Indicates that timeout processing is enabled or not, if so the timeout parameter is used to wait
    *      for a message. Otherwise, if a message is not ready inthe queue will return immediately without waiting.
    * @param timeout Maximum time in microseconds to wait for new messages to arrive. The timeout is ignored if one or
    *      messages are already queued. After first invocation of the listener's handleMessage(), this timeout is ignored.
    *      A zero indicates that the read should wait forever.
    * @param maxNumberOfMessages The maximum number of messages that will be handled by this read request.
    * @param listener The listener whose handleMessage() method will be invoked to handle existing messages.
    * @return The number of messages that were handled
    * @note Unlike the handling of arriving messages by the listener's handleMessage() method when the listener has been
    *      added, this method executes in the same thread that this method was invoked in.
    */
  unsigned long readImplementation(bool enableTimeout, unsigned long timeout, unsigned long maxNumberOfMessages, typename T_UCI::Listener& listener) {
    // May have to wait for a message to arrive if the queue is empty
    if (messageQueue.empty()) {
      // However, if timeouts are disabled return immediately
      if (!enableTimeout) {
        return 0;
      }
      try {
        std::unique_lock<std::mutex> localLock(notificationLock);
        // A timeout value of 0 indicates we wait indefinitely for the message to arrive
        if (timeout == 0) {
          notificationCondition.wait(localLock);
        } else {
          if (notificationCondition.wait_for(localLock, std::chrono::microseconds{timeout}) == std::cv_status::timeout) {
            return 0;
          }
        }
      } catch (...) {
        notificationLock.unlock();
        return 0;
      }
    }
    if (readerState == ReaderState::CLOSED) {
      return 0;
    }
    if (readerState == ReaderState::FAILED) {
      throw uci::base::UCIException("Unable to execute read()/readNoWait() for topic " + topic + " when the ASB state is FAILED");
    }
    unsigned long messageCounter{0};
    try {
      while (!messageQueue.empty() && (messageCounter < maxNumberOfMessages)) {
        messageLock.lock();
        const std::shared_ptr<cms::Message> msg{messageQueue.back()};
        messageQueue.pop_back();
        messageLock.unlock();
        std::unique_ptr<T_ASB_UCI> accessor;
        {
          const auto* text_msg = dynamic_cast<const cms::TextMessage*>(msg.get());
          if (text_msg != nullptr) {
            std::istringstream inputStream(text_msg->getText());
            boost::property_tree::ptree propTree;
            boost::property_tree::xml_parser::read_xml(inputStream, propTree, boost::property_tree::xml_parser::no_comments);
            accessor = boost::make_unique<T_ASB_UCI>();
            std::string nodeName;
            std::string nsPrefix;
            T_ASB_UCI::deserialize(propTree, *accessor, nodeName, nsPrefix, true);
          } else {
            throw uci::base::UCIException("Error during read for topic " + topic + ": unable to deserialize");
          }
        }
        if (accessor) {
          listener.handleMessage(*accessor);
          ++messageCounter;
        } else {
          throw uci::base::UCIException("Error during read for topic " + topic + ": invalid object");
        }
      }
    } catch (const std::exception& e) {
      std::ostringstream errMsg;
      errMsg << "Error during read for topic " << topic << ": exception" << e.what();
      throw uci::base::UCIException(errMsg);
    } catch (...) {
      throw uci::base::UCIException("Error during read for topic " + topic + ": exception not derived from std::exception");
    }
    return messageCounter;
  }

  /** .
    *
    * @param msg .
    */
  void onMessage(const cms::Message* msg) override {
    try {
      const std::lock_guard<std::mutex> guard{messageLock};
      if (msg != nullptr) {
        // If there are no listeners queue the message up, otherwise push the message to all registered listeners
        if (listenerSet.empty()) {
          messageQueue.push_front(std::shared_ptr<cms::Message>(msg->clone()));
          if (messageQueue.size() > maxQueueSize) {
            std::cout << "Message receive queue exceeded limit for topic " << topic << ", removing oldest message(s) \n";
            messageQueue.pop_back();
          }
          // ... otherwise drain the message queue and push the message to all registered listeners
        } else {
          // Deliver all messages that are queued to the listeners, draining the queue
          while (!messageQueue.empty()) {
            const std::shared_ptr<cms::Message>msgQ{messageQueue.back()};
            messageQueue.pop_back();
            // Deliver message copies to all current listeners
            for (const auto& listnr : listenerSet) {
              cms::Message* msgQClone = msgQ->clone();
              if (!listnr->push(msgQClone)) {
                std::cout << "Processing message receive queue exceeded limit for topic " << topic << "\n";
                delete msgQClone;
              }
            }
          }
          // Deliver message copies to all current listeners
          for (const auto& listnr : listenerSet) {
            cms::Message* msgClone = msg->clone();
            if (!listnr->push(msgClone)) {
              std::cout << "Processing message receive queue exceeded limit for topic " << topic  << "\n";
              delete msgClone;
            }
          }
        }
        // Wake-up the message processors or read/readNoWait functions to push messages to the listeners
        {
          const std::unique_lock<std::mutex> localLock(notificationLock);
          notificationCondition.notify_all();
        }
      }
    } catch (...) {
      std::cout << "Exception during attempt to queue message for topic " << topic << ": unknown error, message dropped";
    }
  }

  /** . */
  class ReaderListener {
  public:
    /** The constructor
      *
      * @param topic .
      * @param abstractServiceBusConnection .
      * @param listener .
      * @param notificationCondition .
      * @param notificationLock .
      */
    ReaderListener(std::string topic, asb_uci::base::AbstractServiceBusConnection* abstractServiceBusConnection, typename T_UCI::Listener& listener, std::condition_variable& notificationCondition, std::mutex& notificationLock)
      : topic{std::move(topic)},
        abstractServiceBusConnection{abstractServiceBusConnection},
        listener(listener),
        queue{defaultListenerQueueSize},
        notificationLock(notificationLock),
        notificationCondition(notificationCondition) {
      listenerThread = std::thread([this] { processMessage(); });
    }

    /** .
      *
      * @param msg .
      * @return .
      */
    bool push(cms::Message* msg) {
      return queue.push(msg);
    }

    /** . */
    void shutdown() {
      running = false;
      // Wake-up the message processors in the listeners
      notificationCondition.notify_all();
      listenerThread.join();
    }

    /** .
      *
      * @return .
      */
    typename T_UCI::Listener& getListener() {
      return listener;
    }

  private:
    /** . */
    void processMessage() {
      cms::Message* msg{nullptr};
      while (running) {
        if (queue.empty()) {
          try {
            // Wait for a message to come in and for the queue to have something in it
            std::unique_lock<std::mutex> localLock(notificationLock);
            notificationCondition.wait(localLock);
          } catch (...) {
            notificationLock.unlock();
            continue;
          }
        }
        if (! running) {
          break;
        }
        while (queue.pop(msg)) {
          if (running) {
            // Drain the message queue
            std::unique_ptr<T_ASB_UCI> accessor;
            try {
              const auto* text_msg = dynamic_cast<const cms::TextMessage*>(msg);
              if (text_msg != nullptr) {
                std::istringstream inputStream(text_msg->getText());
                boost::property_tree::ptree propTree;
                boost::property_tree::xml_parser::read_xml(inputStream, propTree, boost::property_tree::xml_parser::no_comments);
                accessor = boost::make_unique<T_ASB_UCI>();
                std::string nodeName;
                std::string nsPrefix;
                T_ASB_UCI::deserialize(propTree, *accessor, nodeName, nsPrefix, true);
              }
            } catch (const std::exception& e) {
              accessor.reset();
              std::cout << "Unable to deserialize message for topic " << topic << ": exception" << e.what();
            } catch (...) {
              accessor.reset();
              std::cout << "Unable to deserialize message for topic " << topic;
            }
            if (accessor) {
              try {
                listener.handleMessage(*accessor);
              } catch (...) {
                std::cout << "Exception in listener of message for topic " << topic;
              }
            }
          }
          delete msg;
        }
      }
    }

    std::string topic;
    asb_uci::base::AbstractServiceBusConnection* abstractServiceBusConnection;
    typename T_UCI::Listener& listener;
    boost::lockfree::queue<cms::Message*> queue;
    std::thread listenerThread;
    std::mutex& notificationLock;
    std::condition_variable& notificationCondition;
    bool running{true};
  };

  enum class ReaderState {
    OPEN,
    CLOSED,
    FAILED
  };

  const std::string topic;
  asb_uci::base::AbstractServiceBusConnection* abstractServiceBusConnection;
  std::unique_ptr<cms::Topic> cmsTopic;
  std::unique_ptr<cms::MessageConsumer> cmsConsumer;
  std::mutex messageLock;
  std::mutex notificationLock;
  std::condition_variable notificationCondition;
  bool asbStateFailed{false};
  std::deque<std::shared_ptr<cms::Message>> messageQueue;
  std::set<std::shared_ptr<ReaderListener>> listenerSet;
  std::uint32_t maxQueueSize;
  uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData asbConnectionStatusData;
  std::mutex asbConnectionStatusDataLock;
  bool allowAddListener{true};
  bool allowRead{true};
  bool allowReadNoWait{true};
  ReaderState readerState{ReaderState::OPEN};
  static constexpr std::int32_t defaultListenerQueueSize{512};
  static constexpr std::int32_t defaultReaderQueueSize{1000};
};

} // namespace base

} // namespace asb_uci

#endif // ASB_UCI_BASE_READER_H
