/** @file PrimitiveList.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:16 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef ASB_UCI_BASE_PRIMITIVELIST_H
#define ASB_UCI_BASE_PRIMITIVELIST_H

#include <vector>

#include <boost/smart_ptr/make_unique.hpp>

#include "../../../../cppInterface/2.3.2/include/uci/base/Accessor.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/SimpleList.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"

/**  */
namespace asb_uci {

/** The namespace in which all base data types are declared */
namespace base {

/** The PrimitiveList is the base class that all bounded lists are derived from. */
template<typename T, uci::base::accessorType::AccessorType V = 0>
class PrimitiveList : public virtual uci::base::SimpleList<T,V> {
public:
  using size_type = typename uci::base::SimpleList<T,V>::size_type;
  using reference = typename uci::base::SimpleList<T,V>::reference;
  using const_reference = typename uci::base::SimpleList<T,V>::const_reference;

  /** The constructor */
  PrimitiveList()
    : list_minimumSize{0},
      list_maximumSize{SIZE_MAX},
      list_accessorData{boost::make_unique<std::vector<T>>()} {
  }

  /** The copy constructor [not supported]
    *
    * @param rhs The PrimitiveList to copy from
    */
  PrimitiveList(const PrimitiveList& rhs) {
    copy(rhs);
  }

  /** The move constructor
    *
    * @param rhs The PrimitiveList to move from
    */
  PrimitiveList(PrimitiveList&& rhs) = delete;

  /** The assignment operator [not supported]
    *
    * @param rhs The PrimitiveList to copy from
    * @return The PrimitiveList that was assigned
    */
  PrimitiveList& operator=(const PrimitiveList& rhs) {
    copy(rhs);
    return *this;
  }

  /** The move assignment operator
    *
    * @param rhs The PrimitiveList to move from
    * @return The PrimitiveList that was assigned
    */
  PrimitiveList& operator=(PrimitiveList&& rhs) = delete;

  /** The destructor */
  virtual ~PrimitiveList() = default;

  /** Returns the number of elements in the PrimitiveList. This number is the number of actual objects held in the
    * PrimitiveList, which is not necessarily equal to its storage capacity.
    *
    * @return The number of actual objects held in the PrimitiveList.
    */
  size_type size() const noexcept override {
    return list_accessorData->size();
  }

  /** Returns the maximum number of elements that the PrimitiveList should hold in order to be consider valid with respect
    * to the XSD specification used to generate this containers specification. The value returned is the same that is
    * returned by the getMaxOccurs() method. If not specified in the XSD, then this is the maximum size the container can
    * reach due to known system or library implementation limitations, but the container is by no means guaranteed to be
    * able to reach that size: it can still fail to allocate storage at any point before that size is reached.
    *
    * @return The maximum number of elements that the PrimitiveList should hold in order to be considered valid.
    */
  size_type max_size() const noexcept override {
    return list_maximumSize;
  }

  /** Returns the minimum number of elements the container should hold in order to be considered valid with respect to the
    * XSD specification used to generate this containers specification. The value returned is the same that is returned by
    * the getMinOccurs() method.
    *
    * @return The minimum number of elements that the PrimitiveList should hold in order to be considered valid.
    */
  size_type min_size() const noexcept override {
    return list_minimumSize;
  }

  /** Resizes the container so that it contains n elements.
    *
    * @param newSize The size of the container after it has been resized. If newSize is smaller than the current container
    *      size, the content of the PrimitiveList is reduced to its first n elements, removing those beyond (and destroying
    *      them). If newSize is greater than the current container size, the content of the PrimitiveList is expanded by
    *      inserting at the end as many elements as needed to reach a size of newSize. The newly added elements are value
    *      initialized (initialized according to their type). If newSize is greater than the current container capacity, an
    *      automatic reallocation of the allocated storage space takes place. Notice that this method changes the actual
    *      content of the container by inserting or erasing elements from it.
    * @param type The size of the container after it has been resized. If newSize is smaller than the current container
    *      size, the content of the PrimitiveList is reduced to its first n elements, removing those beyond (and destroying
    *      them). If newSize is greater than the current container size, the content of the PrimitiveList is expanded by
    *      inserting at the end as many elements as needed to reach a size of newSize. The newly added elements are value
    *      initialized (initialized according to their type). If newSize is greater than the current container capacity, an
    *      automatic reallocation of the allocated storage space takes place. Notice that this method changes the actual
    *      content of the container by inserting or erasing elements from it.
    */
  void resize(size_type newSize, uci::base::accessorType::AccessorType /*type*/ = V) override {
    const size_type actualNewSize{(newSize < list_maximumSize) ? newSize : list_maximumSize};
    if (actualNewSize > list_accessorData->size()) {
      while (actualNewSize > list_accessorData->size()) {
        list_accessorData->push_back({});
      }
    } else {
      list_accessorData->resize(actualNewSize);
    }
  }

  /** Returns the size of allocated storage capacity expressed in terms of elements
    *
    * @return The size of the storage space currently allocated for the PrimitiveList, expressed in terms of elements. This
    *      capacity is not necessarily equal to the PrimitiveList size. It can be equal or greater, with the extra space
    *      allowing to accommodate for growth without the need to reallocate on each insertion. Notice that this capacity
    *      does not suppose a limit on the size of the PrimitiveList. When this capacity is exhausted and more is needed,
    *      it is automatically expanded by the container (reallocating it storage space). The theoretical limit on the size
    *      of a PrimitiveList is given by member max_size. The capacity of a PrimitiveList can be explicitly altered by
    *      calling member PrimitiveList::reserve.
    */
  size_type capacity() const noexcept override {
    return list_accessorData->capacity();
  }

  /** Tests whether PrimitiveList is empty.
    *
    * @return Returns whether the PrimitiveList is empty, i.e. whether its size is 0, (true) or not (false).
    * @note This function does not modify the container in any way. To clear the contents of a PrimitiveList, see
    *      PrimitiveList::clear.
    * @note This function is equivalent to "size() == 0" but may offer better performance due to implementation
    *      constraints.
    */
  bool empty() const noexcept override {
    return list_accessorData->empty();
  }

  /** Request a change in the PrimitiveList's capacity such that the capacity be at least large enough to contain n
    * elements.
    *
    * @param newCapacity If newCapacity is greater than the PrimitiveList's current capacity, then the PrimitiveList's
    *      capacity will be increased to the new capacity. This action may result in a reallocation of the PrimitiveList's
    *      storage using new storage whose capacity is equal to or greater than newCapacity. Such a reallocation will cause
    *      all elements to be copied to the new storage and the original storage to be deleted. In all other cases, the
    *      function call does not cause a reallocation and the PrimitiveList capacity is not affected.
    * @note This function has no effect on the PrimitiveList size and cannot alter its elements.
    */
  void reserve(size_type newCapacity) override {
    list_accessorData->reserve((newCapacity < list_maximumSize) ? newCapacity : list_maximumSize);
  }

  /** Removes the last element in the PrimitiveList, effectively reducing the container size by one. This destroys the
    * removed element.
    */
  void pop_back() noexcept override {
    if (!list_accessorData->empty()) {
      list_accessorData->pop_back();
    }
  }

  /** Removes all elements from the PrimitiveList (which are destroyed), leaving the PrimitiveList with a size of 0. */
  void clear() noexcept override {
    list_accessorData->clear();
  }

  /** The returns this PrimitiveList's "maxOccurs" as specified in the XML Schema specification.
    *
    * @return The PrimitiveList's "maxOccurs".
    * @note The value returned is the same as that returned by max_size()
    */
  size_type getMaximumLength() const noexcept override {
    return list_maximumSize;
  }

  /** The returns this PrimitiveList's "minOccurs" as specified in the XML Schema specification.
    *
    * @return The PrimitiveList's "minOccurs".
    * @note The value returned is the same as that returned by min_size()
    */
  size_type getMinimumLength() const noexcept override {
    return list_minimumSize;
  }

  /** The returns this PrimitiveList's length.
    *
    * @return The PrimitiveList's length.
    */
  size_type getLength() const noexcept override {
    return list_maximumSize;
  }

  /** Returns a reference to the enumerated item at position n in the PrimitiveList.
    *
    * @param index The index of the element in this PrimitiveList a reference to which is to be returned.
    * @return The reference to the element at position n in the PrimitiveList.
    * @note No bounds checking is performed by this operator. See PrimitiveList::at() for a version of this operator that
    *      does perform bounds checking. Unexpected results, including the throwing of exceptions, may occur if the index
    *      is out of range.
    */
  reference operator[](size_type index) override {
    return (*list_accessorData)[index];
  }

  /** Returns a reference to the enumerated item at position n in the PrimitiveList.
    *
    * @param index The index of the element in this PrimitiveList a reference to which is to be returned.
    * @return The constant reference to the element at position n in the PrimitiveList.
    * @note No bounds checking is performed by this operator. See PrimitiveList::at() for a version of this operator that
    *      does perform bounds checking. Unexpected results, including the throwing of exceptions, may occur if the index
    *      is out of range.
    */
  const_reference operator[](size_type index) const override {
    return (*list_accessorData)[index];
  }

  /** Returns a reference to the element at position n in the PrimitiveList container. This method automatically checks
    * whether the index is within the bounds of valid elements in the PrimitiveList, throwing an out_of_range exception if
    * it is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not
    * check against bounds.
    *
    * @param index The index of the element in this PrimitiveList a reference to which is to be returned. If this is
    *      greater than or equal to the PrimitiveList size, an exception of type out_of_range is thrown. Notice that the
    *      first element has a position of 0 (not 1).
    * @return The reference to the element at position index in the PrimitiveList.
    */
  reference at(size_type index) override {
    if (index < list_accessorData->size()) {
      return (*list_accessorData)[index];
    }
    throw uci::base::UCIException("Error in PrimitiveList::at(): Attempted to access an out of bounds index");
  }

  /** Returns a reference to the element at position n in the PrimitiveList container. This method automatically checks
    * whether the index is within the bounds of valid elements in the PrimitiveList, throwing an out_of_range exception if
    * it is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not
    * check against bounds.
    *
    * @param index The index of the element in this PrimitiveList a reference to which is to be returned. If this is
    *      greater than or equal to the PrimitiveList size, an exception of type out_of_range is thrown. Notice that the
    *      first element has a position of 0 (not 1).
    * @return The reference to the enumerate item at position index in the PrimitiveList.
    */
  const_reference at(size_type index) const override {
    if (index < list_accessorData->size()) {
      return (*list_accessorData)[index];
    }
    throw uci::base::UCIException("Error in PrimitiveList::at(): Attempted to access an out of bounds index");
  }

  /** Adds a new element at the end of the PrimitiveList, after its current last element. The content of value is copied
    * (or moved) to the new element. This effectively increases the container size by one, which causes an automatic
    * reallocation of the allocated storage space if, and only if, the new PrimitiveList size surpasses the current
    * PrimitiveList capacity.
    *
    * @param value The value to be copied (or moved into the new element.
    */
  void push_back(const_reference value) override {
    if (list_accessorData->size() < list_maximumSize) {
      list_accessorData->push_back(value);
      return;
    }
    throw uci::base::UCIException("Error in PrimitiveList::push_back(): Addition would exceed maximum size of list (" + std::to_string(list_maximumSize) + ")");
  }

  /** Resets the PrimitiveList */
  void reset() noexcept override {
    list_accessorData->clear();
  }

  /** Creates a new message data by performing a deep copy of the message data that the specified accessor provides access
    * to. The message data this accessor provides access to is freed and this accessor is updated to provide access to the
    * newly created message data.
    *
    * @param accessor The uci::base::SimpleList<T,V> whose contents are to be used to set this uci::base::SimpleList<T,V>'s
    *      contents.
    */
  void copy(const uci::base::SimpleList<T,V>& accessor) {
    copyImpl(accessor, false);
  }

  /** Creates a new message data by performing a deep copy of the message data that the specified accessor provides access
    * to. The message data this accessor provides access to is freed and this accessor is updated to provide access to the
    * newly created message data.
    *
    * @param accessor The uci::base::SimpleList<T,V> whose contents are to be used to set this uci::base::SimpleList<T,V>'s
    *      contents.
    * @param checkIfDerivation Check if accessor to copy is a derived type.
    */
  void copyImpl(const uci::base::SimpleList<T,V>& accessor, const bool /*checkIfDerivation*/) {
    if (&accessor != this) {
      const PrimitiveList<T,V>& accessorImpl(dynamic_cast<const PrimitiveList<T,V>&>(accessor));
      list_minimumSize = accessorImpl.list_minimumSize;
      list_maximumSize = accessorImpl.list_maximumSize;
      list_accessorData = boost::make_unique<std::vector<T>>();
      list_accessorData->reserve(accessorImpl.list_accessorData->size());
      for (const auto& listAccessor : (*accessorImpl.list_accessorData)) {
        list_accessorData->push_back(listAccessor);
      }
    }
  }

  /** 
    *
    * @param type .
    * @return .
    */
  static std::unique_ptr<PrimitiveList<T,V>> create(const uci::base::accessorType::AccessorType /*type*/) {
    return boost::make_unique<PrimitiveList<T,V>>();
  }

  using vector_type = std::vector<T>;
  using iterator = typename vector_type::iterator;
  using const_iterator = typename vector_type::const_iterator;

  /** Return an iterator that represents the beginning of elements in the container
    *
    * @return .
    */
  iterator begin() noexcept {
    return list_accessorData->begin();
  }

  /** Return a const iterator that represents the beginning of elements in the container
    *
    * @return .
    */
  const_iterator cbegin() const noexcept {
    return list_accessorData->cbegin();
  }

  /** Return an iterator that represents the end of elements in the container
    *
    * @return .
    */
  iterator end() noexcept {
    return list_accessorData->end();
  }

  /** Return a const iterator that represents the end of elements in the container
    *
    * @return .
    */
  const_iterator cend() const noexcept {
    return list_accessorData->cend();
  }

private:
  size_type list_minimumSize;
  size_type list_maximumSize;
  std::unique_ptr<std::vector<T>> list_accessorData;

};

} // namespace base

} // namespace asb_uci

#endif // ASB_UCI_BASE_PRIMITIVELIST_H
