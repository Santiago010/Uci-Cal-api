/** @file Writer.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:16 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef ASB_UCI_BASE_WRITER_H
#define ASB_UCI_BASE_WRITER_H

#include <cstdint>
#include <memory>
#include <sstream>
#include <string>

#include <boost/property_tree/xml_parser.hpp>
#include <cms/MessageProducer.h>
#include <cms/Session.h>
#include <cms/Topic.h>

#include "asb_uci/base/AbstractServiceBusConnection.h"
#include "asb_uci/util/SerializationHelpers.h"
#include "uci/base/UCIException.h"

/**  */
namespace asb_uci {

/** The namespace in which all base data types are declared */
namespace base {

/** The Writer provides a base class for all Writer */
class WriterBase {
public:
  /** The constructor */
  WriterBase() = default;

  /** The copy constructor
    *
    * @param rhs The WriterBase to copy from
    */
  WriterBase(const WriterBase& rhs) = default;

  /** The move constructor
    *
    * @param rhs The WriterBase to move from
    */
  WriterBase(WriterBase&& rhs) = default;

  /** The assignment operator
    *
    * @param rhs The WriterBase to copy from
    * @return The WriterBase that was assigned
    */
  WriterBase& operator=(const WriterBase& rhs) = default;

  /** The move assignment operator
    *
    * @param rhs The WriterBase to move from
    * @return The WriterBase that was assigned
    */
  WriterBase& operator=(WriterBase&& rhs) = default;

  /** The destructor */
  virtual ~WriterBase() = default;

  /** Initializes writer */
  virtual void init() = 0;

  /** Update status of Abstract Service Bus Connection associated with writer
    *
    * @param newStatus New Abstract Service Bus Connection status
    */
  virtual void updateStatus(const uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData& newStatus) = 0;

};

/** The Writer provides the support required to write messages to specified targets. */
template<typename T_UCI, typename T_ASB_UCI>
class Writer : public T_UCI::Writer, public WriterBase {
public:
  /** The constructor
    *
    * @param topic The topic to be written
    * @param asbConnection abstract service bus connection
    */
  Writer(const std::string& topic, uci::base::AbstractServiceBusConnection* asbConnection)
    : topic{topic},
      abstractServiceBusConnection{dynamic_cast<asb_uci::base::AbstractServiceBusConnection*>(asbConnection)},
      asbConnectionStatusData(abstractServiceBusConnection->getStatus()) {
    if ((topic.empty()) || (asbConnection == nullptr)) {
      throw uci::base::UCIException("Failed to create writer - invalid argument");
    }
    abstractServiceBusConnection->registerWriter(this);
    cms::Session* session{abstractServiceBusConnection->getWriterSession(topic)};
    if (session != nullptr) {
      try {
        cmsTopic.reset(session->createTopic(topic));
        cmsProducer.reset(session->createProducer(cmsTopic.get()));
      } catch (...) {
        cmsTopic.reset();
        cmsProducer.reset();
        throw uci::base::UCIException("Failed to create ActiveMQ session/topic/producer");
      }
    } else {
      throw uci::base::UCIException("Topic " + topic + " not found and no DefaultConnection specified");
    }
  }

  /** The copy constructor
    *
    * @param rhs The Writer to copy from
    */
  Writer(const Writer& rhs) = delete;

  /** The move constructor
    *
    * @param rhs The Writer to move from
    */
  Writer(Writer&& rhs) = delete;

  /** The assignment operator
    *
    * @param rhs The Writer to copy from
    * @return The Writer that was assigned
    */
  Writer& operator=(const Writer& rhs) = delete;

  /** The move assignment operator
    *
    * @param rhs The Writer to move from
    * @return The Writer that was assigned
    */
  Writer& operator=(Writer&& rhs) = delete;

  /** The destructor */
  ~Writer() override {
    abstractServiceBusConnection->unRegisterWriter(this);
    close();
  }

  /** Initializes writer */
  void init() override {
    updateStatus(asbConnectionStatusData);
  }

  /** Writes the OMS message to the topic specified when this Writer was created.
    *
    * @param accessor The Accessor that provides access to the message that is to be written.
    */
  void write(T_UCI& accessor) override {
    {
      const std::lock_guard<std::mutex> guard{asbConnectionStatusDataLock};
      if (!allowWrite) {
        std::ostringstream errMsg;
        errMsg << "Unable to execute write() when the ASB state is " << asbConnectionStatusData.state;
        throw uci::base::UCIException(errMsg);
      }
    }
    if (!cmsProducer || (abstractServiceBusConnection == nullptr)) {
      throw uci::base::UCIException("Failed to write - not initialized");
    }
    T_ASB_UCI* asbAccessor{dynamic_cast<T_ASB_UCI*>(&accessor)};
    if (asbAccessor == nullptr) {
      throw uci::base::UCIException("Failed to write - invalid accessor");
    }
    try {
      boost::property_tree::ptree propTree;
      const std::string nodeName{T_ASB_UCI::serialize(*asbAccessor, propTree, "", true, false, true, true)};
      asb_uci::util::SerializationHelpers::addNamespaceAttribute(propTree, nodeName);
      std::ostringstream serializedStream;
      boost::property_tree::xml_parser::write_xml(serializedStream, propTree, boost::property_tree::xml_writer_make_settings<std::string>(' ', 2));
      const std::unique_ptr<cms::TextMessage> msg{abstractServiceBusConnection->getWriterSession(topic)->createTextMessage(serializedStream.str())};
      if (msg) {
        std::int32_t retryCount{3};
        std::string sendFailure;
        while (retryCount > 0) {
          try {
            cmsProducer->send(msg.get());
            break;
          } catch (const cms::CMSException& e) {
            --retryCount;
            sendFailure = e.what();
          }
        }
        if (retryCount == 0) {
          throw uci::base::UCIException("Write failed to send message after three attempts. Failure exception message : " + sendFailure);
        }
      } else {
        throw uci::base::UCIException("Write failed in createTextMessage >> creation failed");
      }
    } catch (const cms::CMSException& e) {
      std::ostringstream errMsg;
      errMsg << "Write failed in createTextMessage (original exception cms::CMSException) : " << e.what();
      throw uci::base::UCIException(errMsg);
    } catch (const std::exception& e) {
      std::ostringstream errMsg;
      errMsg << "Failed to write (original exception std::exception) : " << e.what();
      throw uci::base::UCIException(errMsg);
    } catch (...) {
      throw uci::base::UCIException("Failed to write, cause unknown");
    }
  }

  /** Closes the writer. Once closed, any further attempts to use this Writer to write messages will result in an undefined
    * behavior.
    */
  void close() override {
    cmsTopic.reset();
    cmsProducer.reset();
  }

  /** Update status of Abstract Service Bus Connection associated with writer
    *
    * @param newStatus New Abstract Service Bus Connection status
    */
  void updateStatus(const uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData& newStatus) override {
    const std::lock_guard<std::mutex> guard{asbConnectionStatusDataLock};
    asbConnectionStatusData = newStatus;
    allowWrite = ((asbConnectionStatusData.state == uci::base::AbstractServiceBusConnection::NORMAL) || (asbConnectionStatusData.state == uci::base::AbstractServiceBusConnection::DEGRADED));
  }

private:
  const std::string topic;
  asb_uci::base::AbstractServiceBusConnection* abstractServiceBusConnection;
  std::unique_ptr<cms::Topic> cmsTopic;
  std::unique_ptr<cms::MessageProducer> cmsProducer;
  uci::base::AbstractServiceBusConnection::AbstractServiceBusConnectionStatusData asbConnectionStatusData;
  std::mutex asbConnectionStatusDataLock;
  bool allowWrite{true};
};

} // namespace base

} // namespace asb_uci

#endif // ASB_UCI_BASE_WRITER_H
