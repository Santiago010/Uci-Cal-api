/** @file BoundedList.h
 *
 * @warning This file is automatically generated, edit at your own risk
 *
 * This file was generated on 04/01/2024 at 02:25:16 PM
 *
 * <pre>
 * Unclassified               U N C L A S S I F I E D               Unclassified
 *
 * DISTRIBUTION STATEMENT D: Distribution authorized to Department of Defense
 *    and U.S. DoD contractors only, Critical Technology, Export Controlled,
 *    26 January 2023. Other requests for this document shall be referred to
 *    AFLCMC/XA (OAMO), Wright-Patterson AFB OH 45433.
 *
 * DESTRUCTION NOTICE: Destroy by any method that will prevent disclosure of
 *    contents or reconstruction of the document.
 *
 * WARNING - This document contains technical data whose export is restricted
 *    by the Arms Export Control Act (Section 2751 of Title 22, United States
 *    Code) or the Export Control Reform Act of 2018 (Chapter 58 Sections
 *    4801-4852 of Title 50, United States Code). Violations of these export
 *    laws are subject to severe criminal penalties. Disseminate in accordance
 *    with provisions of DoD Directive 5230.25 and DoD Instruction 2040.02.
 *
 * Controlled by: USAF
 * Controlled by: AFLCMC/XA (OAMO)
 * CUI Category(ies): CTI, EXPT
 * Distribution Statement D
 * POC: Wayne Artuso, 937-713-5124
 *
 * CUI//SP-CTI/SP-EXPT
 * </pre>
 *
 */

#ifndef ASB_UCI_BASE_BOUNDEDLIST_H
#define ASB_UCI_BASE_BOUNDEDLIST_H

#include <memory>
#include <vector>

#include <boost/smart_ptr/make_unique.hpp>

#include "../../../../cppInterface/2.3.2/include/uci/base/Accessor.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/BoundedList.h"
#include "../../../../cppInterface/2.3.2/include/uci/base/UCIException.h"

/**  */
namespace asb_uci {

/** The namespace in which all base data types are declared */
namespace base {

/** The BoundedList is the base class that all bounded lists are derived from. */
template<typename T, uci::base::accessorType::AccessorType V, typename AsbT>
class BoundedList : public virtual uci::base::BoundedList<T,V> {
public:
  using size_type = typename uci::base::BoundedList<T,V>::size_type;
  using reference = typename uci::base::BoundedList<T,V>::reference;
  using const_reference = typename uci::base::BoundedList<T,V>::const_reference;

  /** The constructor
    *
    * @param min The minimum number of elements in this BoundedList
    * @param max The maximum number of elements in this BoundedList
    */
  BoundedList(size_type min, size_type max)
    : list_minimumSize{min},
      list_maximumSize{max},
      list_accessorData{boost::make_unique<std::vector<std::shared_ptr<AsbT>>>()} {
  }

  /** The copy constructor
    *
    * @param rhs The BoundedList to copy from
    */
  BoundedList(const BoundedList& rhs) = delete;

  /** The move constructor
    *
    * @param rhs The BoundedList to move from
    */
  BoundedList(BoundedList&& rhs) = delete;

  /** The assignment operator
    *
    * @param rhs The BoundedList to copy from
    * @return The BoundedList that was assigned
    */
  BoundedList& operator=(const BoundedList& rhs) = delete;

  /** The move assignment operator
    *
    * @param rhs The BoundedList to move from
    * @return The BoundedList that was assigned
    */
  BoundedList& operator=(BoundedList&& rhs) = delete;

  /** The destructor */
  virtual ~BoundedList() = default;

  /** Returns the number of elements in the BoundedList. This number is the number of actual objects held in the
    * BoundedList, which is not necessarily equal to its storage capacity.
    *
    * @return The number of actual objects held in the BoundedList.
    */
  size_type size() const noexcept override {
    return list_accessorData->size();
  }

  /** Returns the maximum number of elements that the BoundedList should hold in order to be consider valid with respect to
    * the XSD specification used to generate this containers specification. The value returned is the same that is returned
    * by the getMaxOccurs() method. If not specified in the XSD, then this is the maximum size the container can reach due
    * to known system or library implementation limitations, but the container is by no means guaranteed to be able to
    * reach that size: it can still fail to allocate storage at any point before that size is reached.
    *
    * @return The maximum number of elements that the BoundedList should hold in order to be considered valid.
    */
  size_type max_size() const noexcept override {
    return list_maximumSize;
  }


  void add(const T& item) {
      if (list_accessorData.size() >= list_maximumSize) {
            throw std::out_of_range("List has reached its maximum size");
        }
        list_accessorData.push_back(item);
  }

   // MÃ©todo para obtener los elementos de la lista (opcional)
    const std::vector<std::shared_ptr<T>>& getList() const {
        return *list_accessorData;
    }


  /** Returns the minimum number of elements the container should hold in order to be considered valid with respect to the
    * XSD specification used to generate this containers specification. The value returned is the same that is returned by
    * the getMinOccurs() method.
    *
    * @return The minimum number of elements that the BoundedList should hold in order to be considered valid.
    */
  size_type min_size() const noexcept override {
    return list_minimumSize;
  }

  /** Resizes the container so that it contains n elements.
    *
    * @param newSize The size of the container after it has been resized. If newSize is smaller than the current container
    *      size, the content of the BoundedList is reduced to its first n elements, removing those beyond (and destroying
    *      them). If newSize is greater than the current container size, the content of the BoundedList is expanded by
    *      inserting at the end as many elements as needed to reach a size of newSize. The newly added elements are value
    *      initialized (initialized according to their type). If newSize is greater than the current container capacity, an
    *      automatic reallocation of the allocated storage space takes place. Notice that this method changes the actual
    *      content of the container by inserting or erasing elements from it.
    * @param type The size of the container after it has been resized. If newSize is smaller than the current container
    *      size, the content of the BoundedList is reduced to its first n elements, removing those beyond (and destroying
    *      them). If newSize is greater than the current container size, the content of the BoundedList is expanded by
    *      inserting at the end as many elements as needed to reach a size of newSize. The newly added elements are value
    *      initialized (initialized according to their type). If newSize is greater than the current container capacity, an
    *      automatic reallocation of the allocated storage space takes place. Notice that this method changes the actual
    *      content of the container by inserting or erasing elements from it.
    */
  void resize(size_type newSize, uci::base::accessorType::AccessorType type = V) override {
    const size_type actualNewSize{(newSize < list_maximumSize) ? newSize : list_maximumSize};
    if (actualNewSize > list_accessorData->size()) {
      while (actualNewSize > list_accessorData->size()) {
        const std::shared_ptr<AsbT> newAccessor{AsbT::create(type)};
        if (!newAccessor) {
          throw uci::base::UCIException("Error in BoundedList::resize(): Specified type is not equal to nor derived from the native type of object");
        }
        list_accessorData->push_back(newAccessor);
      }
    } else {
      list_accessorData->resize(actualNewSize);
    }
  }

  /** Returns the size of allocated storage capacity expressed in terms of elements
    *
    * @return The size of the storage space currently allocated for the BoundedList, expressed in terms of elements. This
    *      capacity is not necessarily equal to the BoundedList size. It can be equal or greater, with the extra space
    *      allowing to accommodate for growth without the need to reallocate on each insertion. Notice that this capacity
    *      does not suppose a limit on the size of the BoundedList. When this capacity is exhausted and more is needed, it
    *      is automatically expanded by the container (reallocating it storage space). The theoretical limit on the size of
    *      a BoundedList is given by member max_size. The capacity of a BoundedList can be explicitly altered by calling
    *      member BoundedList::reserve.
    */
  size_type capacity() const noexcept override {
    return list_accessorData->capacity();
  }

  /** Tests whether BoundedList is empty.
    *
    * @return Returns whether the BoundedList is empty, i.e. whether its size is 0, (true) or not (false).
    * @note This function does not modify the container in any way. To clear the contents of a BoundedList, see
    *      BoundedList::clear.
    * @note This function is equivalent to "size() == 0" but may offer better performance due to implementation
    *      constraints.
    */
  bool empty() const noexcept override {
    return list_accessorData->empty();
  }

  /** Request a change in the BoundedList's capacity such that the capacity be at least large enough to contain n elements.
    *
    * @param newCapacity If newCapacity is greater than the BoundedList's current capacity, then the BoundedList's capacity
    *      will be increased to the new capacity. This action may result in a reallocation of the BoundedList's storage
    *      using new storage whose capacity is equal to or greater than newCapacity. Such a reallocation will cause all
    *      elements to be copied to the new storage and the original storage to be deleted. In all other cases, the
    *      function call does not cause a reallocation and the BoundedList capacity is not affected.
    * @note This function has no effect on the BoundedList size and cannot alter its elements.
    */
  void reserve(size_type newCapacity) override {
    list_accessorData->reserve((newCapacity < list_maximumSize) ? newCapacity : list_maximumSize);
  }

  /** Removes the last element in the BoundedList, effectively reducing the container size by one. This destroys the
    * removed element.
    */
  void pop_back() noexcept override {
    if (!list_accessorData->empty()) {
      list_accessorData->pop_back();
    }
  }

  /** Removes all elements from the BoundedList (which are destroyed), leaving the BoundedList with a size of 0. */
  void clear() noexcept override {
    list_accessorData->clear();
  }

  /** The returns this BoundedList's "maxOccurs" as specified in the XML Schema specification.
    *
    * @return The BoundedList's "maxOccurs".
    * @note The value returned is the same as that returned by max_size()
    */
  size_type getMaximumOccurs() const noexcept override {
    return list_maximumSize;
  }

  /** The returns this BoundedList's "minOccurs" as specified in the XML Schema specification.
    *
    * @return The BoundedList's "minOccurs".
    * @note The value returned is the same as that returned by min_size()
    */
  size_type getMinimumOccurs() const noexcept override {
    return list_minimumSize;
  }

  /** Returns a reference to the enumerated item at position n in the BoundedList.
    *
    * @param index The index of the element in this BoundedList a reference to which is to be returned.
    * @return The reference to the element at position n in the BoundedList.
    * @note No bounds checking is performed by this operator. See BoundedList::at() for a version of this operator that
    *      does perform bounds checking. Unexpected results, including the throwing of exceptions, may occur if the index
    *      is out of range.
    */
  reference operator[](size_type index) override {
    return *(*list_accessorData)[index];
  }

  /** Returns a reference to the enumerated item at position n in the BoundedList.
    *
    * @param index The index of the element in this BoundedList a reference to which is to be returned.
    * @return The constant reference to the element at position n in the BoundedList.
    * @note No bounds checking is performed by this operator. See BoundedList::at() for a version of this operator that
    *      does perform bounds checking. Unexpected results, including the throwing of exceptions, may occur if the index
    *      is out of range.
    */
  const_reference operator[](size_type index) const override {
    return *(*list_accessorData)[index];
  }

  /** Returns a reference to the element at position n in the BoundedList container. This method automatically checks
    * whether the index is within the bounds of valid elements in the BoundedList, throwing an out_of_range exception if it
    * is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not
    * check against bounds.
    *
    * @param index The index of the element in this BoundedList a reference to which is to be returned. If this is greater
    *      than or equal to the BoundedList size, an exception of type out_of_range is thrown. Notice that the first
    *      element has a position of 0 (not 1).
    * @return The reference to the element at position index in the BoundedList.
    */
  reference at(size_type index) override {
    if (index < list_accessorData->size()) {
      return *(*list_accessorData)[index];
    }
    throw uci::base::UCIException("Error in BoundedList::at(): Attempted to access an out of bounds index");
  }

  /** Returns a reference to the element at position n in the BoundedList container. This method automatically checks
    * whether the index is within the bounds of valid elements in the BoundedList, throwing an out_of_range exception if it
    * is not (i.e., if n is greater or equal than its size). This is in contrast with member operator[], that does not
    * check against bounds.
    *
    * @param index The index of the element in this BoundedList a reference to which is to be returned. If this is greater
    *      than or equal to the BoundedList size, an exception of type out_of_range is thrown. Notice that the first
    *      element has a position of 0 (not 1).
    * @return The reference to the enumerate item at position index in the BoundedList.
    */
  const_reference at(size_type index) const override {
    if (index < list_accessorData->size()) {
      return *(*list_accessorData)[index];
    }
    throw uci::base::UCIException("Error in BoundedList::at(): Attempted to access an out of bounds index");
  }

  /** Adds a new element at the end of the BoundedList, after its current last element. The content of value is copied (or
    * moved) to the new element. This effectively increases the container size by one, which causes an automatic
    * reallocation of the allocated storage space if, and only if, the new BoundedList size surpasses the current
    * BoundedList capacity.
    *
    * @param value The value to be copied (or moved into the new element.
    */
  void push_back(const_reference value) override {
    if (list_accessorData->size() < list_maximumSize) {
      const std::shared_ptr<AsbT> newAccessor{AsbT::create(value.getAccessorType())};
      newAccessor->copyImpl(dynamic_cast<const AsbT&>(value), true);
      list_accessorData->push_back(newAccessor);
      return;
    }
    throw uci::base::UCIException("Error in BoundedList::push_back(): Addition would exceed maximum size of list (" + std::to_string(list_maximumSize) + ")");
  }

  /** Resets the BoundedList */
  void reset() noexcept override {
    list_accessorData->clear();
  }

  /** Creates a new message data by performing a deep copy of the message data that the specified accessor provides access
    * to. The message data this accessor provides access to is freed and this accessor is updated to provide access to the
    * newly created message data.
    *
    * @param accessor The uci::base::BoundedList<T,V> whose contents are to be used to set this
    *      uci::base::BoundedList<T,V>'s contents.
    */
  void copy(const uci::base::BoundedList<T,V>& accessor) {
    copyImpl(accessor, false);
  }

  /** Creates a new message data by performing a deep copy of the message data that the specified accessor provides access
    * to. The message data this accessor provides access to is freed and this accessor is updated to provide access to the
    * newly created message data.
    *
    * @param accessor The uci::base::BoundedList<T,V> whose contents are to be used to set this
    *      uci::base::BoundedList<T,V>'s contents.
    * @param checkIfDerivation Check if accessor to copy is a derived type.
    */
  void copyImpl(const uci::base::BoundedList<T,V>& accessor, const bool /*checkIfDerivation*/) {
    if (&accessor != this) {
      const BoundedList<T,V,AsbT>& accessorImpl(dynamic_cast<const BoundedList<T,V,AsbT>&>(accessor));
      list_minimumSize = accessorImpl.list_minimumSize;
      list_maximumSize = accessorImpl.list_maximumSize;
      list_accessorData = boost::make_unique<std::vector<std::shared_ptr<AsbT>>>();
      list_accessorData->reserve(accessorImpl.list_accessorData->size());
      for (const auto& listAccessor : (*accessorImpl.list_accessorData)) {
        const std::shared_ptr<AsbT> newAccessor{AsbT::create(listAccessor->getAccessorType())};
        newAccessor->copyImpl(dynamic_cast<const AsbT&>(*listAccessor), true);
        list_accessorData->push_back(newAccessor);
      }
    }
  }

  /** 
    *
    * @param type .
    * @return .
    */
  static std::unique_ptr<BoundedList<T,V,AsbT>> create(const uci::base::accessorType::AccessorType /*type*/) {
    return boost::make_unique<BoundedList<T,V,AsbT>>();
  }

  using vector_type = std::vector<std::shared_ptr<AsbT>>;
  using iterator = typename vector_type::iterator;
  using const_iterator = typename vector_type::const_iterator;

  /** Return an iterator that represents the beginning of elements in the container
    *
    * @return .
    */
  iterator begin() noexcept {
    return list_accessorData->begin();
  }

  /** Return a const iterator that represents the beginning of elements in the container
    *
    * @return .
    */
  const_iterator cbegin() const noexcept {
    return list_accessorData->cbegin();
  }

  /** Return an iterator that represents the end of elements in the container
    *
    * @return .
    */
  iterator end() noexcept {
    return list_accessorData->end();
  }

  /** Return a const iterator that represents the end of elements in the container
    *
    * @return .
    */
  const_iterator cend() const noexcept {
    return list_accessorData->cend();
  }

private:
  size_type list_minimumSize;
  size_type list_maximumSize;
  std::unique_ptr<std::vector<std::shared_ptr<AsbT>>> list_accessorData;

};

} // namespace base

} // namespace asb_uci

#endif // ASB_UCI_BASE_BOUNDEDLIST_H
